From 5d5665e25aa2d5d3d4260b71a8d47c20f8513fbb Mon Sep 17 00:00:00 2001
From: Charitha Saumya <cgusthin@purdue.edu>
Date: Sun, 5 Nov 2023 00:33:46 -0400
Subject: [PATCH 1/3] control flow melding pass with llvm-14

---
 cfm_tests/cfg/Makefile                        |   16 +
 cfm_tests/cfg/bitonic_cfg/Makefile            |   29 +
 cfm_tests/cfg/bitonic_cfg/bitonic_cfg.c       |   32 +
 cfm_tests/cfg/config.mk                       |    6 +
 cfm_tests/cfg/cost_model/Makefile             |   51 +
 cfm_tests/cfg/cost_model/cost_model.c         |   48 +
 cfm_tests/cfg/cost_model/input1.txt           |    1 +
 cfm_tests/cfg/cost_model/input2.txt           |    1 +
 cfm_tests/cfg/dci1/after_dc_insert_0.foo.dot  |   15 +
 cfm_tests/cfg/dci1/dci1.ll                    |  119 ++
 cfm_tests/cfg/dci1/dci1.merged.ll             |   80 ++
 cfm_tests/cfg/dci1/dci1.optimized.ll          |   76 +
 cfm_tests/cfg/dci1/output.merged.txt          |    6 +
 cfm_tests/cfg/dci1/output.txt                 |    6 +
 cfm_tests/cfg/dci2/dci2.ll                    |  286 ++++
 cfm_tests/cfg/dci2/dci2.merged.ll             |   97 ++
 cfm_tests/cfg/dci2/dci2.optimized.ll          |   91 ++
 cfm_tests/cfg/dci2/out.ll                     |  221 +++
 cfm_tests/cfg/dci2/output.merged.txt          |    7 +
 cfm_tests/cfg/dci2/output.txt                 |    7 +
 cfm_tests/cfg/elseif_chain/Makefile           |   62 +
 cfm_tests/cfg/elseif_chain/elseif_chain.c     |   42 +
 cfm_tests/cfg/elseif_chain/input1.txt         |    1 +
 cfm_tests/cfg/elseif_chain/input2.txt         |    1 +
 cfm_tests/cfg/elseif_chain/input3.txt         |    1 +
 cfm_tests/cfg/ifthen1/ifthen1.ll              |  110 ++
 cfm_tests/cfg/ifthen1/ifthen1.merged.ll       |   72 +
 cfm_tests/cfg/ifthen1/ifthen1.optimized.ll    |   69 +
 cfm_tests/cfg/ifthen1/output.merged.txt       |    6 +
 cfm_tests/cfg/ifthen1/output.txt              |    6 +
 cfm_tests/cfg/ifthen2/ifthen2.ll              |  129 ++
 cfm_tests/cfg/ifthen2/ifthen2.merged.ll       |   89 ++
 cfm_tests/cfg/ifthen2/ifthen2.optimized.ll    |   82 ++
 cfm_tests/cfg/ifthen2/output.merged.txt       |    7 +
 cfm_tests/cfg/ifthen2/output.txt              |    7 +
 cfm_tests/cfg/loop_with_single_bb/Makefile    |   31 +
 .../loop_with_single_bb/loop_with_single_bb.c |   44 +
 cfm_tests/cfg/lud_cfg/Makefile                |    4 +
 cfm_tests/cfg/lud_cfg/lud_cfg.c               |   40 +
 cfm_tests/cfg/nested_if/Makefile              |   73 +
 cfm_tests/cfg/nested_if/input1.txt            |    1 +
 cfm_tests/cfg/nested_if/input2.txt            |    1 +
 cfm_tests/cfg/nested_if/input3.txt            |    1 +
 cfm_tests/cfg/nested_if/input4.txt            |    1 +
 cfm_tests/cfg/nested_if/nested_if.c           |   54 +
 cfm_tests/cfg/nested_if2/Makefile             |   84 ++
 cfm_tests/cfg/nested_if2/input1.txt           |    1 +
 cfm_tests/cfg/nested_if2/input2.txt           |    1 +
 cfm_tests/cfg/nested_if2/input3.txt           |    1 +
 cfm_tests/cfg/nested_if2/input4.txt           |    1 +
 cfm_tests/cfg/nested_if2/nested_if2.c         |   39 +
 cfm_tests/cfg/nested_if3/Makefile             |   73 +
 cfm_tests/cfg/nested_if3/input1.txt           |    1 +
 cfm_tests/cfg/nested_if3/input2.txt           |    1 +
 cfm_tests/cfg/nested_if3/input3.txt           |    1 +
 cfm_tests/cfg/nested_if3/input4.txt           |    1 +
 cfm_tests/cfg/nested_if3/nested_if3.c         |   46 +
 cfm_tests/cfg/nested_if4/Makefile             |  132 ++
 cfm_tests/cfg/nested_if4/input1.txt           |    1 +
 cfm_tests/cfg/nested_if4/input2.txt           |    1 +
 cfm_tests/cfg/nested_if4/input3.txt           |    1 +
 cfm_tests/cfg/nested_if4/input4.txt           |    1 +
 cfm_tests/cfg/nested_if4/input5.txt           |    1 +
 cfm_tests/cfg/nested_if4/input6.txt           |    1 +
 cfm_tests/cfg/nested_if4/input7.txt           |    1 +
 cfm_tests/cfg/nested_if4/input8.txt           |    1 +
 cfm_tests/cfg/nested_if4/nested_if4.c         |   54 +
 cfm_tests/cfg/nested_if_asym/Makefile         |   84 ++
 cfm_tests/cfg/nested_if_asym/input1.txt       |    1 +
 cfm_tests/cfg/nested_if_asym/input2.txt       |    1 +
 cfm_tests/cfg/nested_if_asym/input3.txt       |    1 +
 cfm_tests/cfg/nested_if_asym/nested_if_asym.c |   41 +
 cfm_tests/cfg/nested_if_while/Makefile        |   77 +
 cfm_tests/cfg/nested_if_while/cfg12/Makefile  |  122 ++
 .../cfg/nested_if_while/cfg12/input1.txt      |    1 +
 .../cfg/nested_if_while/cfg12/input2.txt      |    1 +
 .../cfg/nested_if_while/cfg12/input3.txt      |    1 +
 .../cfg/nested_if_while/cfg12/input4.txt      |    1 +
 .../cfg/nested_if_while/cfg12/input5.txt      |    1 +
 .../cfg/nested_if_while/cfg12/input6.txt      |    1 +
 .../nested_if_while/cfg12/nested_if_while.c   |   56 +
 cfm_tests/cfg/nested_if_while/input1.txt      |    1 +
 cfm_tests/cfg/nested_if_while/input2.txt      |    1 +
 cfm_tests/cfg/nested_if_while/input3.txt      |    1 +
 cfm_tests/cfg/nested_if_while/input4.txt      |    1 +
 .../cfg/nested_if_while/nested_if_while.c     |   51 +
 cfm_tests/cfg/nested_if_while2/Makefile       |   84 ++
 cfm_tests/cfg/nested_if_while2/input1.txt     |    1 +
 cfm_tests/cfg/nested_if_while2/input2.txt     |    1 +
 cfm_tests/cfg/nested_if_while2/input3.txt     |    1 +
 cfm_tests/cfg/nested_if_while2/input4.txt     |    1 +
 cfm_tests/cfg/nested_if_while2/input5.txt     |    1 +
 .../cfg/nested_if_while2/nested_if_while2.c   |   43 +
 cfm_tests/cfg/path_between_blocks/Makefile    |   34 +
 .../path_between_blocks/path_betweek_blocks.c |   54 +
 cfm_tests/cfg/simple_if_else/Makefile         |   51 +
 cfm_tests/cfg/simple_if_else/input1.txt       |    1 +
 cfm_tests/cfg/simple_if_else/input2.txt       |    1 +
 cfm_tests/cfg/simple_if_else/simple_if_else.c |   39 +
 cfm_tests/cfg/simple_if_else2/Makefile        |   52 +
 cfm_tests/cfg/simple_if_else2/input1.txt      |    1 +
 cfm_tests/cfg/simple_if_else2/input2.txt      |    1 +
 .../cfg/simple_if_else2/simple_if_else2.c     |   24 +
 cfm_tests/cfg/unify_phi/Makefile              |  111 ++
 cfm_tests/cfg/unify_phi/cfg16.c               |   52 +
 cfm_tests/cfg/unify_phi/input1.txt            |    1 +
 cfm_tests/cfg/unify_phi/input2.txt            |    1 +
 cfm_tests/cfg/unify_phi/input3.txt            |    1 +
 cfm_tests/cfg/unify_phi/input4.txt            |    1 +
 cfm_tests/cfg/unify_phi/input5.txt            |    1 +
 cfm_tests/cfg/unify_phi/input6.txt            |    1 +
 cfm_tests/cfg/unify_phi/input7.txt            |    1 +
 llvm/include/llvm/InitializePasses.h          |    6 +
 llvm/include/llvm/LinkAllPasses.h             |    2 +
 .../llvm/Transforms/CFMelder/CFMelder.h       |   34 +
 llvm/lib/Passes/CMakeLists.txt                |    1 +
 llvm/lib/Passes/PassBuilder.cpp               |    1 +
 llvm/lib/Passes/PassBuilderPipelines.cpp      |   13 +
 llvm/lib/Passes/PassRegistry.def              |    1 +
 llvm/lib/Transforms/CFMelder/CFMelder.cpp     |  563 ++++++++
 .../lib/Transforms/CFMelder/CFMelderUtils.cpp | 1053 ++++++++++++++
 llvm/lib/Transforms/CFMelder/CFMelderUtils.h  |  119 ++
 llvm/lib/Transforms/CFMelder/CMakeLists.txt   |   46 +
 .../lib/Transforms/CFMelder/NeedlemanWunsch.h |  105 ++
 .../Transforms/CFMelder/RegionAnalyzer.cpp    |  742 ++++++++++
 llvm/lib/Transforms/CFMelder/RegionAnalyzer.h |  197 +++
 llvm/lib/Transforms/CFMelder/RegionMelder.cpp | 1259 +++++++++++++++++
 llvm/lib/Transforms/CFMelder/RegionMelder.h   |  190 +++
 .../Transforms/CFMelder/RegionReplicator.cpp  |  499 +++++++
 .../Transforms/CFMelder/RegionReplicator.h    |   39 +
 .../Transforms/CFMelder/SeqAlignmentUtils.h   |  161 +++
 llvm/lib/Transforms/CFMelder/SmithWaterman.h  |  184 +++
 llvm/lib/Transforms/CMakeLists.txt            |    1 +
 llvm/tools/bugpoint/CMakeLists.txt            |    1 +
 llvm/tools/opt/CMakeLists.txt                 |    1 +
 llvm/tools/opt/opt.cpp                        |    1 +
 136 files changed, 8796 insertions(+)
 create mode 100644 cfm_tests/cfg/Makefile
 create mode 100644 cfm_tests/cfg/bitonic_cfg/Makefile
 create mode 100644 cfm_tests/cfg/bitonic_cfg/bitonic_cfg.c
 create mode 100644 cfm_tests/cfg/config.mk
 create mode 100644 cfm_tests/cfg/cost_model/Makefile
 create mode 100644 cfm_tests/cfg/cost_model/cost_model.c
 create mode 100644 cfm_tests/cfg/cost_model/input1.txt
 create mode 100644 cfm_tests/cfg/cost_model/input2.txt
 create mode 100644 cfm_tests/cfg/dci1/after_dc_insert_0.foo.dot
 create mode 100644 cfm_tests/cfg/dci1/dci1.ll
 create mode 100644 cfm_tests/cfg/dci1/dci1.merged.ll
 create mode 100644 cfm_tests/cfg/dci1/dci1.optimized.ll
 create mode 100644 cfm_tests/cfg/dci1/output.merged.txt
 create mode 100644 cfm_tests/cfg/dci1/output.txt
 create mode 100644 cfm_tests/cfg/dci2/dci2.ll
 create mode 100644 cfm_tests/cfg/dci2/dci2.merged.ll
 create mode 100644 cfm_tests/cfg/dci2/dci2.optimized.ll
 create mode 100644 cfm_tests/cfg/dci2/out.ll
 create mode 100644 cfm_tests/cfg/dci2/output.merged.txt
 create mode 100644 cfm_tests/cfg/dci2/output.txt
 create mode 100644 cfm_tests/cfg/elseif_chain/Makefile
 create mode 100644 cfm_tests/cfg/elseif_chain/elseif_chain.c
 create mode 100644 cfm_tests/cfg/elseif_chain/input1.txt
 create mode 100644 cfm_tests/cfg/elseif_chain/input2.txt
 create mode 100644 cfm_tests/cfg/elseif_chain/input3.txt
 create mode 100644 cfm_tests/cfg/ifthen1/ifthen1.ll
 create mode 100644 cfm_tests/cfg/ifthen1/ifthen1.merged.ll
 create mode 100644 cfm_tests/cfg/ifthen1/ifthen1.optimized.ll
 create mode 100644 cfm_tests/cfg/ifthen1/output.merged.txt
 create mode 100644 cfm_tests/cfg/ifthen1/output.txt
 create mode 100644 cfm_tests/cfg/ifthen2/ifthen2.ll
 create mode 100644 cfm_tests/cfg/ifthen2/ifthen2.merged.ll
 create mode 100644 cfm_tests/cfg/ifthen2/ifthen2.optimized.ll
 create mode 100644 cfm_tests/cfg/ifthen2/output.merged.txt
 create mode 100644 cfm_tests/cfg/ifthen2/output.txt
 create mode 100644 cfm_tests/cfg/loop_with_single_bb/Makefile
 create mode 100644 cfm_tests/cfg/loop_with_single_bb/loop_with_single_bb.c
 create mode 100644 cfm_tests/cfg/lud_cfg/Makefile
 create mode 100644 cfm_tests/cfg/lud_cfg/lud_cfg.c
 create mode 100644 cfm_tests/cfg/nested_if/Makefile
 create mode 100644 cfm_tests/cfg/nested_if/input1.txt
 create mode 100644 cfm_tests/cfg/nested_if/input2.txt
 create mode 100644 cfm_tests/cfg/nested_if/input3.txt
 create mode 100644 cfm_tests/cfg/nested_if/input4.txt
 create mode 100644 cfm_tests/cfg/nested_if/nested_if.c
 create mode 100644 cfm_tests/cfg/nested_if2/Makefile
 create mode 100644 cfm_tests/cfg/nested_if2/input1.txt
 create mode 100644 cfm_tests/cfg/nested_if2/input2.txt
 create mode 100644 cfm_tests/cfg/nested_if2/input3.txt
 create mode 100644 cfm_tests/cfg/nested_if2/input4.txt
 create mode 100644 cfm_tests/cfg/nested_if2/nested_if2.c
 create mode 100644 cfm_tests/cfg/nested_if3/Makefile
 create mode 100644 cfm_tests/cfg/nested_if3/input1.txt
 create mode 100644 cfm_tests/cfg/nested_if3/input2.txt
 create mode 100644 cfm_tests/cfg/nested_if3/input3.txt
 create mode 100644 cfm_tests/cfg/nested_if3/input4.txt
 create mode 100644 cfm_tests/cfg/nested_if3/nested_if3.c
 create mode 100644 cfm_tests/cfg/nested_if4/Makefile
 create mode 100644 cfm_tests/cfg/nested_if4/input1.txt
 create mode 100644 cfm_tests/cfg/nested_if4/input2.txt
 create mode 100644 cfm_tests/cfg/nested_if4/input3.txt
 create mode 100644 cfm_tests/cfg/nested_if4/input4.txt
 create mode 100644 cfm_tests/cfg/nested_if4/input5.txt
 create mode 100644 cfm_tests/cfg/nested_if4/input6.txt
 create mode 100644 cfm_tests/cfg/nested_if4/input7.txt
 create mode 100644 cfm_tests/cfg/nested_if4/input8.txt
 create mode 100644 cfm_tests/cfg/nested_if4/nested_if4.c
 create mode 100644 cfm_tests/cfg/nested_if_asym/Makefile
 create mode 100644 cfm_tests/cfg/nested_if_asym/input1.txt
 create mode 100644 cfm_tests/cfg/nested_if_asym/input2.txt
 create mode 100644 cfm_tests/cfg/nested_if_asym/input3.txt
 create mode 100644 cfm_tests/cfg/nested_if_asym/nested_if_asym.c
 create mode 100644 cfm_tests/cfg/nested_if_while/Makefile
 create mode 100644 cfm_tests/cfg/nested_if_while/cfg12/Makefile
 create mode 100644 cfm_tests/cfg/nested_if_while/cfg12/input1.txt
 create mode 100644 cfm_tests/cfg/nested_if_while/cfg12/input2.txt
 create mode 100644 cfm_tests/cfg/nested_if_while/cfg12/input3.txt
 create mode 100644 cfm_tests/cfg/nested_if_while/cfg12/input4.txt
 create mode 100644 cfm_tests/cfg/nested_if_while/cfg12/input5.txt
 create mode 100644 cfm_tests/cfg/nested_if_while/cfg12/input6.txt
 create mode 100644 cfm_tests/cfg/nested_if_while/cfg12/nested_if_while.c
 create mode 100644 cfm_tests/cfg/nested_if_while/input1.txt
 create mode 100644 cfm_tests/cfg/nested_if_while/input2.txt
 create mode 100644 cfm_tests/cfg/nested_if_while/input3.txt
 create mode 100644 cfm_tests/cfg/nested_if_while/input4.txt
 create mode 100644 cfm_tests/cfg/nested_if_while/nested_if_while.c
 create mode 100644 cfm_tests/cfg/nested_if_while2/Makefile
 create mode 100644 cfm_tests/cfg/nested_if_while2/input1.txt
 create mode 100644 cfm_tests/cfg/nested_if_while2/input2.txt
 create mode 100644 cfm_tests/cfg/nested_if_while2/input3.txt
 create mode 100644 cfm_tests/cfg/nested_if_while2/input4.txt
 create mode 100644 cfm_tests/cfg/nested_if_while2/input5.txt
 create mode 100644 cfm_tests/cfg/nested_if_while2/nested_if_while2.c
 create mode 100644 cfm_tests/cfg/path_between_blocks/Makefile
 create mode 100644 cfm_tests/cfg/path_between_blocks/path_betweek_blocks.c
 create mode 100644 cfm_tests/cfg/simple_if_else/Makefile
 create mode 100644 cfm_tests/cfg/simple_if_else/input1.txt
 create mode 100644 cfm_tests/cfg/simple_if_else/input2.txt
 create mode 100644 cfm_tests/cfg/simple_if_else/simple_if_else.c
 create mode 100644 cfm_tests/cfg/simple_if_else2/Makefile
 create mode 100644 cfm_tests/cfg/simple_if_else2/input1.txt
 create mode 100644 cfm_tests/cfg/simple_if_else2/input2.txt
 create mode 100644 cfm_tests/cfg/simple_if_else2/simple_if_else2.c
 create mode 100644 cfm_tests/cfg/unify_phi/Makefile
 create mode 100644 cfm_tests/cfg/unify_phi/cfg16.c
 create mode 100644 cfm_tests/cfg/unify_phi/input1.txt
 create mode 100644 cfm_tests/cfg/unify_phi/input2.txt
 create mode 100644 cfm_tests/cfg/unify_phi/input3.txt
 create mode 100644 cfm_tests/cfg/unify_phi/input4.txt
 create mode 100644 cfm_tests/cfg/unify_phi/input5.txt
 create mode 100644 cfm_tests/cfg/unify_phi/input6.txt
 create mode 100644 cfm_tests/cfg/unify_phi/input7.txt
 create mode 100644 llvm/include/llvm/Transforms/CFMelder/CFMelder.h
 create mode 100644 llvm/lib/Transforms/CFMelder/CFMelder.cpp
 create mode 100644 llvm/lib/Transforms/CFMelder/CFMelderUtils.cpp
 create mode 100644 llvm/lib/Transforms/CFMelder/CFMelderUtils.h
 create mode 100644 llvm/lib/Transforms/CFMelder/CMakeLists.txt
 create mode 100644 llvm/lib/Transforms/CFMelder/NeedlemanWunsch.h
 create mode 100644 llvm/lib/Transforms/CFMelder/RegionAnalyzer.cpp
 create mode 100644 llvm/lib/Transforms/CFMelder/RegionAnalyzer.h
 create mode 100644 llvm/lib/Transforms/CFMelder/RegionMelder.cpp
 create mode 100644 llvm/lib/Transforms/CFMelder/RegionMelder.h
 create mode 100644 llvm/lib/Transforms/CFMelder/RegionReplicator.cpp
 create mode 100644 llvm/lib/Transforms/CFMelder/RegionReplicator.h
 create mode 100644 llvm/lib/Transforms/CFMelder/SeqAlignmentUtils.h
 create mode 100644 llvm/lib/Transforms/CFMelder/SmithWaterman.h

diff --git a/cfm_tests/cfg/Makefile b/cfm_tests/cfg/Makefile
new file mode 100644
index 000000000000..3da097306714
--- /dev/null
+++ b/cfm_tests/cfg/Makefile
@@ -0,0 +1,16 @@
+SUBDIRS =  bitonic_cfg  cost_model loop_with_single_bb nested_if2  nested_if4  nested_if_while   simple_if_else   unify_phi elseif_chain  lud_cfg nested_if  nested_if3 nested_if_asym  nested_if_while2  simple_if_else2
+
+.PHONY: subdirs $(SUBDIRS)
+
+subdirs: $(SUBDIRS)
+
+$(SUBDIRS):
+	$(MAKE) -C $@
+
+test :
+	$(foreach dir, $(SUBDIRS), make -C $(dir) test;)
+	
+	
+clean :
+
+	$(foreach dir, $(SUBDIRS), make -C $(dir) clean;)
diff --git a/cfm_tests/cfg/bitonic_cfg/Makefile b/cfm_tests/cfg/bitonic_cfg/Makefile
new file mode 100644
index 000000000000..f6e5693833f5
--- /dev/null
+++ b/cfm_tests/cfg/bitonic_cfg/Makefile
@@ -0,0 +1,29 @@
+include ../config.mk
+
+clang_flags=-emit-llvm -S -Xclang -disable-O0-optnone 
+opt_flags=-O2 -S
+
+obj := $(patsubst %.c,%.merged.ll,$(wildcard *.c))
+inputs := $(wildcard input*.txt)
+all : ${obj}
+	
+%.merged.ll : %.c	
+	${clang} ${clang_flags} $^
+	${opt} ${opt_flags} < $(patsubst %.c,%.ll,$^) > $(patsubst %.c,%.optimized.ll,$^)
+	${opt} ${cfmerger_flags} < $(patsubst %.c,%.optimized.ll,$^) > $@
+
+
+test : is_same
+
+is_same : ${obj}
+	@cmp -s  $(patsubst %.merged.ll,%.optimized.ll,$^) $^ ; \
+	RETVAL=$$?; \
+	if [ $$RETVAL -eq 0 ]; then \
+					echo "ERROR : transformation did NOT change source IR"; \
+	else \
+					echo "SUCCESS : transformation did change source IR"; \
+	fi
+
+clean :
+	rm  -f *.ll output*.*
+
diff --git a/cfm_tests/cfg/bitonic_cfg/bitonic_cfg.c b/cfm_tests/cfg/bitonic_cfg/bitonic_cfg.c
new file mode 100644
index 000000000000..d5b66a1d9952
--- /dev/null
+++ b/cfm_tests/cfg/bitonic_cfg/bitonic_cfg.c
@@ -0,0 +1,32 @@
+#include <stdio.h>
+
+void foo(int threadIdx, int THREADS, int *shared, int sb) {
+
+  for (int k = 2; k <= sb; k *= 2) {
+    // Bitonic merge:
+    for (int j = k / 2; j > 0; j /= 2) {
+      for (int tid = threadIdx; tid < sb; tid += THREADS) {
+        unsigned int ixj = tid ^ j;
+        int a = shared[tid];
+        if (ixj > tid) {
+          if ((tid & k) == 0) {
+            if (shared[tid] > shared[ixj]) {
+              int temp = shared[tid];
+              shared[tid] = shared[ixj];
+              shared[ixj] = temp;
+              a--;
+            }
+          } else {
+            if (shared[tid] < shared[ixj]) {
+              int temp = shared[tid];
+              shared[tid] = shared[ixj];
+              shared[ixj] = temp;
+              a++;
+            }
+          }
+          printf("%d", a);
+        }
+      }
+    }
+  }
+}
diff --git a/cfm_tests/cfg/config.mk b/cfm_tests/cfg/config.mk
new file mode 100644
index 000000000000..381fb93e3e3e
--- /dev/null
+++ b/cfm_tests/cfg/config.mk
@@ -0,0 +1,6 @@
+LLVM_HOME=/home/min/a/cgusthin/git/llvm-project-rocm/build_codesize
+clang=$(LLVM_HOME)/bin/clang
+opt=$(LLVM_HOME)/bin/opt
+lli=$(LLVM_HOME)/bin/lli
+#pass_location=$(LLVM_HOME)/lib/LLVMCFMelderPlugin.so
+cfmerger_flags=-cfmelder  -S -force-cf-merging 
diff --git a/cfm_tests/cfg/cost_model/Makefile b/cfm_tests/cfg/cost_model/Makefile
new file mode 100644
index 000000000000..f5fff3bba1db
--- /dev/null
+++ b/cfm_tests/cfg/cost_model/Makefile
@@ -0,0 +1,51 @@
+include ../config.mk
+clang_flags=-emit-llvm -S -Xclang -disable-O0-optnone 
+opt_flags=-sroa -S
+
+obj := $(patsubst %.c,%.merged.ll,$(wildcard *.c))
+inputs := $(wildcard input*.txt)
+all : ${obj}
+	
+%.merged.ll : %.c	
+	${clang} ${clang_flags} $^
+	${opt} ${opt_flags} < $(patsubst %.c,%.ll,$^) > $(patsubst %.c,%.optimized.ll,$^)
+	${opt}  ${cfmerger_flags} < $(patsubst %.c,%.optimized.ll,$^) > $@
+
+
+test : is_same test1 test2
+
+is_same : ${obj}
+	@cmp -s  $(patsubst %.merged.ll,%.optimized.ll,$^) $^ ; \
+	RETVAL=$$?; \
+	if [ $$RETVAL -eq 0 ]; then \
+					echo "ERROR : transformation did NOT change source IR"; \
+	else \
+					echo "SUCCESS : transformation did change source IR"; \
+	fi
+
+
+test1  : input1.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test2 : input2.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+
+clean :
+	rm  -f *.ll output*.*
+
diff --git a/cfm_tests/cfg/cost_model/cost_model.c b/cfm_tests/cfg/cost_model/cost_model.c
new file mode 100644
index 000000000000..d08586916813
--- /dev/null
+++ b/cfm_tests/cfg/cost_model/cost_model.c
@@ -0,0 +1,48 @@
+#include <stdio.h>
+void foo(int *a1, int *a2, int *a3, int *a4, int *a5, int *a6) {
+  int a = *a1;
+  int b = *a2;
+  int c = *a3;
+  int d = *a4;
+  int e = *a5;
+  int f = *a6;
+
+  if (a > 0) {
+    a = a + b;
+    b = c - d;
+    c = c / 5;
+    d = d >> 2;
+    a = a << 2;
+    e = e * f;
+    f = a & b;
+  } else {
+    a = e + f;
+    b = c - f;
+    c = b | e;
+    a = e ^ f;
+    d = c / 4;
+    e = a * b;
+    f = a & b;
+
+  }
+
+  printf("a=%d\n"
+         "b=%d\n"
+         "c=%d\n"
+         "d=%d\n"
+         "e=%d\n"
+         "f=%d\n",
+         a, b, c, d, e, f);
+}
+
+int main() {
+  int a, b, c, d, e, f;
+  scanf("%d", &a);
+  scanf("%d", &b);
+  scanf("%d", &c);
+  scanf("%d", &d);
+  scanf("%d", &e);
+  scanf("%d", &f);
+
+  foo(&a, &b, &c, &d, &e, &f);
+}
diff --git a/cfm_tests/cfg/cost_model/input1.txt b/cfm_tests/cfg/cost_model/input1.txt
new file mode 100644
index 000000000000..b61b7c26ca70
--- /dev/null
+++ b/cfm_tests/cfg/cost_model/input1.txt
@@ -0,0 +1 @@
+1 2 3 4 5 6
diff --git a/cfm_tests/cfg/cost_model/input2.txt b/cfm_tests/cfg/cost_model/input2.txt
new file mode 100644
index 000000000000..c8b0cf9293b6
--- /dev/null
+++ b/cfm_tests/cfg/cost_model/input2.txt
@@ -0,0 +1 @@
+0 2 3 4 5 6
diff --git a/cfm_tests/cfg/dci1/after_dc_insert_0.foo.dot b/cfm_tests/cfg/dci1/after_dc_insert_0.foo.dot
new file mode 100644
index 000000000000..7921ef6c1dcc
--- /dev/null
+++ b/cfm_tests/cfg/dci1/after_dc_insert_0.foo.dot
@@ -0,0 +1,15 @@
+digraph "CFG for 'foo' function" {
+	label="CFG for 'foo' function";
+
+	Node0x55e46b8d9dc0 [shape=record,label="{entry:\l  %0 = load i32, i32* %a1, align 4\l  %1 = load i32, i32* %a2, align 4\l  %2 = load i32, i32* %a3, align 4\l  %3 = load i32, i32* %a4, align 4\l  %4 = load i32, i32* %a5, align 4\l  %5 = load i32, i32* %a6, align 4\l  %cmp = icmp sgt i32 %0, 0\l  %cfmse.dci_gep = getelementptr [8 x i8], [8 x i8]* @cfmse.dci_gv, i64 0, i64\l... 0\l  br i1 %cmp, label %unify.bb, label %unify.bb\l|{<s0>T|<s1>F}}"];
+	Node0x55e46b8d9dc0:s0 -> Node0x55e46b910ef0;
+	Node0x55e46b8d9dc0:s1 -> Node0x55e46b910ef0;
+	Node0x55e46b910ef0 [shape=record,label="{unify.bb:                                         \l  br i1 %cmp, label %if.then, label %if.else\l|{<s0>T|<s1>F}}"];
+	Node0x55e46b910ef0:s0 -> Node0x55e46b8dca60;
+	Node0x55e46b910ef0:s1 -> Node0x55e46b8dcab0;
+	Node0x55e46b8dca60 [shape=record,label="{if.then:                                          \l  %inc = add nsw i32 %0, 1\l  %dec = add nsw i32 %1, -1\l  %dec1 = add nsw i32 %2, -1\l  %mul = mul nsw i32 %3, 3\l  br label %if.end\l}"];
+	Node0x55e46b8dca60 -> Node0x55e46b8dd120;
+	Node0x55e46b8dcab0 [shape=record,label="{if.else:                                          \l  %6 = add nsw i32 %0, 0\l  %7 = add nsw i32 %1, 0\l  %inc2 = add nsw i32 %5, 1\l  %mul3 = mul nsw i32 %4, 4\l  br label %if.end\l}"];
+	Node0x55e46b8dcab0 -> Node0x55e46b8dd120;
+	Node0x55e46b8dd120 [shape=record,label="{if.end:                                           \l  %a.0 = phi i32 [ %inc, %if.then ], [ %0, %if.else ]\l  %b.0 = phi i32 [ %dec, %if.then ], [ %1, %if.else ]\l  %c.0 = phi i32 [ %dec1, %if.then ], [ %2, %if.else ]\l  %d.0 = phi i32 [ %mul, %if.then ], [ %3, %if.else ]\l  %e.0 = phi i32 [ %4, %if.then ], [ %mul3, %if.else ]\l  %f.0 = phi i32 [ %5, %if.then ], [ %inc2, %if.else ]\l  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8],\l... [31 x i8]* @.str, i64 0, i64 0), i32 %a.0, i32 %b.0, i32 %c.0, i32 %d.0, i32\l... %e.0, i32 %f.0)\l  ret void\l}"];
+}
diff --git a/cfm_tests/cfg/dci1/dci1.ll b/cfm_tests/cfg/dci1/dci1.ll
new file mode 100644
index 000000000000..4b71b971bbc3
--- /dev/null
+++ b/cfm_tests/cfg/dci1/dci1.ll
@@ -0,0 +1,119 @@
+; ModuleID = 'dci1.c'
+source_filename = "dci1.c"
+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-gnu"
+
+@.str = private unnamed_addr constant [31 x i8] c"a=%d\0Ab=%d\0Ac=%d\0Ad=%d\0Ae=%d\0Af=%d\0A\00", align 1
+@.str.1 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local void @foo(i32* %a1, i32* %a2, i32* %a3, i32* %a4, i32* %a5, i32* %a6) #0 {
+entry:
+  %a1.addr = alloca i32*, align 8
+  %a2.addr = alloca i32*, align 8
+  %a3.addr = alloca i32*, align 8
+  %a4.addr = alloca i32*, align 8
+  %a5.addr = alloca i32*, align 8
+  %a6.addr = alloca i32*, align 8
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  store i32* %a1, i32** %a1.addr, align 8
+  store i32* %a2, i32** %a2.addr, align 8
+  store i32* %a3, i32** %a3.addr, align 8
+  store i32* %a4, i32** %a4.addr, align 8
+  store i32* %a5, i32** %a5.addr, align 8
+  store i32* %a6, i32** %a6.addr, align 8
+  %0 = load i32*, i32** %a1.addr, align 8
+  %1 = load i32, i32* %0, align 4
+  store i32 %1, i32* %a, align 4
+  %2 = load i32*, i32** %a2.addr, align 8
+  %3 = load i32, i32* %2, align 4
+  store i32 %3, i32* %b, align 4
+  %4 = load i32*, i32** %a3.addr, align 8
+  %5 = load i32, i32* %4, align 4
+  store i32 %5, i32* %c, align 4
+  %6 = load i32*, i32** %a4.addr, align 8
+  %7 = load i32, i32* %6, align 4
+  store i32 %7, i32* %d, align 4
+  %8 = load i32*, i32** %a5.addr, align 8
+  %9 = load i32, i32* %8, align 4
+  store i32 %9, i32* %e, align 4
+  %10 = load i32*, i32** %a6.addr, align 8
+  %11 = load i32, i32* %10, align 4
+  store i32 %11, i32* %f, align 4
+  %12 = load i32, i32* %a, align 4
+  %cmp = icmp sgt i32 %12, 0
+  br i1 %cmp, label %if.then, label %if.else
+
+if.then:                                          ; preds = %entry
+  %13 = load i32, i32* %a, align 4
+  %inc = add nsw i32 %13, 1
+  store i32 %inc, i32* %a, align 4
+  %14 = load i32, i32* %b, align 4
+  %dec = add nsw i32 %14, -1
+  store i32 %dec, i32* %b, align 4
+  %15 = load i32, i32* %c, align 4
+  %dec1 = add nsw i32 %15, -1
+  store i32 %dec1, i32* %c, align 4
+  %16 = load i32, i32* %d, align 4
+  %mul = mul nsw i32 %16, 3
+  store i32 %mul, i32* %d, align 4
+  br label %if.end
+
+if.else:                                          ; preds = %entry
+  %17 = load i32, i32* %f, align 4
+  %inc2 = add nsw i32 %17, 1
+  store i32 %inc2, i32* %f, align 4
+  %18 = load i32, i32* %e, align 4
+  %mul3 = mul nsw i32 %18, 4
+  store i32 %mul3, i32* %e, align 4
+  br label %if.end
+
+if.end:                                           ; preds = %if.else, %if.then
+  %19 = load i32, i32* %a, align 4
+  %20 = load i32, i32* %b, align 4
+  %21 = load i32, i32* %c, align 4
+  %22 = load i32, i32* %d, align 4
+  %23 = load i32, i32* %e, align 4
+  %24 = load i32, i32* %f, align 4
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str, i64 0, i64 0), i32 %19, i32 %20, i32 %21, i32 %22, i32 %23, i32 %24)
+  ret void
+}
+
+declare dso_local i32 @printf(i8*, ...) #1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local i32 @main() #0 {
+entry:
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  %call = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %a)
+  %call1 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %b)
+  %call2 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %c)
+  %call3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %d)
+  %call4 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %e)
+  %call5 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %f)
+  call void @foo(i32* %a, i32* %b, i32* %c, i32* %d, i32* %e, i32* %f)
+  ret i32 0
+}
+
+declare dso_local i32 @__isoc99_scanf(i8*, ...) #1
+
+attributes #0 = { noinline nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+
+!llvm.module.flags = !{!0, !1, !2}
+!llvm.ident = !{!3}
+
+!0 = !{i32 1, !"wchar_size", i32 4}
+!1 = !{i32 7, !"uwtable", i32 1}
+!2 = !{i32 7, !"frame-pointer", i32 2}
+!3 = !{!"clang version 14.0.0 (git@github.com:charitha22/llvm-project-rocm.git 9b11feafa64c148db02b5b50badeead69ea85de8)"}
diff --git a/cfm_tests/cfg/dci1/dci1.merged.ll b/cfm_tests/cfg/dci1/dci1.merged.ll
new file mode 100644
index 000000000000..ea2124ab4317
--- /dev/null
+++ b/cfm_tests/cfg/dci1/dci1.merged.ll
@@ -0,0 +1,80 @@
+; ModuleID = '<stdin>'
+source_filename = "dci1.c"
+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-gnu"
+
+@.str = private unnamed_addr constant [31 x i8] c"a=%d\0Ab=%d\0Ac=%d\0Ad=%d\0Ae=%d\0Af=%d\0A\00", align 1
+@.str.1 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
+@cfmse.dci_gv = private global [8 x i8] zeroinitializer
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local void @foo(i32* %a1, i32* %a2, i32* %a3, i32* %a4, i32* %a5, i32* %a6) #0 {
+entry:
+  %0 = load i32, i32* %a1, align 4
+  %1 = load i32, i32* %a2, align 4
+  %2 = load i32, i32* %a3, align 4
+  %3 = load i32, i32* %a4, align 4
+  %4 = load i32, i32* %a5, align 4
+  %5 = load i32, i32* %a6, align 4
+  %cmp = icmp sgt i32 %0, 0
+  %cfmse.dci_gep = getelementptr [8 x i8], [8 x i8]* @cfmse.dci_gv, i64 0, i64 0
+  br label %merged.bb
+
+if.end:                                           ; preds = %merged.bb
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str, i64 0, i64 0), i32 %moved.sel, i32 %moved.sel7, i32 %moved.sel8, i32 %moved.sel9, i32 %moved.sel10, i32 %moved.sel11)
+  ret void
+
+merged.bb:                                        ; preds = %entry
+  %merged.select = select i1 %cmp, i32 1, i32 0
+  %6 = add nsw i32 %0, %merged.select
+  %merged.select1 = select i1 %cmp, i32 -1, i32 0
+  %7 = add nsw i32 %1, %merged.select1
+  %merged.select2 = select i1 %cmp, i32 %2, i32 %5
+  %merged.select3 = select i1 %cmp, i32 -1, i32 1
+  %8 = add nsw i32 %merged.select2, %merged.select3
+  %merged.select4 = select i1 %cmp, i32 %3, i32 %4
+  %merged.select5 = select i1 %cmp, i32 3, i32 4
+  %9 = mul nsw i32 %merged.select4, %merged.select5
+  %moved.sel = select i1 %cmp, i32 %6, i32 %0
+  %moved.sel7 = select i1 %cmp, i32 %7, i32 %1
+  %moved.sel8 = select i1 %cmp, i32 %8, i32 %2
+  %moved.sel9 = select i1 %cmp, i32 %9, i32 %3
+  %moved.sel10 = select i1 %cmp, i32 %4, i32 %9
+  %moved.sel11 = select i1 %cmp, i32 %5, i32 %8
+  br label %if.end
+}
+
+declare dso_local i32 @printf(i8*, ...) #1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local i32 @main() #0 {
+entry:
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  %call = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %a)
+  %call1 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %b)
+  %call2 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %c)
+  %call3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %d)
+  %call4 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %e)
+  %call5 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %f)
+  call void @foo(i32* %a, i32* %b, i32* %c, i32* %d, i32* %e, i32* %f)
+  %cfmse.dci_gep = getelementptr [8 x i8], [8 x i8]* @cfmse.dci_gv, i64 0, i64 0
+  ret i32 0
+}
+
+declare dso_local i32 @__isoc99_scanf(i8*, ...) #1
+
+attributes #0 = { noinline nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+
+!llvm.module.flags = !{!0, !1, !2}
+!llvm.ident = !{!3}
+
+!0 = !{i32 1, !"wchar_size", i32 4}
+!1 = !{i32 7, !"uwtable", i32 1}
+!2 = !{i32 7, !"frame-pointer", i32 2}
+!3 = !{!"clang version 14.0.0 (git@github.com:charitha22/llvm-project-rocm.git 9b11feafa64c148db02b5b50badeead69ea85de8)"}
diff --git a/cfm_tests/cfg/dci1/dci1.optimized.ll b/cfm_tests/cfg/dci1/dci1.optimized.ll
new file mode 100644
index 000000000000..781cc6a93777
--- /dev/null
+++ b/cfm_tests/cfg/dci1/dci1.optimized.ll
@@ -0,0 +1,76 @@
+; ModuleID = '<stdin>'
+source_filename = "dci1.c"
+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-gnu"
+
+@.str = private unnamed_addr constant [31 x i8] c"a=%d\0Ab=%d\0Ac=%d\0Ad=%d\0Ae=%d\0Af=%d\0A\00", align 1
+@.str.1 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local void @foo(i32* %a1, i32* %a2, i32* %a3, i32* %a4, i32* %a5, i32* %a6) #0 {
+entry:
+  %0 = load i32, i32* %a1, align 4
+  %1 = load i32, i32* %a2, align 4
+  %2 = load i32, i32* %a3, align 4
+  %3 = load i32, i32* %a4, align 4
+  %4 = load i32, i32* %a5, align 4
+  %5 = load i32, i32* %a6, align 4
+  %cmp = icmp sgt i32 %0, 0
+  br i1 %cmp, label %if.then, label %if.else
+
+if.then:                                          ; preds = %entry
+  %inc = add nsw i32 %0, 1
+  %dec = add nsw i32 %1, -1
+  %dec1 = add nsw i32 %2, -1
+  %mul = mul nsw i32 %3, 3
+  br label %if.end
+
+if.else:                                          ; preds = %entry
+  %inc2 = add nsw i32 %5, 1
+  %mul3 = mul nsw i32 %4, 4
+  br label %if.end
+
+if.end:                                           ; preds = %if.else, %if.then
+  %a.0 = phi i32 [ %inc, %if.then ], [ %0, %if.else ]
+  %b.0 = phi i32 [ %dec, %if.then ], [ %1, %if.else ]
+  %c.0 = phi i32 [ %dec1, %if.then ], [ %2, %if.else ]
+  %d.0 = phi i32 [ %mul, %if.then ], [ %3, %if.else ]
+  %e.0 = phi i32 [ %4, %if.then ], [ %mul3, %if.else ]
+  %f.0 = phi i32 [ %5, %if.then ], [ %inc2, %if.else ]
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str, i64 0, i64 0), i32 %a.0, i32 %b.0, i32 %c.0, i32 %d.0, i32 %e.0, i32 %f.0)
+  ret void
+}
+
+declare dso_local i32 @printf(i8*, ...) #1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local i32 @main() #0 {
+entry:
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  %call = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %a)
+  %call1 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %b)
+  %call2 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %c)
+  %call3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %d)
+  %call4 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %e)
+  %call5 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %f)
+  call void @foo(i32* %a, i32* %b, i32* %c, i32* %d, i32* %e, i32* %f)
+  ret i32 0
+}
+
+declare dso_local i32 @__isoc99_scanf(i8*, ...) #1
+
+attributes #0 = { noinline nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+
+!llvm.module.flags = !{!0, !1, !2}
+!llvm.ident = !{!3}
+
+!0 = !{i32 1, !"wchar_size", i32 4}
+!1 = !{i32 7, !"uwtable", i32 1}
+!2 = !{i32 7, !"frame-pointer", i32 2}
+!3 = !{!"clang version 14.0.0 (git@github.com:charitha22/llvm-project-rocm.git 9b11feafa64c148db02b5b50badeead69ea85de8)"}
diff --git a/cfm_tests/cfg/dci1/output.merged.txt b/cfm_tests/cfg/dci1/output.merged.txt
new file mode 100644
index 000000000000..9d2dcb3d3138
--- /dev/null
+++ b/cfm_tests/cfg/dci1/output.merged.txt
@@ -0,0 +1,6 @@
+a=2
+b=1
+c=2
+d=12
+e=5
+f=6
diff --git a/cfm_tests/cfg/dci1/output.txt b/cfm_tests/cfg/dci1/output.txt
new file mode 100644
index 000000000000..9d2dcb3d3138
--- /dev/null
+++ b/cfm_tests/cfg/dci1/output.txt
@@ -0,0 +1,6 @@
+a=2
+b=1
+c=2
+d=12
+e=5
+f=6
diff --git a/cfm_tests/cfg/dci2/dci2.ll b/cfm_tests/cfg/dci2/dci2.ll
new file mode 100644
index 000000000000..d527bdace99e
--- /dev/null
+++ b/cfm_tests/cfg/dci2/dci2.ll
@@ -0,0 +1,286 @@
+; ModuleID = 'dci2.c'
+source_filename = "dci2.c"
+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-gnu"
+
+@glob = dso_local global [3 x i8] c"000", align 1, !dbg !0
+@.str = private unnamed_addr constant [31 x i8] c"a=%d\0Ab=%d\0Ac=%d\0Ad=%d\0Ae=%d\0Af=%d\0A\00", align 1
+@.str.1 = private unnamed_addr constant [4 x i8] c"%c\0A\00", align 1
+@.str.2 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local void @foo(i32* %a1, i32* %a2, i32* %a3, i32* %a4, i32* %a5, i32* %a6, i32* %arr) #0 !dbg !16 {
+entry:
+  %a1.addr = alloca i32*, align 8
+  %a2.addr = alloca i32*, align 8
+  %a3.addr = alloca i32*, align 8
+  %a4.addr = alloca i32*, align 8
+  %a5.addr = alloca i32*, align 8
+  %a6.addr = alloca i32*, align 8
+  %arr.addr = alloca i32*, align 8
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  store i32* %a1, i32** %a1.addr, align 8
+  call void @llvm.dbg.declare(metadata i32** %a1.addr, metadata !21, metadata !DIExpression()), !dbg !22
+  store i32* %a2, i32** %a2.addr, align 8
+  call void @llvm.dbg.declare(metadata i32** %a2.addr, metadata !23, metadata !DIExpression()), !dbg !24
+  store i32* %a3, i32** %a3.addr, align 8
+  call void @llvm.dbg.declare(metadata i32** %a3.addr, metadata !25, metadata !DIExpression()), !dbg !26
+  store i32* %a4, i32** %a4.addr, align 8
+  call void @llvm.dbg.declare(metadata i32** %a4.addr, metadata !27, metadata !DIExpression()), !dbg !28
+  store i32* %a5, i32** %a5.addr, align 8
+  call void @llvm.dbg.declare(metadata i32** %a5.addr, metadata !29, metadata !DIExpression()), !dbg !30
+  store i32* %a6, i32** %a6.addr, align 8
+  call void @llvm.dbg.declare(metadata i32** %a6.addr, metadata !31, metadata !DIExpression()), !dbg !32
+  store i32* %arr, i32** %arr.addr, align 8
+  call void @llvm.dbg.declare(metadata i32** %arr.addr, metadata !33, metadata !DIExpression()), !dbg !34
+  call void @llvm.dbg.declare(metadata i32* %a, metadata !35, metadata !DIExpression()), !dbg !36
+  %0 = load i32*, i32** %a1.addr, align 8, !dbg !37
+  %1 = load i32, i32* %0, align 4, !dbg !38
+  store i32 %1, i32* %a, align 4, !dbg !36
+  call void @llvm.dbg.declare(metadata i32* %b, metadata !39, metadata !DIExpression()), !dbg !40
+  %2 = load i32*, i32** %a2.addr, align 8, !dbg !41
+  %3 = load i32, i32* %2, align 4, !dbg !42
+  store i32 %3, i32* %b, align 4, !dbg !40
+  call void @llvm.dbg.declare(metadata i32* %c, metadata !43, metadata !DIExpression()), !dbg !44
+  %4 = load i32*, i32** %a3.addr, align 8, !dbg !45
+  %5 = load i32, i32* %4, align 4, !dbg !46
+  store i32 %5, i32* %c, align 4, !dbg !44
+  call void @llvm.dbg.declare(metadata i32* %d, metadata !47, metadata !DIExpression()), !dbg !48
+  %6 = load i32*, i32** %a4.addr, align 8, !dbg !49
+  %7 = load i32, i32* %6, align 4, !dbg !50
+  store i32 %7, i32* %d, align 4, !dbg !48
+  call void @llvm.dbg.declare(metadata i32* %e, metadata !51, metadata !DIExpression()), !dbg !52
+  %8 = load i32*, i32** %a5.addr, align 8, !dbg !53
+  %9 = load i32, i32* %8, align 4, !dbg !54
+  store i32 %9, i32* %e, align 4, !dbg !52
+  call void @llvm.dbg.declare(metadata i32* %f, metadata !55, metadata !DIExpression()), !dbg !56
+  %10 = load i32*, i32** %a6.addr, align 8, !dbg !57
+  %11 = load i32, i32* %10, align 4, !dbg !58
+  store i32 %11, i32* %f, align 4, !dbg !56
+  %12 = load i32, i32* %a, align 4, !dbg !59
+  %cmp = icmp sgt i32 %12, 0, !dbg !61
+  br i1 %cmp, label %if.then, label %if.else, !dbg !62
+
+if.then:                                          ; preds = %entry
+  %13 = load i32*, i32** %arr.addr, align 8, !dbg !63
+  %arrayidx = getelementptr inbounds i32, i32* %13, i64 0, !dbg !63
+  %14 = load i32, i32* %arrayidx, align 4, !dbg !63
+  %15 = load i32, i32* %a, align 4, !dbg !65
+  %add = add nsw i32 %15, %14, !dbg !65
+  store i32 %add, i32* %a, align 4, !dbg !65
+  %16 = load i32, i32* %b, align 4, !dbg !66
+  %dec = add nsw i32 %16, -1, !dbg !66
+  store i32 %dec, i32* %b, align 4, !dbg !66
+  %17 = load i32, i32* %c, align 4, !dbg !67
+  %dec1 = add nsw i32 %17, -1, !dbg !67
+  store i32 %dec1, i32* %c, align 4, !dbg !67
+  %18 = load i32, i32* %d, align 4, !dbg !68
+  %mul = mul nsw i32 %18, 3, !dbg !68
+  store i32 %mul, i32* %d, align 4, !dbg !68
+  br label %if.end, !dbg !69
+
+if.else:                                          ; preds = %entry
+  %19 = load i32, i32* %f, align 4, !dbg !70
+  %inc = add nsw i32 %19, 1, !dbg !70
+  store i32 %inc, i32* %f, align 4, !dbg !70
+  %20 = load i32, i32* %e, align 4, !dbg !72
+  %mul2 = mul nsw i32 %20, 4, !dbg !72
+  store i32 %mul2, i32* %e, align 4, !dbg !72
+  %21 = load i32, i32* %e, align 4, !dbg !73
+  %22 = load i32*, i32** %arr.addr, align 8, !dbg !74
+  %arrayidx3 = getelementptr inbounds i32, i32* %22, i64 1, !dbg !74
+  store i32 %21, i32* %arrayidx3, align 4, !dbg !75
+  br label %if.end
+
+if.end:                                           ; preds = %if.else, %if.then
+  %23 = load i32, i32* %a, align 4, !dbg !76
+  %24 = load i32, i32* %b, align 4, !dbg !77
+  %25 = load i32, i32* %c, align 4, !dbg !78
+  %26 = load i32, i32* %d, align 4, !dbg !79
+  %27 = load i32, i32* %e, align 4, !dbg !80
+  %28 = load i32, i32* %f, align 4, !dbg !81
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str, i64 0, i64 0), i32 %23, i32 %24, i32 %25, i32 %26, i32 %27, i32 %28), !dbg !82
+  ret void, !dbg !83
+}
+
+; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+declare dso_local i32 @printf(i8*, ...) #2
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local i32 @main() #0 !dbg !84 {
+entry:
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  %arr = alloca [2 x i32], align 4
+  %g = alloca i8, align 1
+  call void @llvm.dbg.declare(metadata i32* %a, metadata !87, metadata !DIExpression()), !dbg !88
+  call void @llvm.dbg.declare(metadata i32* %b, metadata !89, metadata !DIExpression()), !dbg !90
+  call void @llvm.dbg.declare(metadata i32* %c, metadata !91, metadata !DIExpression()), !dbg !92
+  call void @llvm.dbg.declare(metadata i32* %d, metadata !93, metadata !DIExpression()), !dbg !94
+  call void @llvm.dbg.declare(metadata i32* %e, metadata !95, metadata !DIExpression()), !dbg !96
+  call void @llvm.dbg.declare(metadata i32* %f, metadata !97, metadata !DIExpression()), !dbg !98
+  call void @llvm.dbg.declare(metadata [2 x i32]* %arr, metadata !99, metadata !DIExpression()), !dbg !103
+  call void @llvm.dbg.declare(metadata i8* %g, metadata !104, metadata !DIExpression()), !dbg !105
+  %0 = load i8, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @glob, i64 0, i64 0), align 1, !dbg !106
+  store i8 %0, i8* %g, align 1, !dbg !105
+  %1 = load i8, i8* %g, align 1, !dbg !107
+  %conv = sext i8 %1 to i32, !dbg !107
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i64 0, i64 0), i32 %conv), !dbg !108
+  %call1 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %a), !dbg !109
+  %call2 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %b), !dbg !110
+  %call3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %c), !dbg !111
+  %call4 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %d), !dbg !112
+  %call5 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %e), !dbg !113
+  %call6 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %f), !dbg !114
+  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 0, !dbg !115
+  %call7 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %arrayidx), !dbg !116
+  %arrayidx8 = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 1, !dbg !117
+  %call9 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %arrayidx8), !dbg !118
+  %arraydecay = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 0, !dbg !119
+  call void @foo(i32* %a, i32* %b, i32* %c, i32* %d, i32* %e, i32* %f, i32* %arraydecay), !dbg !120
+  ret i32 0, !dbg !121
+}
+
+declare dso_local i32 @__isoc99_scanf(i8*, ...) #2
+
+attributes #0 = { noinline nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+attributes #1 = { nofree nosync nounwind readnone speculatable willreturn }
+attributes #2 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+
+!llvm.dbg.cu = !{!2}
+!llvm.module.flags = !{!10, !11, !12, !13, !14}
+!llvm.ident = !{!15}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = distinct !DIGlobalVariable(name: "glob", scope: !2, file: !3, line: 2, type: !6, isLocal: false, isDefinition: true)
+!2 = distinct !DICompileUnit(language: DW_LANG_C99, file: !3, producer: "clang version 14.0.0 (git@github.com:charitha22/llvm-project-rocm.git ae6efdec32edb05bec9f2dc7688768c482043ace)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !4, globals: !5, splitDebugInlining: false, nameTableKind: None)
+!3 = !DIFile(filename: "dci2.c", directory: "/home/min/a/cgusthin/git/llvm-project-rocm/cfm_tests/cfg/dci2")
+!4 = !{}
+!5 = !{!0}
+!6 = !DICompositeType(tag: DW_TAG_array_type, baseType: !7, size: 24, elements: !8)
+!7 = !DIBasicType(name: "char", size: 8, encoding: DW_ATE_signed_char)
+!8 = !{!9}
+!9 = !DISubrange(count: 3)
+!10 = !{i32 7, !"Dwarf Version", i32 4}
+!11 = !{i32 2, !"Debug Info Version", i32 3}
+!12 = !{i32 1, !"wchar_size", i32 4}
+!13 = !{i32 7, !"uwtable", i32 1}
+!14 = !{i32 7, !"frame-pointer", i32 2}
+!15 = !{!"clang version 14.0.0 (git@github.com:charitha22/llvm-project-rocm.git ae6efdec32edb05bec9f2dc7688768c482043ace)"}
+!16 = distinct !DISubprogram(name: "foo", scope: !3, file: !3, line: 3, type: !17, scopeLine: 3, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !2, retainedNodes: !4)
+!17 = !DISubroutineType(types: !18)
+!18 = !{null, !19, !19, !19, !19, !19, !19, !19}
+!19 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !20, size: 64)
+!20 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
+!21 = !DILocalVariable(name: "a1", arg: 1, scope: !16, file: !3, line: 3, type: !19)
+!22 = !DILocation(line: 3, column: 15, scope: !16)
+!23 = !DILocalVariable(name: "a2", arg: 2, scope: !16, file: !3, line: 3, type: !19)
+!24 = !DILocation(line: 3, column: 24, scope: !16)
+!25 = !DILocalVariable(name: "a3", arg: 3, scope: !16, file: !3, line: 3, type: !19)
+!26 = !DILocation(line: 3, column: 33, scope: !16)
+!27 = !DILocalVariable(name: "a4", arg: 4, scope: !16, file: !3, line: 3, type: !19)
+!28 = !DILocation(line: 3, column: 42, scope: !16)
+!29 = !DILocalVariable(name: "a5", arg: 5, scope: !16, file: !3, line: 3, type: !19)
+!30 = !DILocation(line: 3, column: 51, scope: !16)
+!31 = !DILocalVariable(name: "a6", arg: 6, scope: !16, file: !3, line: 3, type: !19)
+!32 = !DILocation(line: 3, column: 60, scope: !16)
+!33 = !DILocalVariable(name: "arr", arg: 7, scope: !16, file: !3, line: 3, type: !19)
+!34 = !DILocation(line: 3, column: 69, scope: !16)
+!35 = !DILocalVariable(name: "a", scope: !16, file: !3, line: 4, type: !20)
+!36 = !DILocation(line: 4, column: 7, scope: !16)
+!37 = !DILocation(line: 4, column: 12, scope: !16)
+!38 = !DILocation(line: 4, column: 11, scope: !16)
+!39 = !DILocalVariable(name: "b", scope: !16, file: !3, line: 5, type: !20)
+!40 = !DILocation(line: 5, column: 7, scope: !16)
+!41 = !DILocation(line: 5, column: 12, scope: !16)
+!42 = !DILocation(line: 5, column: 11, scope: !16)
+!43 = !DILocalVariable(name: "c", scope: !16, file: !3, line: 6, type: !20)
+!44 = !DILocation(line: 6, column: 7, scope: !16)
+!45 = !DILocation(line: 6, column: 12, scope: !16)
+!46 = !DILocation(line: 6, column: 11, scope: !16)
+!47 = !DILocalVariable(name: "d", scope: !16, file: !3, line: 7, type: !20)
+!48 = !DILocation(line: 7, column: 7, scope: !16)
+!49 = !DILocation(line: 7, column: 12, scope: !16)
+!50 = !DILocation(line: 7, column: 11, scope: !16)
+!51 = !DILocalVariable(name: "e", scope: !16, file: !3, line: 8, type: !20)
+!52 = !DILocation(line: 8, column: 7, scope: !16)
+!53 = !DILocation(line: 8, column: 12, scope: !16)
+!54 = !DILocation(line: 8, column: 11, scope: !16)
+!55 = !DILocalVariable(name: "f", scope: !16, file: !3, line: 9, type: !20)
+!56 = !DILocation(line: 9, column: 7, scope: !16)
+!57 = !DILocation(line: 9, column: 12, scope: !16)
+!58 = !DILocation(line: 9, column: 11, scope: !16)
+!59 = !DILocation(line: 11, column: 7, scope: !60)
+!60 = distinct !DILexicalBlock(scope: !16, file: !3, line: 11, column: 7)
+!61 = !DILocation(line: 11, column: 9, scope: !60)
+!62 = !DILocation(line: 11, column: 7, scope: !16)
+!63 = !DILocation(line: 12, column: 10, scope: !64)
+!64 = distinct !DILexicalBlock(scope: !60, file: !3, line: 11, column: 14)
+!65 = !DILocation(line: 12, column: 7, scope: !64)
+!66 = !DILocation(line: 13, column: 6, scope: !64)
+!67 = !DILocation(line: 14, column: 6, scope: !64)
+!68 = !DILocation(line: 15, column: 6, scope: !64)
+!69 = !DILocation(line: 16, column: 3, scope: !64)
+!70 = !DILocation(line: 17, column: 6, scope: !71)
+!71 = distinct !DILexicalBlock(scope: !60, file: !3, line: 16, column: 10)
+!72 = !DILocation(line: 18, column: 6, scope: !71)
+!73 = !DILocation(line: 19, column: 14, scope: !71)
+!74 = !DILocation(line: 19, column: 5, scope: !71)
+!75 = !DILocation(line: 19, column: 12, scope: !71)
+!76 = !DILocation(line: 28, column: 10, scope: !16)
+!77 = !DILocation(line: 28, column: 13, scope: !16)
+!78 = !DILocation(line: 28, column: 16, scope: !16)
+!79 = !DILocation(line: 28, column: 19, scope: !16)
+!80 = !DILocation(line: 28, column: 22, scope: !16)
+!81 = !DILocation(line: 28, column: 25, scope: !16)
+!82 = !DILocation(line: 22, column: 3, scope: !16)
+!83 = !DILocation(line: 29, column: 1, scope: !16)
+!84 = distinct !DISubprogram(name: "main", scope: !3, file: !3, line: 31, type: !85, scopeLine: 31, spFlags: DISPFlagDefinition, unit: !2, retainedNodes: !4)
+!85 = !DISubroutineType(types: !86)
+!86 = !{!20}
+!87 = !DILocalVariable(name: "a", scope: !84, file: !3, line: 32, type: !20)
+!88 = !DILocation(line: 32, column: 7, scope: !84)
+!89 = !DILocalVariable(name: "b", scope: !84, file: !3, line: 32, type: !20)
+!90 = !DILocation(line: 32, column: 10, scope: !84)
+!91 = !DILocalVariable(name: "c", scope: !84, file: !3, line: 32, type: !20)
+!92 = !DILocation(line: 32, column: 13, scope: !84)
+!93 = !DILocalVariable(name: "d", scope: !84, file: !3, line: 32, type: !20)
+!94 = !DILocation(line: 32, column: 16, scope: !84)
+!95 = !DILocalVariable(name: "e", scope: !84, file: !3, line: 32, type: !20)
+!96 = !DILocation(line: 32, column: 19, scope: !84)
+!97 = !DILocalVariable(name: "f", scope: !84, file: !3, line: 32, type: !20)
+!98 = !DILocation(line: 32, column: 22, scope: !84)
+!99 = !DILocalVariable(name: "arr", scope: !84, file: !3, line: 33, type: !100)
+!100 = !DICompositeType(tag: DW_TAG_array_type, baseType: !20, size: 64, elements: !101)
+!101 = !{!102}
+!102 = !DISubrange(count: 2)
+!103 = !DILocation(line: 33, column: 7, scope: !84)
+!104 = !DILocalVariable(name: "g", scope: !84, file: !3, line: 34, type: !7)
+!105 = !DILocation(line: 34, column: 8, scope: !84)
+!106 = !DILocation(line: 34, column: 12, scope: !84)
+!107 = !DILocation(line: 35, column: 18, scope: !84)
+!108 = !DILocation(line: 35, column: 3, scope: !84)
+!109 = !DILocation(line: 36, column: 3, scope: !84)
+!110 = !DILocation(line: 37, column: 3, scope: !84)
+!111 = !DILocation(line: 38, column: 3, scope: !84)
+!112 = !DILocation(line: 39, column: 3, scope: !84)
+!113 = !DILocation(line: 40, column: 3, scope: !84)
+!114 = !DILocation(line: 41, column: 3, scope: !84)
+!115 = !DILocation(line: 42, column: 16, scope: !84)
+!116 = !DILocation(line: 42, column: 3, scope: !84)
+!117 = !DILocation(line: 43, column: 16, scope: !84)
+!118 = !DILocation(line: 43, column: 3, scope: !84)
+!119 = !DILocation(line: 45, column: 31, scope: !84)
+!120 = !DILocation(line: 45, column: 3, scope: !84)
+!121 = !DILocation(line: 46, column: 1, scope: !84)
diff --git a/cfm_tests/cfg/dci2/dci2.merged.ll b/cfm_tests/cfg/dci2/dci2.merged.ll
new file mode 100644
index 000000000000..96ea11ff931e
--- /dev/null
+++ b/cfm_tests/cfg/dci2/dci2.merged.ll
@@ -0,0 +1,97 @@
+; ModuleID = '<stdin>'
+source_filename = "dci2.c"
+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-gnu"
+
+@glob = dso_local global [3 x i8] c"000", align 1
+@.str = private unnamed_addr constant [31 x i8] c"a=%d\0Ab=%d\0Ac=%d\0Ad=%d\0Ae=%d\0Af=%d\0A\00", align 1
+@.str.1 = private unnamed_addr constant [4 x i8] c"%c\0A\00", align 1
+@.str.2 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
+@cfmse.dci_gv = private global [8 x i8] zeroinitializer
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local void @foo(i32* %a1, i32* %a2, i32* %a3, i32* %a4, i32* %a5, i32* %a6, i32* %arr) #0 {
+entry:
+  %0 = load i32, i32* %a1, align 4
+  %1 = load i32, i32* %a2, align 4
+  %2 = load i32, i32* %a3, align 4
+  %3 = load i32, i32* %a4, align 4
+  %4 = load i32, i32* %a5, align 4
+  %5 = load i32, i32* %a6, align 4
+  %cmp = icmp sgt i32 %0, 0
+  %cfmse.dci_gep = getelementptr [8 x i8], [8 x i8]* @cfmse.dci_gv, i64 0, i64 0
+  br label %merged.bb
+
+if.end:                                           ; preds = %merged.bb
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str, i64 0, i64 0), i32 %moved.sel, i32 %moved.sel8, i32 %moved.sel9, i32 %moved.sel10, i32 %moved.sel11, i32 %moved.sel12)
+  ret void
+
+merged.bb:                                        ; preds = %entry
+  %6 = getelementptr inbounds i32, i32* %arr, i64 0
+  %7 = load i32, i32* %6, align 4
+  %merged.select = select i1 %cmp, i32 %7, i32 0
+  %8 = add nsw i32 %0, %merged.select
+  %merged.select1 = select i1 %cmp, i32 -1, i32 0
+  %9 = add nsw i32 %1, %merged.select1
+  %merged.select2 = select i1 %cmp, i32 %2, i32 %5
+  %merged.select3 = select i1 %cmp, i32 -1, i32 1
+  %10 = add nsw i32 %merged.select2, %merged.select3
+  %merged.select4 = select i1 %cmp, i32 %3, i32 %4
+  %merged.select5 = select i1 %cmp, i32 3, i32 4
+  %11 = mul nsw i32 %merged.select4, %merged.select5
+  %12 = getelementptr inbounds i32, i32* %arr, i64 1
+  %13 = load i32, i32* %12, align 4
+  %merged.select6 = select i1 %cmp, i32 %13, i32 %11
+  store i32 %merged.select6, i32* %12, align 4
+  %moved.sel = select i1 %cmp, i32 %8, i32 %0
+  %moved.sel8 = select i1 %cmp, i32 %9, i32 %1
+  %moved.sel9 = select i1 %cmp, i32 %10, i32 %2
+  %moved.sel10 = select i1 %cmp, i32 %11, i32 %3
+  %moved.sel11 = select i1 %cmp, i32 %4, i32 %11
+  %moved.sel12 = select i1 %cmp, i32 %5, i32 %10
+  br label %if.end
+}
+
+declare dso_local i32 @printf(i8*, ...) #1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local i32 @main() #0 {
+entry:
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  %arr = alloca [2 x i32], align 4
+  %0 = load i8, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @glob, i64 0, i64 0), align 1
+  %conv = sext i8 %0 to i32
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i64 0, i64 0), i32 %conv)
+  %call1 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %a)
+  %call2 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %b)
+  %call3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %c)
+  %call4 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %d)
+  %call5 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %e)
+  %call6 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %f)
+  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 0
+  %call7 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %arrayidx)
+  %arrayidx8 = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 1
+  %call9 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %arrayidx8)
+  %arraydecay = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 0
+  call void @foo(i32* %a, i32* %b, i32* %c, i32* %d, i32* %e, i32* %f, i32* %arraydecay)
+  %cfmse.dci_gep = getelementptr [8 x i8], [8 x i8]* @cfmse.dci_gv, i64 0, i64 0
+  ret i32 0
+}
+
+declare dso_local i32 @__isoc99_scanf(i8*, ...) #1
+
+attributes #0 = { noinline nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+
+!llvm.module.flags = !{!0, !1, !2}
+!llvm.ident = !{!3}
+
+!0 = !{i32 1, !"wchar_size", i32 4}
+!1 = !{i32 7, !"uwtable", i32 1}
+!2 = !{i32 7, !"frame-pointer", i32 2}
+!3 = !{!"clang version 14.0.0 (git@github.com:charitha22/llvm-project-rocm.git ae6efdec32edb05bec9f2dc7688768c482043ace)"}
diff --git a/cfm_tests/cfg/dci2/dci2.optimized.ll b/cfm_tests/cfg/dci2/dci2.optimized.ll
new file mode 100644
index 000000000000..59529dccab0a
--- /dev/null
+++ b/cfm_tests/cfg/dci2/dci2.optimized.ll
@@ -0,0 +1,91 @@
+; ModuleID = '<stdin>'
+source_filename = "dci2.c"
+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-gnu"
+
+@glob = dso_local global [3 x i8] c"000", align 1
+@.str = private unnamed_addr constant [31 x i8] c"a=%d\0Ab=%d\0Ac=%d\0Ad=%d\0Ae=%d\0Af=%d\0A\00", align 1
+@.str.1 = private unnamed_addr constant [4 x i8] c"%c\0A\00", align 1
+@.str.2 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local void @foo(i32* %a1, i32* %a2, i32* %a3, i32* %a4, i32* %a5, i32* %a6, i32* %arr) #0 {
+entry:
+  %0 = load i32, i32* %a1, align 4
+  %1 = load i32, i32* %a2, align 4
+  %2 = load i32, i32* %a3, align 4
+  %3 = load i32, i32* %a4, align 4
+  %4 = load i32, i32* %a5, align 4
+  %5 = load i32, i32* %a6, align 4
+  %cmp = icmp sgt i32 %0, 0
+  br i1 %cmp, label %if.then, label %if.else
+
+if.then:                                          ; preds = %entry
+  %arrayidx = getelementptr inbounds i32, i32* %arr, i64 0
+  %6 = load i32, i32* %arrayidx, align 4
+  %add = add nsw i32 %0, %6
+  %dec = add nsw i32 %1, -1
+  %dec1 = add nsw i32 %2, -1
+  %mul = mul nsw i32 %3, 3
+  br label %if.end
+
+if.else:                                          ; preds = %entry
+  %inc = add nsw i32 %5, 1
+  %mul2 = mul nsw i32 %4, 4
+  %arrayidx3 = getelementptr inbounds i32, i32* %arr, i64 1
+  store i32 %mul2, i32* %arrayidx3, align 4
+  br label %if.end
+
+if.end:                                           ; preds = %if.else, %if.then
+  %a.0 = phi i32 [ %add, %if.then ], [ %0, %if.else ]
+  %b.0 = phi i32 [ %dec, %if.then ], [ %1, %if.else ]
+  %c.0 = phi i32 [ %dec1, %if.then ], [ %2, %if.else ]
+  %d.0 = phi i32 [ %mul, %if.then ], [ %3, %if.else ]
+  %e.0 = phi i32 [ %4, %if.then ], [ %mul2, %if.else ]
+  %f.0 = phi i32 [ %5, %if.then ], [ %inc, %if.else ]
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str, i64 0, i64 0), i32 %a.0, i32 %b.0, i32 %c.0, i32 %d.0, i32 %e.0, i32 %f.0)
+  ret void
+}
+
+declare dso_local i32 @printf(i8*, ...) #1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local i32 @main() #0 {
+entry:
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  %arr = alloca [2 x i32], align 4
+  %0 = load i8, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @glob, i64 0, i64 0), align 1
+  %conv = sext i8 %0 to i32
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i64 0, i64 0), i32 %conv)
+  %call1 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %a)
+  %call2 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %b)
+  %call3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %c)
+  %call4 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %d)
+  %call5 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %e)
+  %call6 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %f)
+  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 0
+  %call7 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %arrayidx)
+  %arrayidx8 = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 1
+  %call9 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %arrayidx8)
+  %arraydecay = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 0
+  call void @foo(i32* %a, i32* %b, i32* %c, i32* %d, i32* %e, i32* %f, i32* %arraydecay)
+  ret i32 0
+}
+
+declare dso_local i32 @__isoc99_scanf(i8*, ...) #1
+
+attributes #0 = { noinline nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+
+!llvm.module.flags = !{!0, !1, !2}
+!llvm.ident = !{!3}
+
+!0 = !{i32 1, !"wchar_size", i32 4}
+!1 = !{i32 7, !"uwtable", i32 1}
+!2 = !{i32 7, !"frame-pointer", i32 2}
+!3 = !{!"clang version 14.0.0 (git@github.com:charitha22/llvm-project-rocm.git ae6efdec32edb05bec9f2dc7688768c482043ace)"}
diff --git a/cfm_tests/cfg/dci2/out.ll b/cfm_tests/cfg/dci2/out.ll
new file mode 100644
index 000000000000..86d144a69e2c
--- /dev/null
+++ b/cfm_tests/cfg/dci2/out.ll
@@ -0,0 +1,221 @@
+; ModuleID = '<stdin>'
+source_filename = "dci2.c"
+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-gnu"
+
+@glob = dso_local global [3 x i8] c"000", align 1
+@.str = private unnamed_addr constant [31 x i8] c"a=%d\0Ab=%d\0Ac=%d\0Ad=%d\0Ae=%d\0Af=%d\0A\00", align 1
+@.str.1 = private unnamed_addr constant [4 x i8] c"%c\0A\00", align 1
+@.str.2 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
+@cfmse.dci_gv = private global [8 x i8] zeroinitializer
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local void @foo(i32* %a1, i32* %a2, i32* %a3, i32* %a4, i32* %a5, i32* %a6, i32* %arr) #0 !dbg !8 {
+entry:
+  %a1.addr = alloca i32*, align 8
+  %a2.addr = alloca i32*, align 8
+  %a3.addr = alloca i32*, align 8
+  %a4.addr = alloca i32*, align 8
+  %a5.addr = alloca i32*, align 8
+  %a6.addr = alloca i32*, align 8
+  %arr.addr = alloca i32*, align 8
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  store i32* %a1, i32** %a1.addr, align 8
+  store i32* %a2, i32** %a2.addr, align 8
+  store i32* %a3, i32** %a3.addr, align 8
+  store i32* %a4, i32** %a4.addr, align 8
+  store i32* %a5, i32** %a5.addr, align 8
+  store i32* %a6, i32** %a6.addr, align 8
+  store i32* %arr, i32** %arr.addr, align 8
+  %0 = load i32*, i32** %a1.addr, align 8, !dbg !11
+  %1 = load i32, i32* %0, align 4, !dbg !12
+  store i32 %1, i32* %a, align 4, !dbg !13
+  %2 = load i32*, i32** %a2.addr, align 8, !dbg !14
+  %3 = load i32, i32* %2, align 4, !dbg !15
+  store i32 %3, i32* %b, align 4, !dbg !16
+  %4 = load i32*, i32** %a3.addr, align 8, !dbg !17
+  %5 = load i32, i32* %4, align 4, !dbg !18
+  store i32 %5, i32* %c, align 4, !dbg !19
+  %6 = load i32*, i32** %a4.addr, align 8, !dbg !20
+  %7 = load i32, i32* %6, align 4, !dbg !21
+  store i32 %7, i32* %d, align 4, !dbg !22
+  %8 = load i32*, i32** %a5.addr, align 8, !dbg !23
+  %9 = load i32, i32* %8, align 4, !dbg !24
+  store i32 %9, i32* %e, align 4, !dbg !25
+  %10 = load i32*, i32** %a6.addr, align 8, !dbg !26
+  %11 = load i32, i32* %10, align 4, !dbg !27
+  store i32 %11, i32* %f, align 4, !dbg !28
+  %12 = load i32, i32* %a, align 4, !dbg !29
+  %cmp = icmp sgt i32 %12, 0, !dbg !30
+  %cfmse.dci_gep = getelementptr [8 x i8], [8 x i8]* @cfmse.dci_gv, i64 0, i64 0
+  br label %merged.bb, !dbg !29
+
+if.end:                                           ; preds = %merged.bb
+  %13 = load i32, i32* %a, align 4, !dbg !31
+  %14 = load i32, i32* %b, align 4, !dbg !32
+  %15 = load i32, i32* %c, align 4, !dbg !33
+  %16 = load i32, i32* %d, align 4, !dbg !34
+  %17 = load i32, i32* %e, align 4, !dbg !35
+  %18 = load i32, i32* %f, align 4, !dbg !36
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str, i64 0, i64 0), i32 %13, i32 %14, i32 %15, i32 %16, i32 %17, i32 %18), !dbg !37
+  ret void, !dbg !38
+
+merged.bb:                                        ; preds = %entry
+  %19 = load i32*, i32** %arr.addr, align 8, !dbg !39
+  %20 = getelementptr inbounds i32, i32* %19, i64 0, !dbg !39
+  %21 = load i32, i32* %20, align 4, !dbg !39
+  %22 = load i32, i32* %a, align 4, !dbg !40
+  %23 = load i32, i32* %f, align 4, !dbg !40
+  %merged.select = select i1 %cmp, i32 %22, i32 %23, !dbg !40
+  %merged.select13 = select i1 %cmp, i32 %21, i32 1, !dbg !40
+  %24 = add nsw i32 %merged.select, %merged.select13, !dbg !40
+  %25 = load i32, i32* %a, align 4, !dbg !40
+  %merged.select14 = select i1 %cmp, i32 %24, i32 %25, !dbg !40
+  store i32 %merged.select14, i32* %a, align 4, !dbg !40
+  %26 = load i32, i32* %f, align 4, !dbg !41
+  %merged.select15 = select i1 %cmp, i32 %26, i32 %24, !dbg !41
+  store i32 %merged.select15, i32* %f, align 4, !dbg !41
+  %27 = load i32, i32* %b, align 4, !dbg !41
+  %28 = load i32, i32* %e, align 4, !dbg !41
+  %merged.select16 = select i1 %cmp, i32 -1, i32 0, !dbg !41
+  %29 = add nsw i32 %27, %merged.select16, !dbg !41
+  %merged.select17 = select i1 %cmp, i32 1, i32 4, !dbg !41
+  %30 = mul nsw i32 %28, %merged.select17, !dbg !41
+  %31 = load i32, i32* %b, align 4, !dbg !41
+  %merged.select18 = select i1 %cmp, i32 %29, i32 %31, !dbg !41
+  store i32 %merged.select18, i32* %b, align 4, !dbg !41
+  %32 = load i32, i32* %e, align 4, !dbg !42
+  %merged.select19 = select i1 %cmp, i32 %32, i32 %30, !dbg !42
+  store i32 %merged.select19, i32* %e, align 4, !dbg !42
+  %33 = load i32, i32* %c, align 4, !dbg !42
+  %34 = load i32, i32* %e, align 4, !dbg !42
+  %merged.select20 = select i1 %cmp, i32 -1, i32 0, !dbg !42
+  %35 = add nsw i32 %33, %merged.select20, !dbg !42
+  %36 = load i32, i32* %c, align 4, !dbg !42
+  %merged.select21 = select i1 %cmp, i32 %35, i32 %36, !dbg !42
+  store i32 %merged.select21, i32* %c, align 4, !dbg !42
+  %37 = load i32, i32* %d, align 4, !dbg !43
+  %38 = load i32*, i32** %arr.addr, align 8, !dbg !43
+  %merged.select22 = select i1 %cmp, i32 3, i32 1, !dbg !43
+  %39 = mul nsw i32 %37, %merged.select22, !dbg !43
+  %40 = getelementptr inbounds i32, i32* %38, i64 1, !dbg !43
+  %41 = load i32, i32* %d, align 4, !dbg !43
+  %merged.select23 = select i1 %cmp, i32 %39, i32 %41, !dbg !43
+  store i32 %merged.select23, i32* %d, align 4, !dbg !43
+  %42 = load i32, i32* %40, align 4, !dbg !44
+  %merged.select24 = select i1 %cmp, i32 %42, i32 %34, !dbg !44
+  store i32 %merged.select24, i32* %40, align 4, !dbg !44
+  br label %if.end
+}
+
+declare dso_local i32 @printf(i8*, ...) #1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local i32 @main() #0 !dbg !45 {
+entry:
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  %arr = alloca [2 x i32], align 4
+  %g = alloca i8, align 1
+  %0 = load i8, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @glob, i64 0, i64 0), align 1, !dbg !46
+  store i8 %0, i8* %g, align 1, !dbg !47
+  %1 = load i8, i8* %g, align 1, !dbg !48
+  %conv = sext i8 %1 to i32, !dbg !48
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i64 0, i64 0), i32 %conv), !dbg !49
+  %call1 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %a), !dbg !50
+  %call2 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %b), !dbg !51
+  %call3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %c), !dbg !52
+  %call4 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %d), !dbg !53
+  %call5 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %e), !dbg !54
+  %call6 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %f), !dbg !55
+  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 0, !dbg !56
+  %call7 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %arrayidx), !dbg !57
+  %arrayidx8 = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 1, !dbg !58
+  %call9 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %arrayidx8), !dbg !59
+  %arraydecay = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 0, !dbg !60
+  call void @foo(i32* %a, i32* %b, i32* %c, i32* %d, i32* %e, i32* %f, i32* %arraydecay), !dbg !61
+  %cfmse.dci_gep = getelementptr [8 x i8], [8 x i8]* @cfmse.dci_gv, i64 0, i64 0
+  ret i32 0, !dbg !62
+}
+
+declare dso_local i32 @__isoc99_scanf(i8*, ...) #1
+
+attributes #0 = { noinline nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!2, !3, !4, !5, !6}
+!llvm.ident = !{!7}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 14.0.0 (git@github.com:charitha22/llvm-project-rocm.git ae6efdec32edb05bec9f2dc7688768c482043ace)", isOptimized: false, runtimeVersion: 0, emissionKind: LineTablesOnly, splitDebugInlining: false, nameTableKind: None)
+!1 = !DIFile(filename: "dci2.c", directory: "/home/min/a/cgusthin/git/llvm-project-rocm/cfm_tests/cfg/dci2")
+!2 = !{i32 7, !"Dwarf Version", i32 4}
+!3 = !{i32 2, !"Debug Info Version", i32 3}
+!4 = !{i32 1, !"wchar_size", i32 4}
+!5 = !{i32 7, !"uwtable", i32 1}
+!6 = !{i32 7, !"frame-pointer", i32 2}
+!7 = !{!"clang version 14.0.0 (git@github.com:charitha22/llvm-project-rocm.git ae6efdec32edb05bec9f2dc7688768c482043ace)"}
+!8 = distinct !DISubprogram(name: "foo", scope: !1, file: !1, line: 3, type: !9, scopeLine: 3, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0)
+!9 = !DISubroutineType(types: !10)
+!10 = !{}
+!11 = !DILocation(line: 4, column: 12, scope: !8)
+!12 = !DILocation(line: 4, column: 11, scope: !8)
+!13 = !DILocation(line: 4, column: 7, scope: !8)
+!14 = !DILocation(line: 5, column: 12, scope: !8)
+!15 = !DILocation(line: 5, column: 11, scope: !8)
+!16 = !DILocation(line: 5, column: 7, scope: !8)
+!17 = !DILocation(line: 6, column: 12, scope: !8)
+!18 = !DILocation(line: 6, column: 11, scope: !8)
+!19 = !DILocation(line: 6, column: 7, scope: !8)
+!20 = !DILocation(line: 7, column: 12, scope: !8)
+!21 = !DILocation(line: 7, column: 11, scope: !8)
+!22 = !DILocation(line: 7, column: 7, scope: !8)
+!23 = !DILocation(line: 8, column: 12, scope: !8)
+!24 = !DILocation(line: 8, column: 11, scope: !8)
+!25 = !DILocation(line: 8, column: 7, scope: !8)
+!26 = !DILocation(line: 9, column: 12, scope: !8)
+!27 = !DILocation(line: 9, column: 11, scope: !8)
+!28 = !DILocation(line: 9, column: 7, scope: !8)
+!29 = !DILocation(line: 11, column: 7, scope: !8)
+!30 = !DILocation(line: 11, column: 9, scope: !8)
+!31 = !DILocation(line: 28, column: 10, scope: !8)
+!32 = !DILocation(line: 28, column: 13, scope: !8)
+!33 = !DILocation(line: 28, column: 16, scope: !8)
+!34 = !DILocation(line: 28, column: 19, scope: !8)
+!35 = !DILocation(line: 28, column: 22, scope: !8)
+!36 = !DILocation(line: 28, column: 25, scope: !8)
+!37 = !DILocation(line: 22, column: 3, scope: !8)
+!38 = !DILocation(line: 29, column: 1, scope: !8)
+!39 = !DILocation(line: 12, column: 10, scope: !8)
+!40 = !DILocation(line: 12, column: 7, scope: !8)
+!41 = !DILocation(line: 13, column: 6, scope: !8)
+!42 = !DILocation(line: 14, column: 6, scope: !8)
+!43 = !DILocation(line: 15, column: 6, scope: !8)
+!44 = !DILocation(line: 16, column: 3, scope: !8)
+!45 = distinct !DISubprogram(name: "main", scope: !1, file: !1, line: 31, type: !9, scopeLine: 31, spFlags: DISPFlagDefinition, unit: !0)
+!46 = !DILocation(line: 34, column: 12, scope: !45)
+!47 = !DILocation(line: 34, column: 8, scope: !45)
+!48 = !DILocation(line: 35, column: 18, scope: !45)
+!49 = !DILocation(line: 35, column: 3, scope: !45)
+!50 = !DILocation(line: 36, column: 3, scope: !45)
+!51 = !DILocation(line: 37, column: 3, scope: !45)
+!52 = !DILocation(line: 38, column: 3, scope: !45)
+!53 = !DILocation(line: 39, column: 3, scope: !45)
+!54 = !DILocation(line: 40, column: 3, scope: !45)
+!55 = !DILocation(line: 41, column: 3, scope: !45)
+!56 = !DILocation(line: 42, column: 16, scope: !45)
+!57 = !DILocation(line: 42, column: 3, scope: !45)
+!58 = !DILocation(line: 43, column: 16, scope: !45)
+!59 = !DILocation(line: 43, column: 3, scope: !45)
+!60 = !DILocation(line: 45, column: 31, scope: !45)
+!61 = !DILocation(line: 45, column: 3, scope: !45)
+!62 = !DILocation(line: 46, column: 1, scope: !45)
diff --git a/cfm_tests/cfg/dci2/output.merged.txt b/cfm_tests/cfg/dci2/output.merged.txt
new file mode 100644
index 000000000000..0e7655670c1d
--- /dev/null
+++ b/cfm_tests/cfg/dci2/output.merged.txt
@@ -0,0 +1,7 @@
+0
+a=1
+b=1
+c=2
+d=12
+e=5
+f=6
diff --git a/cfm_tests/cfg/dci2/output.txt b/cfm_tests/cfg/dci2/output.txt
new file mode 100644
index 000000000000..0e7655670c1d
--- /dev/null
+++ b/cfm_tests/cfg/dci2/output.txt
@@ -0,0 +1,7 @@
+0
+a=1
+b=1
+c=2
+d=12
+e=5
+f=6
diff --git a/cfm_tests/cfg/elseif_chain/Makefile b/cfm_tests/cfg/elseif_chain/Makefile
new file mode 100644
index 000000000000..a82dda59ee7d
--- /dev/null
+++ b/cfm_tests/cfg/elseif_chain/Makefile
@@ -0,0 +1,62 @@
+include ../config.mk
+clang_flags=-emit-llvm -S -Xclang -disable-O0-optnone 
+opt_flags=-sroa -S
+
+obj := $(patsubst %.c,%.merged.ll,$(wildcard *.c))
+inputs := $(wildcard input*.txt)
+all : ${obj}
+	
+%.merged.ll : %.c	
+	${clang} ${clang_flags} $^
+	${opt} ${opt_flags} < $(patsubst %.c,%.ll,$^) > $(patsubst %.c,%.optimized.ll,$^)
+	${opt}  ${cfmerger_flags} < $(patsubst %.c,%.optimized.ll,$^) > $@
+
+
+
+test : is_same test1 test2 test3
+
+is_same : ${obj}
+	@cmp -s  $(patsubst %.merged.ll,%.optimized.ll,$^) $^ ; \
+	RETVAL=$$?; \
+	if [ $$RETVAL -eq 0 ]; then \
+					echo "ERROR : transformation did NOT change source IR"; \
+	else \
+					echo "SUCCESS : transformation did change source IR"; \
+	fi
+
+
+test1  : input1.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test2 : input2.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test3 : input3.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+
+clean :
+	rm  -f *.ll output*.* .*.dot *.dot
+
diff --git a/cfm_tests/cfg/elseif_chain/elseif_chain.c b/cfm_tests/cfg/elseif_chain/elseif_chain.c
new file mode 100644
index 000000000000..3860e75b6842
--- /dev/null
+++ b/cfm_tests/cfg/elseif_chain/elseif_chain.c
@@ -0,0 +1,42 @@
+#include <stdio.h>
+void foo(int *a1, int *a2, int *a3, int *a4, int *a5, int *a6) {
+  int a = *a1;
+  int b = *a2;
+  int c = *a3;
+  int d = *a4;
+  int e = *a5;
+  int f = *a6;
+
+  if (a > 0) {
+    a = b - c;
+    b = d * e;
+
+  } else if (b > 0) {
+    d = e - f;
+    e = c * f;
+  }
+  else if (c > 0) {
+    f = a - b;
+    c = e * d;
+  } 
+
+  printf("a=%d\n"
+         "b=%d\n"
+         "c=%d\n"
+         "d=%d\n"
+         "e=%d\n"
+         "f=%d\n",
+         a, b, c, d, e, f);
+}
+
+int main() {
+  int a, b, c, d, e, f;
+  scanf("%d", &a);
+  scanf("%d", &b);
+  scanf("%d", &c);
+  scanf("%d", &d);
+  scanf("%d", &e);
+  scanf("%d", &f);
+
+  foo(&a, &b, &c, &d, &e, &f);
+}
diff --git a/cfm_tests/cfg/elseif_chain/input1.txt b/cfm_tests/cfg/elseif_chain/input1.txt
new file mode 100644
index 000000000000..b61b7c26ca70
--- /dev/null
+++ b/cfm_tests/cfg/elseif_chain/input1.txt
@@ -0,0 +1 @@
+1 2 3 4 5 6
diff --git a/cfm_tests/cfg/elseif_chain/input2.txt b/cfm_tests/cfg/elseif_chain/input2.txt
new file mode 100644
index 000000000000..b5dd06327b1d
--- /dev/null
+++ b/cfm_tests/cfg/elseif_chain/input2.txt
@@ -0,0 +1 @@
+0 2 3 4 5 6 
diff --git a/cfm_tests/cfg/elseif_chain/input3.txt b/cfm_tests/cfg/elseif_chain/input3.txt
new file mode 100644
index 000000000000..ac1130337762
--- /dev/null
+++ b/cfm_tests/cfg/elseif_chain/input3.txt
@@ -0,0 +1 @@
+0 0 3 4 5 6 
diff --git a/cfm_tests/cfg/ifthen1/ifthen1.ll b/cfm_tests/cfg/ifthen1/ifthen1.ll
new file mode 100644
index 000000000000..c621a2e4f656
--- /dev/null
+++ b/cfm_tests/cfg/ifthen1/ifthen1.ll
@@ -0,0 +1,110 @@
+; ModuleID = 'ifthen1.c'
+source_filename = "ifthen1.c"
+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-gnu"
+
+@.str = private unnamed_addr constant [31 x i8] c"a=%d\0Ab=%d\0Ac=%d\0Ad=%d\0Ae=%d\0Af=%d\0A\00", align 1
+@.str.1 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local void @foo(i32* %a1, i32* %a2, i32* %a3, i32* %a4, i32* %a5, i32* %a6) #0 {
+entry:
+  %a1.addr = alloca i32*, align 8
+  %a2.addr = alloca i32*, align 8
+  %a3.addr = alloca i32*, align 8
+  %a4.addr = alloca i32*, align 8
+  %a5.addr = alloca i32*, align 8
+  %a6.addr = alloca i32*, align 8
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  store i32* %a1, i32** %a1.addr, align 8
+  store i32* %a2, i32** %a2.addr, align 8
+  store i32* %a3, i32** %a3.addr, align 8
+  store i32* %a4, i32** %a4.addr, align 8
+  store i32* %a5, i32** %a5.addr, align 8
+  store i32* %a6, i32** %a6.addr, align 8
+  %0 = load i32*, i32** %a1.addr, align 8
+  %1 = load i32, i32* %0, align 4
+  store i32 %1, i32* %a, align 4
+  %2 = load i32*, i32** %a2.addr, align 8
+  %3 = load i32, i32* %2, align 4
+  store i32 %3, i32* %b, align 4
+  %4 = load i32*, i32** %a3.addr, align 8
+  %5 = load i32, i32* %4, align 4
+  store i32 %5, i32* %c, align 4
+  %6 = load i32*, i32** %a4.addr, align 8
+  %7 = load i32, i32* %6, align 4
+  store i32 %7, i32* %d, align 4
+  %8 = load i32*, i32** %a5.addr, align 8
+  %9 = load i32, i32* %8, align 4
+  store i32 %9, i32* %e, align 4
+  %10 = load i32*, i32** %a6.addr, align 8
+  %11 = load i32, i32* %10, align 4
+  store i32 %11, i32* %f, align 4
+  %12 = load i32, i32* %a, align 4
+  %cmp = icmp sgt i32 %12, 0
+  br i1 %cmp, label %if.then, label %if.end
+
+if.then:                                          ; preds = %entry
+  %13 = load i32, i32* %a, align 4
+  %inc = add nsw i32 %13, 1
+  store i32 %inc, i32* %a, align 4
+  %14 = load i32, i32* %b, align 4
+  %dec = add nsw i32 %14, -1
+  store i32 %dec, i32* %b, align 4
+  %15 = load i32, i32* %c, align 4
+  %dec1 = add nsw i32 %15, -1
+  store i32 %dec1, i32* %c, align 4
+  %16 = load i32, i32* %d, align 4
+  %mul = mul nsw i32 %16, 3
+  store i32 %mul, i32* %d, align 4
+  br label %if.end
+
+if.end:                                           ; preds = %if.then, %entry
+  %17 = load i32, i32* %a, align 4
+  %18 = load i32, i32* %b, align 4
+  %19 = load i32, i32* %c, align 4
+  %20 = load i32, i32* %d, align 4
+  %21 = load i32, i32* %e, align 4
+  %22 = load i32, i32* %f, align 4
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str, i64 0, i64 0), i32 %17, i32 %18, i32 %19, i32 %20, i32 %21, i32 %22)
+  ret void
+}
+
+declare dso_local i32 @printf(i8*, ...) #1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local i32 @main() #0 {
+entry:
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  %call = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %a)
+  %call1 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %b)
+  %call2 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %c)
+  %call3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %d)
+  %call4 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %e)
+  %call5 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %f)
+  call void @foo(i32* %a, i32* %b, i32* %c, i32* %d, i32* %e, i32* %f)
+  ret i32 0
+}
+
+declare dso_local i32 @__isoc99_scanf(i8*, ...) #1
+
+attributes #0 = { noinline nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+
+!llvm.module.flags = !{!0, !1, !2}
+!llvm.ident = !{!3}
+
+!0 = !{i32 1, !"wchar_size", i32 4}
+!1 = !{i32 7, !"uwtable", i32 1}
+!2 = !{i32 7, !"frame-pointer", i32 2}
+!3 = !{!"clang version 14.0.0 (git@github.com:charitha22/llvm-project-rocm.git 9b11feafa64c148db02b5b50badeead69ea85de8)"}
diff --git a/cfm_tests/cfg/ifthen1/ifthen1.merged.ll b/cfm_tests/cfg/ifthen1/ifthen1.merged.ll
new file mode 100644
index 000000000000..0e1f648f9d06
--- /dev/null
+++ b/cfm_tests/cfg/ifthen1/ifthen1.merged.ll
@@ -0,0 +1,72 @@
+; ModuleID = '<stdin>'
+source_filename = "ifthen1.c"
+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-gnu"
+
+@.str = private unnamed_addr constant [31 x i8] c"a=%d\0Ab=%d\0Ac=%d\0Ad=%d\0Ae=%d\0Af=%d\0A\00", align 1
+@.str.1 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local void @foo(i32* %a1, i32* %a2, i32* %a3, i32* %a4, i32* %a5, i32* %a6) #0 {
+entry:
+  %0 = load i32, i32* %a1, align 4
+  %1 = load i32, i32* %a2, align 4
+  %2 = load i32, i32* %a3, align 4
+  %3 = load i32, i32* %a4, align 4
+  %4 = load i32, i32* %a5, align 4
+  %5 = load i32, i32* %a6, align 4
+  %cmp = icmp sgt i32 %0, 0
+  br i1 %cmp, label %if.then, label %replicated.bb
+
+if.then:                                          ; preds = %entry
+  %inc = add nsw i32 %0, 1
+  %dec = add nsw i32 %1, -1
+  %dec1 = add nsw i32 %2, -1
+  %mul = mul nsw i32 %3, 3
+  br label %if.end
+
+if.end:                                           ; preds = %replicated.bb, %if.then
+  %c.0 = phi i32 [ %dec1, %if.then ], [ %2, %replicated.bb ]
+  %d.0 = phi i32 [ %mul, %if.then ], [ %3, %replicated.bb ]
+  %b.0 = phi i32 [ %dec, %if.then ], [ %1, %replicated.bb ]
+  %a.0 = phi i32 [ %inc, %if.then ], [ %0, %replicated.bb ]
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str, i64 0, i64 0), i32 %a.0, i32 %b.0, i32 %c.0, i32 %d.0, i32 %4, i32 %5)
+  ret void
+
+replicated.bb:                                    ; preds = %entry
+  br label %if.end
+}
+
+declare dso_local i32 @printf(i8*, ...) #1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local i32 @main() #0 {
+entry:
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  %call = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %a)
+  %call1 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %b)
+  %call2 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %c)
+  %call3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %d)
+  %call4 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %e)
+  %call5 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %f)
+  call void @foo(i32* %a, i32* %b, i32* %c, i32* %d, i32* %e, i32* %f)
+  ret i32 0
+}
+
+declare dso_local i32 @__isoc99_scanf(i8*, ...) #1
+
+attributes #0 = { noinline nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+
+!llvm.module.flags = !{!0, !1, !2}
+!llvm.ident = !{!3}
+
+!0 = !{i32 1, !"wchar_size", i32 4}
+!1 = !{i32 7, !"uwtable", i32 1}
+!2 = !{i32 7, !"frame-pointer", i32 2}
+!3 = !{!"clang version 14.0.0 (git@github.com:charitha22/llvm-project-rocm.git 9b11feafa64c148db02b5b50badeead69ea85de8)"}
diff --git a/cfm_tests/cfg/ifthen1/ifthen1.optimized.ll b/cfm_tests/cfg/ifthen1/ifthen1.optimized.ll
new file mode 100644
index 000000000000..ee80a15f334b
--- /dev/null
+++ b/cfm_tests/cfg/ifthen1/ifthen1.optimized.ll
@@ -0,0 +1,69 @@
+; ModuleID = '<stdin>'
+source_filename = "ifthen1.c"
+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-gnu"
+
+@.str = private unnamed_addr constant [31 x i8] c"a=%d\0Ab=%d\0Ac=%d\0Ad=%d\0Ae=%d\0Af=%d\0A\00", align 1
+@.str.1 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local void @foo(i32* %a1, i32* %a2, i32* %a3, i32* %a4, i32* %a5, i32* %a6) #0 {
+entry:
+  %0 = load i32, i32* %a1, align 4
+  %1 = load i32, i32* %a2, align 4
+  %2 = load i32, i32* %a3, align 4
+  %3 = load i32, i32* %a4, align 4
+  %4 = load i32, i32* %a5, align 4
+  %5 = load i32, i32* %a6, align 4
+  %cmp = icmp sgt i32 %0, 0
+  br i1 %cmp, label %if.then, label %if.end
+
+if.then:                                          ; preds = %entry
+  %inc = add nsw i32 %0, 1
+  %dec = add nsw i32 %1, -1
+  %dec1 = add nsw i32 %2, -1
+  %mul = mul nsw i32 %3, 3
+  br label %if.end
+
+if.end:                                           ; preds = %if.then, %entry
+  %c.0 = phi i32 [ %dec1, %if.then ], [ %2, %entry ]
+  %d.0 = phi i32 [ %mul, %if.then ], [ %3, %entry ]
+  %b.0 = phi i32 [ %dec, %if.then ], [ %1, %entry ]
+  %a.0 = phi i32 [ %inc, %if.then ], [ %0, %entry ]
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str, i64 0, i64 0), i32 %a.0, i32 %b.0, i32 %c.0, i32 %d.0, i32 %4, i32 %5)
+  ret void
+}
+
+declare dso_local i32 @printf(i8*, ...) #1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local i32 @main() #0 {
+entry:
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  %call = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %a)
+  %call1 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %b)
+  %call2 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %c)
+  %call3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %d)
+  %call4 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %e)
+  %call5 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* %f)
+  call void @foo(i32* %a, i32* %b, i32* %c, i32* %d, i32* %e, i32* %f)
+  ret i32 0
+}
+
+declare dso_local i32 @__isoc99_scanf(i8*, ...) #1
+
+attributes #0 = { noinline nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+
+!llvm.module.flags = !{!0, !1, !2}
+!llvm.ident = !{!3}
+
+!0 = !{i32 1, !"wchar_size", i32 4}
+!1 = !{i32 7, !"uwtable", i32 1}
+!2 = !{i32 7, !"frame-pointer", i32 2}
+!3 = !{!"clang version 14.0.0 (git@github.com:charitha22/llvm-project-rocm.git 9b11feafa64c148db02b5b50badeead69ea85de8)"}
diff --git a/cfm_tests/cfg/ifthen1/output.merged.txt b/cfm_tests/cfg/ifthen1/output.merged.txt
new file mode 100644
index 000000000000..9d2dcb3d3138
--- /dev/null
+++ b/cfm_tests/cfg/ifthen1/output.merged.txt
@@ -0,0 +1,6 @@
+a=2
+b=1
+c=2
+d=12
+e=5
+f=6
diff --git a/cfm_tests/cfg/ifthen1/output.txt b/cfm_tests/cfg/ifthen1/output.txt
new file mode 100644
index 000000000000..9d2dcb3d3138
--- /dev/null
+++ b/cfm_tests/cfg/ifthen1/output.txt
@@ -0,0 +1,6 @@
+a=2
+b=1
+c=2
+d=12
+e=5
+f=6
diff --git a/cfm_tests/cfg/ifthen2/ifthen2.ll b/cfm_tests/cfg/ifthen2/ifthen2.ll
new file mode 100644
index 000000000000..58dba1e9a94c
--- /dev/null
+++ b/cfm_tests/cfg/ifthen2/ifthen2.ll
@@ -0,0 +1,129 @@
+; ModuleID = 'ifthen2.c'
+source_filename = "ifthen2.c"
+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-gnu"
+
+@glob = dso_local global [3 x i8] c"000", align 1
+@.str = private unnamed_addr constant [31 x i8] c"a=%d\0Ab=%d\0Ac=%d\0Ad=%d\0Ae=%d\0Af=%d\0A\00", align 1
+@.str.1 = private unnamed_addr constant [4 x i8] c"%c\0A\00", align 1
+@.str.2 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local void @foo(i32* %a1, i32* %a2, i32* %a3, i32* %a4, i32* %a5, i32* %a6, i32* %arr) #0 {
+entry:
+  %a1.addr = alloca i32*, align 8
+  %a2.addr = alloca i32*, align 8
+  %a3.addr = alloca i32*, align 8
+  %a4.addr = alloca i32*, align 8
+  %a5.addr = alloca i32*, align 8
+  %a6.addr = alloca i32*, align 8
+  %arr.addr = alloca i32*, align 8
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  store i32* %a1, i32** %a1.addr, align 8
+  store i32* %a2, i32** %a2.addr, align 8
+  store i32* %a3, i32** %a3.addr, align 8
+  store i32* %a4, i32** %a4.addr, align 8
+  store i32* %a5, i32** %a5.addr, align 8
+  store i32* %a6, i32** %a6.addr, align 8
+  store i32* %arr, i32** %arr.addr, align 8
+  %0 = load i32*, i32** %a1.addr, align 8
+  %1 = load i32, i32* %0, align 4
+  store i32 %1, i32* %a, align 4
+  %2 = load i32*, i32** %a2.addr, align 8
+  %3 = load i32, i32* %2, align 4
+  store i32 %3, i32* %b, align 4
+  %4 = load i32*, i32** %a3.addr, align 8
+  %5 = load i32, i32* %4, align 4
+  store i32 %5, i32* %c, align 4
+  %6 = load i32*, i32** %a4.addr, align 8
+  %7 = load i32, i32* %6, align 4
+  store i32 %7, i32* %d, align 4
+  %8 = load i32*, i32** %a5.addr, align 8
+  %9 = load i32, i32* %8, align 4
+  store i32 %9, i32* %e, align 4
+  %10 = load i32*, i32** %a6.addr, align 8
+  %11 = load i32, i32* %10, align 4
+  store i32 %11, i32* %f, align 4
+  %12 = load i32, i32* %a, align 4
+  %cmp = icmp sgt i32 %12, 0
+  br i1 %cmp, label %if.then, label %if.end
+
+if.then:                                          ; preds = %entry
+  %13 = load i32*, i32** %arr.addr, align 8
+  %arrayidx = getelementptr inbounds i32, i32* %13, i64 0
+  %14 = load i32, i32* %arrayidx, align 4
+  %15 = load i32, i32* %a, align 4
+  %add = add nsw i32 %15, %14
+  store i32 %add, i32* %a, align 4
+  %16 = load i32, i32* %b, align 4
+  %dec = add nsw i32 %16, -1
+  store i32 %dec, i32* %b, align 4
+  %17 = load i32, i32* %c, align 4
+  %dec1 = add nsw i32 %17, -1
+  store i32 %dec1, i32* %c, align 4
+  %18 = load i32, i32* %d, align 4
+  %mul = mul nsw i32 %18, 3
+  store i32 %mul, i32* %d, align 4
+  br label %if.end
+
+if.end:                                           ; preds = %if.then, %entry
+  %19 = load i32, i32* %a, align 4
+  %20 = load i32, i32* %b, align 4
+  %21 = load i32, i32* %c, align 4
+  %22 = load i32, i32* %d, align 4
+  %23 = load i32, i32* %e, align 4
+  %24 = load i32, i32* %f, align 4
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str, i64 0, i64 0), i32 %19, i32 %20, i32 %21, i32 %22, i32 %23, i32 %24)
+  ret void
+}
+
+declare dso_local i32 @printf(i8*, ...) #1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local i32 @main() #0 {
+entry:
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  %arr = alloca [2 x i32], align 4
+  %g = alloca i8, align 1
+  %0 = load i8, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @glob, i64 0, i64 0), align 1
+  store i8 %0, i8* %g, align 1
+  %1 = load i8, i8* %g, align 1
+  %conv = sext i8 %1 to i32
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i64 0, i64 0), i32 %conv)
+  %call1 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %a)
+  %call2 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %b)
+  %call3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %c)
+  %call4 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %d)
+  %call5 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %e)
+  %call6 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %f)
+  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 0
+  %call7 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %arrayidx)
+  %arrayidx8 = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 1
+  %call9 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %arrayidx8)
+  %arraydecay = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 0
+  call void @foo(i32* %a, i32* %b, i32* %c, i32* %d, i32* %e, i32* %f, i32* %arraydecay)
+  ret i32 0
+}
+
+declare dso_local i32 @__isoc99_scanf(i8*, ...) #1
+
+attributes #0 = { noinline nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+
+!llvm.module.flags = !{!0, !1, !2}
+!llvm.ident = !{!3}
+
+!0 = !{i32 1, !"wchar_size", i32 4}
+!1 = !{i32 7, !"uwtable", i32 1}
+!2 = !{i32 7, !"frame-pointer", i32 2}
+!3 = !{!"clang version 14.0.0 (git@github.com:charitha22/llvm-project-rocm.git 9b11feafa64c148db02b5b50badeead69ea85de8)"}
diff --git a/cfm_tests/cfg/ifthen2/ifthen2.merged.ll b/cfm_tests/cfg/ifthen2/ifthen2.merged.ll
new file mode 100644
index 000000000000..3974602d71d5
--- /dev/null
+++ b/cfm_tests/cfg/ifthen2/ifthen2.merged.ll
@@ -0,0 +1,89 @@
+; ModuleID = '<stdin>'
+source_filename = "ifthen2.c"
+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-gnu"
+
+@glob = dso_local global [3 x i8] c"000", align 1
+@.str = private unnamed_addr constant [31 x i8] c"a=%d\0Ab=%d\0Ac=%d\0Ad=%d\0Ae=%d\0Af=%d\0A\00", align 1
+@.str.1 = private unnamed_addr constant [4 x i8] c"%c\0A\00", align 1
+@.str.2 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
+@cfmse.dci_gv = private global [8 x i8] zeroinitializer
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local void @foo(i32* %a1, i32* %a2, i32* %a3, i32* %a4, i32* %a5, i32* %a6, i32* %arr) #0 {
+entry:
+  %0 = load i32, i32* %a1, align 4
+  %1 = load i32, i32* %a2, align 4
+  %2 = load i32, i32* %a3, align 4
+  %3 = load i32, i32* %a4, align 4
+  %4 = load i32, i32* %a5, align 4
+  %5 = load i32, i32* %a6, align 4
+  %cmp = icmp sgt i32 %0, 0
+  %cfmse.dci_gep = getelementptr [8 x i8], [8 x i8]* @cfmse.dci_gv, i64 0, i64 0
+  br label %merged.bb
+
+if.end:                                           ; preds = %merged.bb
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str, i64 0, i64 0), i32 %moved.sel7, i32 %moved.sel6, i32 %moved.sel, i32 %moved.sel5, i32 %4, i32 %5)
+  ret void
+
+merged.bb:                                        ; preds = %entry
+  %6 = getelementptr inbounds i32, i32* %arr, i64 0
+  %7 = load i32, i32* %6, align 4
+  %merged.select = select i1 %cmp, i32 %7, i32 0
+  %8 = add nsw i32 %0, %merged.select
+  %merged.select1 = select i1 %cmp, i32 -1, i32 0
+  %9 = add nsw i32 %1, %merged.select1
+  %merged.select2 = select i1 %cmp, i32 -1, i32 0
+  %10 = add nsw i32 %2, %merged.select2
+  %merged.select3 = select i1 %cmp, i32 3, i32 1
+  %11 = mul nsw i32 %3, %merged.select3
+  %moved.sel = select i1 %cmp, i32 %10, i32 %2
+  %moved.sel5 = select i1 %cmp, i32 %11, i32 %3
+  %moved.sel6 = select i1 %cmp, i32 %9, i32 %1
+  %moved.sel7 = select i1 %cmp, i32 %8, i32 %0
+  br label %if.end
+}
+
+declare dso_local i32 @printf(i8*, ...) #1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local i32 @main() #0 {
+entry:
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  %arr = alloca [2 x i32], align 4
+  %0 = load i8, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @glob, i64 0, i64 0), align 1
+  %conv = sext i8 %0 to i32
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i64 0, i64 0), i32 %conv)
+  %call1 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %a)
+  %call2 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %b)
+  %call3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %c)
+  %call4 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %d)
+  %call5 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %e)
+  %call6 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %f)
+  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 0
+  %call7 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %arrayidx)
+  %arrayidx8 = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 1
+  %call9 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %arrayidx8)
+  %arraydecay = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 0
+  call void @foo(i32* %a, i32* %b, i32* %c, i32* %d, i32* %e, i32* %f, i32* %arraydecay)
+  %cfmse.dci_gep = getelementptr [8 x i8], [8 x i8]* @cfmse.dci_gv, i64 0, i64 0
+  ret i32 0
+}
+
+declare dso_local i32 @__isoc99_scanf(i8*, ...) #1
+
+attributes #0 = { noinline nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+
+!llvm.module.flags = !{!0, !1, !2}
+!llvm.ident = !{!3}
+
+!0 = !{i32 1, !"wchar_size", i32 4}
+!1 = !{i32 7, !"uwtable", i32 1}
+!2 = !{i32 7, !"frame-pointer", i32 2}
+!3 = !{!"clang version 14.0.0 (git@github.com:charitha22/llvm-project-rocm.git 9b11feafa64c148db02b5b50badeead69ea85de8)"}
diff --git a/cfm_tests/cfg/ifthen2/ifthen2.optimized.ll b/cfm_tests/cfg/ifthen2/ifthen2.optimized.ll
new file mode 100644
index 000000000000..acbb72bea954
--- /dev/null
+++ b/cfm_tests/cfg/ifthen2/ifthen2.optimized.ll
@@ -0,0 +1,82 @@
+; ModuleID = '<stdin>'
+source_filename = "ifthen2.c"
+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-gnu"
+
+@glob = dso_local global [3 x i8] c"000", align 1
+@.str = private unnamed_addr constant [31 x i8] c"a=%d\0Ab=%d\0Ac=%d\0Ad=%d\0Ae=%d\0Af=%d\0A\00", align 1
+@.str.1 = private unnamed_addr constant [4 x i8] c"%c\0A\00", align 1
+@.str.2 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local void @foo(i32* %a1, i32* %a2, i32* %a3, i32* %a4, i32* %a5, i32* %a6, i32* %arr) #0 {
+entry:
+  %0 = load i32, i32* %a1, align 4
+  %1 = load i32, i32* %a2, align 4
+  %2 = load i32, i32* %a3, align 4
+  %3 = load i32, i32* %a4, align 4
+  %4 = load i32, i32* %a5, align 4
+  %5 = load i32, i32* %a6, align 4
+  %cmp = icmp sgt i32 %0, 0
+  br i1 %cmp, label %if.then, label %if.end
+
+if.then:                                          ; preds = %entry
+  %arrayidx = getelementptr inbounds i32, i32* %arr, i64 0
+  %6 = load i32, i32* %arrayidx, align 4
+  %add = add nsw i32 %0, %6
+  %dec = add nsw i32 %1, -1
+  %dec1 = add nsw i32 %2, -1
+  %mul = mul nsw i32 %3, 3
+  br label %if.end
+
+if.end:                                           ; preds = %if.then, %entry
+  %c.0 = phi i32 [ %dec1, %if.then ], [ %2, %entry ]
+  %d.0 = phi i32 [ %mul, %if.then ], [ %3, %entry ]
+  %b.0 = phi i32 [ %dec, %if.then ], [ %1, %entry ]
+  %a.0 = phi i32 [ %add, %if.then ], [ %0, %entry ]
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str, i64 0, i64 0), i32 %a.0, i32 %b.0, i32 %c.0, i32 %d.0, i32 %4, i32 %5)
+  ret void
+}
+
+declare dso_local i32 @printf(i8*, ...) #1
+
+; Function Attrs: noinline nounwind uwtable
+define dso_local i32 @main() #0 {
+entry:
+  %a = alloca i32, align 4
+  %b = alloca i32, align 4
+  %c = alloca i32, align 4
+  %d = alloca i32, align 4
+  %e = alloca i32, align 4
+  %f = alloca i32, align 4
+  %arr = alloca [2 x i32], align 4
+  %0 = load i8, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @glob, i64 0, i64 0), align 1
+  %conv = sext i8 %0 to i32
+  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i64 0, i64 0), i32 %conv)
+  %call1 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %a)
+  %call2 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %b)
+  %call3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %c)
+  %call4 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %d)
+  %call5 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %e)
+  %call6 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %f)
+  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 0
+  %call7 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %arrayidx)
+  %arrayidx8 = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 1
+  %call9 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i32* %arrayidx8)
+  %arraydecay = getelementptr inbounds [2 x i32], [2 x i32]* %arr, i64 0, i64 0
+  call void @foo(i32* %a, i32* %b, i32* %c, i32* %d, i32* %e, i32* %f, i32* %arraydecay)
+  ret i32 0
+}
+
+declare dso_local i32 @__isoc99_scanf(i8*, ...) #1
+
+attributes #0 = { noinline nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
+
+!llvm.module.flags = !{!0, !1, !2}
+!llvm.ident = !{!3}
+
+!0 = !{i32 1, !"wchar_size", i32 4}
+!1 = !{i32 7, !"uwtable", i32 1}
+!2 = !{i32 7, !"frame-pointer", i32 2}
+!3 = !{!"clang version 14.0.0 (git@github.com:charitha22/llvm-project-rocm.git 9b11feafa64c148db02b5b50badeead69ea85de8)"}
diff --git a/cfm_tests/cfg/ifthen2/output.merged.txt b/cfm_tests/cfg/ifthen2/output.merged.txt
new file mode 100644
index 000000000000..0e7655670c1d
--- /dev/null
+++ b/cfm_tests/cfg/ifthen2/output.merged.txt
@@ -0,0 +1,7 @@
+0
+a=1
+b=1
+c=2
+d=12
+e=5
+f=6
diff --git a/cfm_tests/cfg/ifthen2/output.txt b/cfm_tests/cfg/ifthen2/output.txt
new file mode 100644
index 000000000000..0e7655670c1d
--- /dev/null
+++ b/cfm_tests/cfg/ifthen2/output.txt
@@ -0,0 +1,7 @@
+0
+a=1
+b=1
+c=2
+d=12
+e=5
+f=6
diff --git a/cfm_tests/cfg/loop_with_single_bb/Makefile b/cfm_tests/cfg/loop_with_single_bb/Makefile
new file mode 100644
index 000000000000..f964a16f0912
--- /dev/null
+++ b/cfm_tests/cfg/loop_with_single_bb/Makefile
@@ -0,0 +1,31 @@
+include ../config.mk
+
+clang_flags=-emit-llvm -S -Xclang -disable-O0-optnone 
+opt_flags=-sroa -S
+
+obj := $(patsubst %.c,%.merged.ll,$(wildcard *.c))
+inputs := $(wildcard input*.txt)
+all : ${obj}
+	
+%.merged.ll : %.c	
+	${clang} ${clang_flags} $^
+	${opt} ${opt_flags} < $(patsubst %.c,%.ll,$^) > $(patsubst %.c,%.optimized.ll,$^)
+	${opt}  ${cfmerger_flags} < $(patsubst %.c,%.optimized.ll,$^) > $@
+
+
+test : is_diff
+
+is_diff : ${obj}
+	@cmp -s  $(patsubst %.merged.ll,%.optimized.ll,$^) $^ ; \
+	RETVAL=$$?; \
+	if [ $$RETVAL -eq 0 ]; then \
+		echo "SUCCESS : transformation did NOT change source IR"; \
+	else \
+		echo "ERROR : transformation did change source IR "; \
+	fi
+
+
+
+clean :
+	rm  -f *.ll output*.* .*.dot
+
diff --git a/cfm_tests/cfg/loop_with_single_bb/loop_with_single_bb.c b/cfm_tests/cfg/loop_with_single_bb/loop_with_single_bb.c
new file mode 100644
index 000000000000..b7139cdd5f1c
--- /dev/null
+++ b/cfm_tests/cfg/loop_with_single_bb/loop_with_single_bb.c
@@ -0,0 +1,44 @@
+#include <stdio.h>
+void foo(int *a1, int *a2, int *a3, int *a4, int *a5, int *a6) {
+  int a = *a1;
+  int b = *a2;
+  int c = *a3;
+  int d = *a4;
+  int e = *a5;
+  int f = *a6;
+
+  if (a == 0) {
+    while (c > 0) {
+      c--;
+      d+=10;
+      e-=5;
+    }
+
+  }
+  else {
+    a--;
+    b+=7;
+    f-=3;
+  }
+
+  
+  printf("a=%d\n"
+         "b=%d\n"
+         "c=%d\n"
+         "d=%d\n"
+         "e=%d\n"
+         "f=%d\n",
+         a, b, c, d, e, f);
+}
+
+int main() {
+  int a, b, c, d, e, f;
+  scanf("%d", &a);
+  scanf("%d", &b);
+  scanf("%d", &c);
+  scanf("%d", &d);
+  scanf("%d", &e);
+  scanf("%d", &f);
+
+  foo(&a, &b, &c, &d, &e, &f);
+}
diff --git a/cfm_tests/cfg/lud_cfg/Makefile b/cfm_tests/cfg/lud_cfg/Makefile
new file mode 100644
index 000000000000..ca39fb0564f5
--- /dev/null
+++ b/cfm_tests/cfg/lud_cfg/Makefile
@@ -0,0 +1,4 @@
+test:
+	@echo "SUCCESS : no tests here"
+clean :
+	rm -rf *.ll
diff --git a/cfm_tests/cfg/lud_cfg/lud_cfg.c b/cfm_tests/cfg/lud_cfg/lud_cfg.c
new file mode 100644
index 000000000000..b21b50e283d2
--- /dev/null
+++ b/cfm_tests/cfg/lud_cfg/lud_cfg.c
@@ -0,0 +1,40 @@
+#define BLOCK_SIZE 16
+#include <stdio.h>
+void foo() {
+
+  float dia[BLOCK_SIZE][BLOCK_SIZE];
+  float peri_row[BLOCK_SIZE][BLOCK_SIZE];
+  float peri_col[BLOCK_SIZE][BLOCK_SIZE];
+  for (int a = 0; a < BLOCK_SIZE; a++) {
+    for (int b = 0; b < BLOCK_SIZE; b++) {
+      float val = a/(float)BLOCK_SIZE + b/(float)BLOCK_SIZE;
+      dia[a][b] = val;
+      peri_col[a][b] = val;
+      peri_row[a][b] = val;
+    }
+  }
+
+  int tid = 17, idx, i, j;
+
+  if (tid < BLOCK_SIZE) { // peri-row
+    idx = tid;
+    for (i = 1; i < BLOCK_SIZE; i++) {
+      for (j = 0; j < i; j++)
+        peri_row[i][idx] -= dia[i][j] * peri_row[j][idx];
+    }
+  } else { // peri-col
+    idx = tid - BLOCK_SIZE;
+    for (i = 0; i < BLOCK_SIZE; i++) {
+      for (j = 0; j < i; j++)
+        peri_col[idx][i] -= peri_col[idx][j] * dia[j][i];
+      peri_col[idx][i] /= dia[i][i];
+    }
+  }
+  for (int a = 0; a < BLOCK_SIZE; a++) {
+    for (int b = 0; b < BLOCK_SIZE; b++) {
+      printf("%f %f\n", peri_row[a][b], peri_col[a][b]);
+    }
+  }
+}
+
+int main() { foo(); }
\ No newline at end of file
diff --git a/cfm_tests/cfg/nested_if/Makefile b/cfm_tests/cfg/nested_if/Makefile
new file mode 100644
index 000000000000..68b3d98cba1c
--- /dev/null
+++ b/cfm_tests/cfg/nested_if/Makefile
@@ -0,0 +1,73 @@
+include ../config.mk
+
+clang_flags=-emit-llvm -S -Xclang -disable-O0-optnone 
+opt_flags=-sroa -S
+
+obj := $(patsubst %.c,%.merged.ll,$(wildcard *.c))
+inputs := $(wildcard input*.txt)
+all : ${obj}
+	
+%.merged.ll : %.c	
+	${clang} ${clang_flags} $^
+	${opt} ${opt_flags} < $(patsubst %.c,%.ll,$^) > $(patsubst %.c,%.optimized.ll,$^)
+	${opt}  ${cfmerger_flags} < $(patsubst %.c,%.optimized.ll,$^) > $@
+
+
+test : is_same test1 test2 test3 test4
+
+is_same : ${obj}
+	@cmp -s  $(patsubst %.merged.ll,%.optimized.ll,$^) $^ ; \
+	RETVAL=$$?; \
+	if [ $$RETVAL -eq 0 ]; then \
+					echo "ERROR : transformation did NOT change source IR"; \
+	else \
+					echo "SUCCESS : transformation did change source IR"; \
+	fi
+
+
+test1  : input1.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test2 : input2.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test3 : input3.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test4 : input4.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+
+
+clean :
+	rm  -f *.ll output*.* .*.dot
+
diff --git a/cfm_tests/cfg/nested_if/input1.txt b/cfm_tests/cfg/nested_if/input1.txt
new file mode 100644
index 000000000000..b61b7c26ca70
--- /dev/null
+++ b/cfm_tests/cfg/nested_if/input1.txt
@@ -0,0 +1 @@
+1 2 3 4 5 6
diff --git a/cfm_tests/cfg/nested_if/input2.txt b/cfm_tests/cfg/nested_if/input2.txt
new file mode 100644
index 000000000000..03742e4d1fb6
--- /dev/null
+++ b/cfm_tests/cfg/nested_if/input2.txt
@@ -0,0 +1 @@
+1 -1 -1 4 5 6
diff --git a/cfm_tests/cfg/nested_if/input3.txt b/cfm_tests/cfg/nested_if/input3.txt
new file mode 100644
index 000000000000..4c1119d22373
--- /dev/null
+++ b/cfm_tests/cfg/nested_if/input3.txt
@@ -0,0 +1 @@
+1 2 -1 4 5 6
diff --git a/cfm_tests/cfg/nested_if/input4.txt b/cfm_tests/cfg/nested_if/input4.txt
new file mode 100644
index 000000000000..b4c7e980699b
--- /dev/null
+++ b/cfm_tests/cfg/nested_if/input4.txt
@@ -0,0 +1 @@
+-1 -1 3 4 5 6
diff --git a/cfm_tests/cfg/nested_if/nested_if.c b/cfm_tests/cfg/nested_if/nested_if.c
new file mode 100644
index 000000000000..fc605fc482f4
--- /dev/null
+++ b/cfm_tests/cfg/nested_if/nested_if.c
@@ -0,0 +1,54 @@
+#include <stdio.h>
+void foo(int *a1, int *a2, int *a3, int *a4, int *a5, int *a6) {
+  int a = *a1;
+  int b = *a2;
+  int c = *a3;
+  int d = *a4;
+  int e = *a5;
+  int f = *a6;
+
+  if (a > 0) {
+    a++;
+    if (b > 0) {
+      b++;
+      if (c > 0)
+        c++;
+    }
+    if (c < 0) {
+      if (d > 0)
+        d++;
+    }
+  } else {
+
+    if (e > 0) {
+      if (a > 0) {
+        a++;
+      }
+    }
+    f++;
+    if (d > 0) {
+      c++;
+      if (b < 0)
+        b++;
+    }
+  }
+  printf("a=%d\n"
+         "b=%d\n"
+         "c=%d\n"
+         "d=%d\n"
+         "e=%d\n"
+         "f=%d\n",
+         a, b, c, d, e, f);
+}
+
+int main() {
+  int a, b, c, d, e, f;
+  scanf("%d", &a);
+  scanf("%d", &b);
+  scanf("%d", &c);
+  scanf("%d", &d);
+  scanf("%d", &e);
+  scanf("%d", &f);
+
+  foo(&a, &b, &c, &d, &e, &f);
+}
diff --git a/cfm_tests/cfg/nested_if2/Makefile b/cfm_tests/cfg/nested_if2/Makefile
new file mode 100644
index 000000000000..9a7bb4223a41
--- /dev/null
+++ b/cfm_tests/cfg/nested_if2/Makefile
@@ -0,0 +1,84 @@
+include ../config.mk
+
+clang_flags=-emit-llvm -S -Xclang -disable-O0-optnone 
+opt_flags=-sroa -S
+
+obj := $(patsubst %.c,%.merged.ll,$(wildcard *.c))
+inputs := $(wildcard input*.txt)
+all : ${obj}
+	
+%.merged.ll : %.c	
+	${clang} ${clang_flags} $^
+	${opt} ${opt_flags} < $(patsubst %.c,%.ll,$^) > $(patsubst %.c,%.optimized.ll,$^)
+	${opt}  ${cfmerger_flags} < $(patsubst %.c,%.optimized.ll,$^) > $@
+
+
+test : is_same test1 test2 test3 test4 
+
+is_same : ${obj}
+	@cmp -s  $(patsubst %.merged.ll,%.optimized.ll,$^) $^ ; \
+	RETVAL=$$?; \
+	if [ $$RETVAL -eq 0 ]; then \
+					echo "ERROR : transformation did NOT change source IR"; \
+	else \
+					echo "SUCCESS : transformation did change source IR"; \
+	fi
+
+
+test1  : input1.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test2 : input2.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test3 : input3.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test4 : input4.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+test5 : input5.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+
+
+clean :
+	rm  -f *.ll output*.*
+
diff --git a/cfm_tests/cfg/nested_if2/input1.txt b/cfm_tests/cfg/nested_if2/input1.txt
new file mode 100644
index 000000000000..b61b7c26ca70
--- /dev/null
+++ b/cfm_tests/cfg/nested_if2/input1.txt
@@ -0,0 +1 @@
+1 2 3 4 5 6
diff --git a/cfm_tests/cfg/nested_if2/input2.txt b/cfm_tests/cfg/nested_if2/input2.txt
new file mode 100644
index 000000000000..ae2193893f67
--- /dev/null
+++ b/cfm_tests/cfg/nested_if2/input2.txt
@@ -0,0 +1 @@
+1 1 3 4 5 6
diff --git a/cfm_tests/cfg/nested_if2/input3.txt b/cfm_tests/cfg/nested_if2/input3.txt
new file mode 100644
index 000000000000..4d93971ccbb9
--- /dev/null
+++ b/cfm_tests/cfg/nested_if2/input3.txt
@@ -0,0 +1 @@
+-1 2 3 4 1 6
diff --git a/cfm_tests/cfg/nested_if2/input4.txt b/cfm_tests/cfg/nested_if2/input4.txt
new file mode 100644
index 000000000000..7f66fcb46962
--- /dev/null
+++ b/cfm_tests/cfg/nested_if2/input4.txt
@@ -0,0 +1 @@
+-1 2 3 4 2 6
diff --git a/cfm_tests/cfg/nested_if2/nested_if2.c b/cfm_tests/cfg/nested_if2/nested_if2.c
new file mode 100644
index 000000000000..1add230b66a8
--- /dev/null
+++ b/cfm_tests/cfg/nested_if2/nested_if2.c
@@ -0,0 +1,39 @@
+#include <stdio.h>
+void foo() {
+
+  int a = scanf("%d", &a);
+  int b = scanf("%d", &b);
+  int c = scanf("%d", &c);
+  int d = scanf("%d", &d);
+  int e = scanf("%d", &e);
+  int f = scanf("%d", &f);
+
+  if (a > 0) {
+    if (b == 2) {
+      b *= 5;
+      b++;
+    }
+
+    a++;
+    b--;
+    c *= 10;
+  } else {
+    if (e == 1)
+      e *= 10;
+    e++;
+    f--;
+    c *= 10;
+  }
+
+  printf("a=%d\n"
+          "b=%d\n"
+          "c=%d\n"
+          "d=%d\n"
+          "e=%d\n"
+          "f=%d\n",
+          a,b,c,d,e,f);
+}
+
+int main() {
+    foo();
+}
diff --git a/cfm_tests/cfg/nested_if3/Makefile b/cfm_tests/cfg/nested_if3/Makefile
new file mode 100644
index 000000000000..0e6787c3f821
--- /dev/null
+++ b/cfm_tests/cfg/nested_if3/Makefile
@@ -0,0 +1,73 @@
+include ../config.mk
+
+clang_flags=-emit-llvm -S -Xclang -disable-O0-optnone 
+opt_flags=-sroa -S
+
+obj := $(patsubst %.c,%.merged.ll,$(wildcard *.c))
+inputs := $(wildcard input*.txt)
+all : ${obj}
+	
+%.merged.ll : %.c	
+	${clang} ${clang_flags} $^
+	${opt} ${opt_flags} < $(patsubst %.c,%.ll,$^) > $(patsubst %.c,%.optimized.ll,$^)
+	${opt}  ${cfmerger_flags} < $(patsubst %.c,%.optimized.ll,$^) > $@
+
+
+test : is_same test1 test2 test3 test4
+
+is_same : ${obj}
+	@cmp -s  $(patsubst %.merged.ll,%.optimized.ll,$^) $^ ; \
+	RETVAL=$$?; \
+	if [ $$RETVAL -eq 0 ]; then \
+					echo "ERROR : transformation did NOT change source IR"; \
+	else \
+					echo "SUCCESS : transformation did change source IR"; \
+	fi
+
+
+test1  : input1.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test2 : input2.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test3 : input3.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test4 : input4.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+
+
+clean :
+	rm  -f *.ll output*.*
+
diff --git a/cfm_tests/cfg/nested_if3/input1.txt b/cfm_tests/cfg/nested_if3/input1.txt
new file mode 100644
index 000000000000..786a41f65c03
--- /dev/null
+++ b/cfm_tests/cfg/nested_if3/input1.txt
@@ -0,0 +1 @@
+1 1 3 4 5 6 
diff --git a/cfm_tests/cfg/nested_if3/input2.txt b/cfm_tests/cfg/nested_if3/input2.txt
new file mode 100644
index 000000000000..fe222ae9e0ab
--- /dev/null
+++ b/cfm_tests/cfg/nested_if3/input2.txt
@@ -0,0 +1 @@
+-1 1 3 4 1 6 
diff --git a/cfm_tests/cfg/nested_if3/input3.txt b/cfm_tests/cfg/nested_if3/input3.txt
new file mode 100644
index 000000000000..ebd769315e50
--- /dev/null
+++ b/cfm_tests/cfg/nested_if3/input3.txt
@@ -0,0 +1 @@
+-1 1 3 4 5 6 
diff --git a/cfm_tests/cfg/nested_if3/input4.txt b/cfm_tests/cfg/nested_if3/input4.txt
new file mode 100644
index 000000000000..6ff2b89b459d
--- /dev/null
+++ b/cfm_tests/cfg/nested_if3/input4.txt
@@ -0,0 +1 @@
+1 2 3 4 5 6 
diff --git a/cfm_tests/cfg/nested_if3/nested_if3.c b/cfm_tests/cfg/nested_if3/nested_if3.c
new file mode 100644
index 000000000000..2a6407e99f71
--- /dev/null
+++ b/cfm_tests/cfg/nested_if3/nested_if3.c
@@ -0,0 +1,46 @@
+#include <stdio.h>
+void foo(int *a1, int *a2, int *a3, int *a4, int *a5, int *a6) {
+  int a = *a1;
+  int b = *a2;
+  int c = *a3;
+  int d = *a4;
+  int e = *a5;
+  int f = *a6;
+
+  if (a > 0) {
+    if (b == 2) {
+      b *= 5;
+      b++;
+    }
+
+    a++;
+    b--;
+    c *= 10;
+  } else {
+    if (e == 1)
+      e *= 10;
+    e++;
+    f--;
+    c *= 10;
+  }
+
+  printf("a=%d\n"
+         "b=%d\n"
+         "c=%d\n"
+         "d=%d\n"
+         "e=%d\n"
+         "f=%d\n",
+         a, b, c, d, e, f);
+}
+
+int main() {
+  int a, b, c, d, e, f;
+  scanf("%d", &a);
+  scanf("%d", &b);
+  scanf("%d", &c);
+  scanf("%d", &d);
+  scanf("%d", &e);
+  scanf("%d", &f);
+
+  foo(&a, &b, &c, &d, &e, &f);
+}
diff --git a/cfm_tests/cfg/nested_if4/Makefile b/cfm_tests/cfg/nested_if4/Makefile
new file mode 100644
index 000000000000..03e21e85e94e
--- /dev/null
+++ b/cfm_tests/cfg/nested_if4/Makefile
@@ -0,0 +1,132 @@
+include ../config.mk
+clang_flags=-emit-llvm -S -Xclang -disable-O0-optnone 
+opt_flags=-sroa -S
+
+obj := $(patsubst %.c,%.merged.ll,$(wildcard *.c))
+inputs := $(wildcard input*.txt)
+all : ${obj}
+	
+%.merged.ll : %.c	
+	${clang} ${clang_flags} $^
+	${opt} ${opt_flags} < $(patsubst %.c,%.ll,$^) > $(patsubst %.c,%.optimized.ll,$^)
+	${opt}  ${cfmerger_flags} < $(patsubst %.c,%.optimized.ll,$^) > $@
+
+
+test : is_same test1 test2 test3 test4 test5 test6 test7 test8 
+
+is_same : ${obj}
+	@cmp -s  $(patsubst %.merged.ll,%.optimized.ll,$^) $^ ; \
+	RETVAL=$$?; \
+	if [ $$RETVAL -eq 0 ]; then \
+					echo "ERROR : transformation did NOT change source IR"; \
+	else \
+					echo "SUCCESS : transformation did change source IR"; \
+	fi
+
+
+test1  : input1.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test2 : input2.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test3 : input3.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test4 : input4.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test5 : input5.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test6 : input6.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test7 : input7.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test8 : input8.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test9 : input9.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+test10 : input10.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+
+clean :
+	rm  -f *.ll output*.* .*.dot
+
diff --git a/cfm_tests/cfg/nested_if4/input1.txt b/cfm_tests/cfg/nested_if4/input1.txt
new file mode 100644
index 000000000000..b61b7c26ca70
--- /dev/null
+++ b/cfm_tests/cfg/nested_if4/input1.txt
@@ -0,0 +1 @@
+1 2 3 4 5 6
diff --git a/cfm_tests/cfg/nested_if4/input2.txt b/cfm_tests/cfg/nested_if4/input2.txt
new file mode 100644
index 000000000000..66be51e83068
--- /dev/null
+++ b/cfm_tests/cfg/nested_if4/input2.txt
@@ -0,0 +1 @@
+1 2 -1 4  5 6
diff --git a/cfm_tests/cfg/nested_if4/input3.txt b/cfm_tests/cfg/nested_if4/input3.txt
new file mode 100644
index 000000000000..0fd76a2081c5
--- /dev/null
+++ b/cfm_tests/cfg/nested_if4/input3.txt
@@ -0,0 +1 @@
+1 -1 3 4 5 6
diff --git a/cfm_tests/cfg/nested_if4/input4.txt b/cfm_tests/cfg/nested_if4/input4.txt
new file mode 100644
index 000000000000..03742e4d1fb6
--- /dev/null
+++ b/cfm_tests/cfg/nested_if4/input4.txt
@@ -0,0 +1 @@
+1 -1 -1 4 5 6
diff --git a/cfm_tests/cfg/nested_if4/input5.txt b/cfm_tests/cfg/nested_if4/input5.txt
new file mode 100644
index 000000000000..8a2f4ecd9452
--- /dev/null
+++ b/cfm_tests/cfg/nested_if4/input5.txt
@@ -0,0 +1 @@
+1 -1 -1 -1 5 6
diff --git a/cfm_tests/cfg/nested_if4/input6.txt b/cfm_tests/cfg/nested_if4/input6.txt
new file mode 100644
index 000000000000..2d595650de6d
--- /dev/null
+++ b/cfm_tests/cfg/nested_if4/input6.txt
@@ -0,0 +1 @@
+-1 -1 3 1 1 6
diff --git a/cfm_tests/cfg/nested_if4/input7.txt b/cfm_tests/cfg/nested_if4/input7.txt
new file mode 100644
index 000000000000..774e2332821f
--- /dev/null
+++ b/cfm_tests/cfg/nested_if4/input7.txt
@@ -0,0 +1 @@
+-1 -1 3 1 -1 6
diff --git a/cfm_tests/cfg/nested_if4/input8.txt b/cfm_tests/cfg/nested_if4/input8.txt
new file mode 100644
index 000000000000..bad2b738d95f
--- /dev/null
+++ b/cfm_tests/cfg/nested_if4/input8.txt
@@ -0,0 +1 @@
+-1 2 3 -1 -1 6
diff --git a/cfm_tests/cfg/nested_if4/nested_if4.c b/cfm_tests/cfg/nested_if4/nested_if4.c
new file mode 100644
index 000000000000..1bdf9ccd9a69
--- /dev/null
+++ b/cfm_tests/cfg/nested_if4/nested_if4.c
@@ -0,0 +1,54 @@
+#include <stdio.h>
+void foo(int *a1, int *a2, int *a3, int *a4, int *a5, int *a6) {
+  int a = *a1;
+  int b = *a2;
+  int c = *a3;
+  int d = *a4;
+  int e = *a5;
+  int f = *a6;
+
+  if (a > 0) {
+    if (b > 0) {
+      if (c > 0)
+        c++;
+    }
+    a++;
+    if (c < 0) {
+      b++;
+      if (d > 0)
+        d++;
+    }
+  } else {
+
+    if (e > 0) {
+      if (a > 0) {
+        a++;
+      }
+    }
+    f++;
+    if (d > 0) {
+      c++;
+      if (b < 0)
+        b++;
+    }
+  }
+  printf("a=%d\n"
+         "b=%d\n"
+         "c=%d\n"
+         "d=%d\n"
+         "e=%d\n"
+         "f=%d\n",
+         a, b, c, d, e, f);
+}
+
+int main() {
+  int a, b, c, d, e, f;
+  scanf("%d", &a);
+  scanf("%d", &b);
+  scanf("%d", &c);
+  scanf("%d", &d);
+  scanf("%d", &e);
+  scanf("%d", &f);
+
+  foo(&a, &b, &c, &d, &e, &f);
+}
diff --git a/cfm_tests/cfg/nested_if_asym/Makefile b/cfm_tests/cfg/nested_if_asym/Makefile
new file mode 100644
index 000000000000..378837ccf108
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_asym/Makefile
@@ -0,0 +1,84 @@
+include ../config.mk
+
+clang_flags=-emit-llvm -S -Xclang -disable-O0-optnone 
+opt_flags=-sroa -S
+
+obj := $(patsubst %.c,%.merged.ll,$(wildcard *.c))
+inputs := $(wildcard input*.txt)
+all : ${obj}
+	
+%.merged.ll : %.c	
+	${clang} ${clang_flags} $^
+	${opt} ${opt_flags} < $(patsubst %.c,%.ll,$^) > $(patsubst %.c,%.optimized.ll,$^)
+	${opt} ${cfmerger_flags} < $(patsubst %.c,%.optimized.ll,$^) > $@
+
+
+test : is_same test1 test2 test3 
+
+is_same : ${obj}
+	@cmp -s  $(patsubst %.merged.ll,%.optimized.ll,$^) $^ ; \
+	RETVAL=$$?; \
+	if [ $$RETVAL -eq 0 ]; then \
+					echo "ERROR : transformation did NOT change source IR"; \
+	else \
+					echo "SUCCESS : transformation did change source IR"; \
+	fi
+
+
+test1  : input1.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test2 : input2.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test3 : input3.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test4 : input4.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+test5 : input5.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+
+
+clean :
+	rm  -f *.ll output*.*
+
diff --git a/cfm_tests/cfg/nested_if_asym/input1.txt b/cfm_tests/cfg/nested_if_asym/input1.txt
new file mode 100644
index 000000000000..b61b7c26ca70
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_asym/input1.txt
@@ -0,0 +1 @@
+1 2 3 4 5 6
diff --git a/cfm_tests/cfg/nested_if_asym/input2.txt b/cfm_tests/cfg/nested_if_asym/input2.txt
new file mode 100644
index 000000000000..4d93971ccbb9
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_asym/input2.txt
@@ -0,0 +1 @@
+-1 2 3 4 1 6
diff --git a/cfm_tests/cfg/nested_if_asym/input3.txt b/cfm_tests/cfg/nested_if_asym/input3.txt
new file mode 100644
index 000000000000..e1a00b965af6
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_asym/input3.txt
@@ -0,0 +1 @@
+-1 2 3 4 0 6
diff --git a/cfm_tests/cfg/nested_if_asym/nested_if_asym.c b/cfm_tests/cfg/nested_if_asym/nested_if_asym.c
new file mode 100644
index 000000000000..88f3647000d4
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_asym/nested_if_asym.c
@@ -0,0 +1,41 @@
+#include <stdio.h>
+void foo(int *a1, int *a2, int *a3, int *a4, int *a5, int *a6) {
+  int a = *a1;
+  int b = *a2;
+  int c = *a3;
+  int d = *a4;
+  int e = *a5;
+  int f = *a6;
+
+  if (a > 0) {
+    a++;
+    b--;
+    c *= 10;
+  } else {
+    if (e == 1)
+      e *= 10;
+    e++;
+    f--;
+    c *= 10;
+  }
+  printf("a=%d\n"
+         "b=%d\n"
+         "c=%d\n"
+         "d=%d\n"
+         "e=%d\n"
+         "f=%d\n",
+         a, b, c, d, e, f);
+
+}
+
+int main() {
+  int a, b, c, d, e, f;
+  scanf("%d", &a);
+  scanf("%d", &b);
+  scanf("%d", &c);
+  scanf("%d", &d);
+  scanf("%d", &e);
+  scanf("%d", &f);
+
+  foo(&a, &b, &c, &d, &e, &f);
+}
diff --git a/cfm_tests/cfg/nested_if_while/Makefile b/cfm_tests/cfg/nested_if_while/Makefile
new file mode 100644
index 000000000000..e475ca9b92be
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while/Makefile
@@ -0,0 +1,77 @@
+include ../config.mk
+
+clang_flags=-emit-llvm -S -Xclang -disable-O0-optnone 
+opt_flags=-gvn -S 
+
+obj := $(patsubst %.c,%.merged.ll,$(wildcard *.c))
+inputs := $(wildcard input*.txt)
+all : ${obj}
+	
+%.merged.ll : %.c	
+	${clang} ${clang_flags} $^
+	${opt} ${opt_flags} < $(patsubst %.c,%.ll,$^) > $(patsubst %.c,%.optimized.ll,$^)
+	${opt}  ${cfmerger_flags} < $(patsubst %.c,%.optimized.ll,$^) > $@
+
+
+test : is_same test1 test2 test3 test4
+
+is_same : ${obj}
+	@cmp -s  $(patsubst %.merged.ll,%.optimized.ll,$^) $^ ; \
+	RETVAL=$$?; \
+	if [ $$RETVAL -eq 0 ]; then \
+					echo "ERROR : transformation did NOT change source IR"; \
+	else \
+					echo "SUCCESS : transformation did change source IR"; \
+	fi
+
+
+test1  : input1.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test2 : input2.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test3 : input3.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test4 : input4.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+
+
+
+
+
+clean :
+	rm  -f *.ll output*.* .*.dot
+
+
diff --git a/cfm_tests/cfg/nested_if_while/cfg12/Makefile b/cfm_tests/cfg/nested_if_while/cfg12/Makefile
new file mode 100644
index 000000000000..97e49b18bc73
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while/cfg12/Makefile
@@ -0,0 +1,122 @@
+include ../config.mk
+clang_flags=-emit-llvm -S -Xclang -disable-O0-optnone 
+opt_flags=-sroa -S
+
+obj := $(patsubst %.c,%.merged.ll,$(wildcard *.c))
+inputs := $(wildcard input*.txt)
+all : ${obj}
+	
+%.merged.ll : %.c	
+	${clang} ${clang_flags} $^
+	${opt} ${opt_flags} < $(patsubst %.c,%.ll,$^) > $(patsubst %.c,%.optimized.ll,$^)
+	${opt}  ${cfmerger_flags} < $(patsubst %.c,%.optimized.ll,$^) > $@
+
+
+test : test1 test2 test3 test4 test5 test6 
+
+test1  : input1.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test2 : input2.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test3 : input3.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test4 : input4.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test5 : input5.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test6 : input6.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test7 : input7.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test8 : input8.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test9 : input9.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+test10 : input10.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+
+clean :
+	rm  -f *.ll output*.*
+
diff --git a/cfm_tests/cfg/nested_if_while/cfg12/input1.txt b/cfm_tests/cfg/nested_if_while/cfg12/input1.txt
new file mode 100644
index 000000000000..b61b7c26ca70
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while/cfg12/input1.txt
@@ -0,0 +1 @@
+1 2 3 4 5 6
diff --git a/cfm_tests/cfg/nested_if_while/cfg12/input2.txt b/cfm_tests/cfg/nested_if_while/cfg12/input2.txt
new file mode 100644
index 000000000000..e218a15b7fa8
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while/cfg12/input2.txt
@@ -0,0 +1 @@
+-1 2 3 4 5 6
diff --git a/cfm_tests/cfg/nested_if_while/cfg12/input3.txt b/cfm_tests/cfg/nested_if_while/cfg12/input3.txt
new file mode 100644
index 000000000000..8e3982ca415b
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while/cfg12/input3.txt
@@ -0,0 +1 @@
+1 -2 3 4 5 6
diff --git a/cfm_tests/cfg/nested_if_while/cfg12/input4.txt b/cfm_tests/cfg/nested_if_while/cfg12/input4.txt
new file mode 100644
index 000000000000..4f39ab72805d
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while/cfg12/input4.txt
@@ -0,0 +1 @@
+-1 2 3 -1 5 6
diff --git a/cfm_tests/cfg/nested_if_while/cfg12/input5.txt b/cfm_tests/cfg/nested_if_while/cfg12/input5.txt
new file mode 100644
index 000000000000..6bbc4665c677
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while/cfg12/input5.txt
@@ -0,0 +1 @@
+-1 2 3 -1 -5 6
diff --git a/cfm_tests/cfg/nested_if_while/cfg12/input6.txt b/cfm_tests/cfg/nested_if_while/cfg12/input6.txt
new file mode 100644
index 000000000000..9132bc5dce5d
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while/cfg12/input6.txt
@@ -0,0 +1 @@
+-1 2 3 1 -5 6
diff --git a/cfm_tests/cfg/nested_if_while/cfg12/nested_if_while.c b/cfm_tests/cfg/nested_if_while/cfg12/nested_if_while.c
new file mode 100644
index 000000000000..cb72c7c52aba
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while/cfg12/nested_if_while.c
@@ -0,0 +1,56 @@
+#include <stdio.h>
+void foo(int *a1, int *a2, int *a3, int *a4, int *a5, int *a6) {
+  int a = *a1;
+  int b = *a2;
+  int c = *a3;
+  int d = *a4;
+  int e = *a5;
+  int f = *a6;
+
+  if (a > 0) {
+    while (b > 0) {
+      /*if (c > 0)*/
+        c++;
+        b--;
+    }
+    a++;
+    /*if (c < 0) {*/
+      b++;
+      /*if (d > 0)*/
+        /*d++;*/
+    /*}*/
+  } else {
+
+    if (d > 0) {
+      c++;
+      /*if (b < 0)*/
+        /*b++;*/
+    }
+    while (e > 0) {
+      /*if (a > 0) {*/
+        a++;
+        e--;
+      /*}*/
+    }
+    f++;
+  }
+  printf("a=%d\n"
+         "b=%d\n"
+         "c=%d\n"
+         "d=%d\n"
+         "e=%d\n"
+         "f=%d\n",
+         a, b, c, d, e, f);
+}
+
+int main() {
+  int a, b, c, d, e, f;
+  scanf("%d", &a);
+  scanf("%d", &b);
+  scanf("%d", &c);
+  scanf("%d", &d);
+  scanf("%d", &e);
+  scanf("%d", &f);
+
+  foo(&a, &b, &c, &d, &e, &f);
+}
diff --git a/cfm_tests/cfg/nested_if_while/input1.txt b/cfm_tests/cfg/nested_if_while/input1.txt
new file mode 100644
index 000000000000..05d4b74b3617
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while/input1.txt
@@ -0,0 +1 @@
+2 0 0 0 10 0
diff --git a/cfm_tests/cfg/nested_if_while/input2.txt b/cfm_tests/cfg/nested_if_while/input2.txt
new file mode 100644
index 000000000000..900b9c900686
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while/input2.txt
@@ -0,0 +1 @@
+2 0 0 2 10 0
diff --git a/cfm_tests/cfg/nested_if_while/input3.txt b/cfm_tests/cfg/nested_if_while/input3.txt
new file mode 100644
index 000000000000..21499f356de5
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while/input3.txt
@@ -0,0 +1 @@
+2 0 1 2 10 0
diff --git a/cfm_tests/cfg/nested_if_while/input4.txt b/cfm_tests/cfg/nested_if_while/input4.txt
new file mode 100644
index 000000000000..3b6c2eaf7766
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while/input4.txt
@@ -0,0 +1 @@
+4 -2 0 0  9 0
diff --git a/cfm_tests/cfg/nested_if_while/nested_if_while.c b/cfm_tests/cfg/nested_if_while/nested_if_while.c
new file mode 100644
index 000000000000..cb9136deedf3
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while/nested_if_while.c
@@ -0,0 +1,51 @@
+#include <stdio.h>
+void foo(int *a1, int *a2, int *a3, int *a4, int *a5, int *a6) {
+  int a = *a1;
+  int b = *a2;
+  int c = *a3;
+  int d = *a4;
+  int e = *a5;
+  int f = *a6;
+
+  if (e != 10) {
+    if (c == 0) {
+      while (a > 0) {
+        if (b < 0)
+          b++;
+        a--;
+        /*if(e != 10)*/
+        /*b--;*/
+      }
+    }
+  } else {
+    if (f == 0) {
+      while (d > 0) {
+        if (c == 0)
+          e++;
+        d--;
+        /*if(e != 10)*/
+        /*b--;*/
+      }
+    }
+  }
+
+  printf("a=%d\n"
+         "b=%d\n"
+         "c=%d\n"
+         "d=%d\n"
+         "e=%d\n"
+         "f=%d\n",
+         a, b, c, d, e, f);
+}
+
+int main() {
+  int a, b, c, d, e, f;
+  scanf("%d", &a);
+  scanf("%d", &b);
+  scanf("%d", &c);
+  scanf("%d", &d);
+  scanf("%d", &e);
+  scanf("%d", &f);
+
+  foo(&a, &b, &c, &d, &e, &f);
+}
diff --git a/cfm_tests/cfg/nested_if_while2/Makefile b/cfm_tests/cfg/nested_if_while2/Makefile
new file mode 100644
index 000000000000..d0d98fce9e06
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while2/Makefile
@@ -0,0 +1,84 @@
+include ../config.mk
+
+clang_flags=-emit-llvm -S -Xclang -disable-O0-optnone 
+opt_flags=-sroa -S
+
+obj := $(patsubst %.c,%.merged.ll,$(wildcard *.c))
+inputs := $(wildcard input*.txt)
+all : ${obj}
+	
+%.merged.ll : %.c	
+	${clang} ${clang_flags} $^
+	${opt} ${opt_flags} < $(patsubst %.c,%.ll,$^) > $(patsubst %.c,%.optimized.ll,$^)
+	${opt}  ${cfmerger_flags} < $(patsubst %.c,%.optimized.ll,$^) > $@
+
+
+test : is_same test1 test2 test3 test4 test5
+
+is_same : ${obj}
+	@cmp -s  $(patsubst %.merged.ll,%.optimized.ll,$^) $^ ; \
+	RETVAL=$$?; \
+	if [ $$RETVAL -eq 0 ]; then \
+					echo "ERROR : transformation did NOT change source IR"; \
+	else \
+					echo "SUCCESS : transformation did change source IR"; \
+	fi
+
+
+test1  : input1.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test2 : input2.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test3 : input3.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test4 : input4.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+test5 : input5.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+
+
+clean :
+	rm  -f *.ll output*.*
+
diff --git a/cfm_tests/cfg/nested_if_while2/input1.txt b/cfm_tests/cfg/nested_if_while2/input1.txt
new file mode 100644
index 000000000000..ac3342971ebd
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while2/input1.txt
@@ -0,0 +1 @@
+1 2 0 4 5 6
diff --git a/cfm_tests/cfg/nested_if_while2/input2.txt b/cfm_tests/cfg/nested_if_while2/input2.txt
new file mode 100644
index 000000000000..0dbe409de68a
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while2/input2.txt
@@ -0,0 +1 @@
+1 -2 0 4 5 6
diff --git a/cfm_tests/cfg/nested_if_while2/input3.txt b/cfm_tests/cfg/nested_if_while2/input3.txt
new file mode 100644
index 000000000000..471986dbe421
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while2/input3.txt
@@ -0,0 +1 @@
+10 -2 0 4 5 6
diff --git a/cfm_tests/cfg/nested_if_while2/input4.txt b/cfm_tests/cfg/nested_if_while2/input4.txt
new file mode 100644
index 000000000000..1da8c2b5edba
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while2/input4.txt
@@ -0,0 +1 @@
+1 2 1 3 5 6
diff --git a/cfm_tests/cfg/nested_if_while2/input5.txt b/cfm_tests/cfg/nested_if_while2/input5.txt
new file mode 100644
index 000000000000..72982154cae9
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while2/input5.txt
@@ -0,0 +1 @@
+1 2 1 3 -3 6
diff --git a/cfm_tests/cfg/nested_if_while2/nested_if_while2.c b/cfm_tests/cfg/nested_if_while2/nested_if_while2.c
new file mode 100644
index 000000000000..8e4f36f4ba04
--- /dev/null
+++ b/cfm_tests/cfg/nested_if_while2/nested_if_while2.c
@@ -0,0 +1,43 @@
+#include <stdio.h>
+void foo(int *a1, int *a2, int *a3, int *a4, int *a5, int *a6) {
+  int a = *a1;
+  int b = *a2;
+  int c = *a3;
+  int d = *a4;
+  int e = *a5;
+  int f = *a6;
+
+  if (c == 0) {
+    while (a > 0) {
+      if (b < 0)
+        b++;
+      a--;
+    }
+  } else {
+    while (d > 0) {
+      if (e < 0)
+        f++;
+      d--;
+    }
+  }
+
+  printf("a=%d\n"
+         "b=%d\n"
+         "c=%d\n"
+         "d=%d\n"
+         "e=%d\n"
+         "f=%d\n",
+         a, b, c, d, e, f);
+}
+
+int main() {
+  int a, b, c, d, e, f;
+  scanf("%d", &a);
+  scanf("%d", &b);
+  scanf("%d", &c);
+  scanf("%d", &d);
+  scanf("%d", &e);
+  scanf("%d", &f);
+
+  foo(&a, &b, &c, &d, &e, &f);
+}
diff --git a/cfm_tests/cfg/path_between_blocks/Makefile b/cfm_tests/cfg/path_between_blocks/Makefile
new file mode 100644
index 000000000000..d7928b876588
--- /dev/null
+++ b/cfm_tests/cfg/path_between_blocks/Makefile
@@ -0,0 +1,34 @@
+include ../config.mk
+
+clang_flags=-emit-llvm -S -Xclang -disable-O0-optnone 
+opt_flags=-sroa -S
+
+obj := $(patsubst %.c,%.merged.ll,$(wildcard *.c))
+inputs := $(wildcard input*.txt)
+all : ${obj}
+	
+%.merged.ll : %.c	
+	${clang} ${clang_flags} $^
+	${opt} ${opt_flags} < $(patsubst %.c,%.ll,$^) > $(patsubst %.c,%.optimized.ll,$^)
+	${opt}  ${cfmerger_flags} < $(patsubst %.c,%.optimized.ll,$^) > $@
+
+
+test : is_same 
+
+is_same : ${obj}
+	@cmp -s  $(patsubst %.merged.ll,%.optimized.ll,$^) $^ ; \
+	RETVAL=$$?; \
+	if [ $$RETVAL -eq 0 ]; then \
+					echo "ERROR : transformation did NOT change source IR"; \
+	else \
+					echo "SUCCESS : transformation did change source IR"; \
+	fi
+
+
+
+
+
+
+clean :
+	rm  -f *.ll output*.* .*.dot
+
diff --git a/cfm_tests/cfg/path_between_blocks/path_betweek_blocks.c b/cfm_tests/cfg/path_between_blocks/path_betweek_blocks.c
new file mode 100644
index 000000000000..9419dfbac4de
--- /dev/null
+++ b/cfm_tests/cfg/path_between_blocks/path_betweek_blocks.c
@@ -0,0 +1,54 @@
+#include <stdio.h>
+void foo(int *a1, int *a2, int *a3, int *a4, int *a5, int *a6) {
+  int a = *a1;
+  int b = *a2;
+  int c = *a3;
+  int d = *a4;
+  int e = *a5;
+  int f = *a6;
+
+  if (a > 0) {
+    if (b > -1) {
+      a++;
+      c -= 3;
+    } else {
+      e++;
+      f -= 3;
+    }
+    if (c > 10) {
+      e++;
+      d -= 3;
+    } else {
+      if (f == 0) {
+        b++;
+        c -= 3;
+      } else {
+      L1:
+        c++;
+        a -= 3;
+      }
+    }
+  } else {
+    goto L1;
+  }
+
+  printf("a=%d\n"
+         "b=%d\n"
+         "c=%d\n"
+         "d=%d\n"
+         "e=%d\n"
+         "f=%d\n",
+         a, b, c, d, e, f);
+}
+
+int main() {
+  int a, b, c, d, e, f;
+  scanf("%d", &a);
+  scanf("%d", &b);
+  scanf("%d", &c);
+  scanf("%d", &d);
+  scanf("%d", &e);
+  scanf("%d", &f);
+
+  foo(&a, &b, &c, &d, &e, &f);
+}
diff --git a/cfm_tests/cfg/simple_if_else/Makefile b/cfm_tests/cfg/simple_if_else/Makefile
new file mode 100644
index 000000000000..b51e9d1bd064
--- /dev/null
+++ b/cfm_tests/cfg/simple_if_else/Makefile
@@ -0,0 +1,51 @@
+include ../config.mk
+clang_flags=-emit-llvm -S -Xclang -disable-O0-optnone 
+opt_flags=-sroa -S
+
+obj := $(patsubst %.c,%.merged.ll,$(wildcard *.c))
+inputs := $(wildcard input*.txt)
+all : ${obj}
+	
+%.merged.ll : %.c	
+	${clang} ${clang_flags} $^
+	${opt} ${opt_flags} < $(patsubst %.c,%.ll,$^) > $(patsubst %.c,%.optimized.ll,$^)
+	${opt} ${cfmerger_flags} < $(patsubst %.c,%.optimized.ll,$^) > $@
+
+
+test : is_same test1 test2
+
+is_same : ${obj}
+	@cmp -s  $(patsubst %.merged.ll,%.optimized.ll,$^) $^ ; \
+	RETVAL=$$?; \
+	if [ $$RETVAL -eq 0 ]; then \
+					echo "ERROR : transformation did NOT change source IR"; \
+	else \
+					echo "SUCCESS : transformation did change source IR"; \
+	fi
+
+
+test1  : input1.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test2 : input2.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+
+clean :
+	rm  -f *.ll output*.*
+
diff --git a/cfm_tests/cfg/simple_if_else/input1.txt b/cfm_tests/cfg/simple_if_else/input1.txt
new file mode 100644
index 000000000000..c8b0cf9293b6
--- /dev/null
+++ b/cfm_tests/cfg/simple_if_else/input1.txt
@@ -0,0 +1 @@
+0 2 3 4 5 6
diff --git a/cfm_tests/cfg/simple_if_else/input2.txt b/cfm_tests/cfg/simple_if_else/input2.txt
new file mode 100644
index 000000000000..b61b7c26ca70
--- /dev/null
+++ b/cfm_tests/cfg/simple_if_else/input2.txt
@@ -0,0 +1 @@
+1 2 3 4 5 6
diff --git a/cfm_tests/cfg/simple_if_else/simple_if_else.c b/cfm_tests/cfg/simple_if_else/simple_if_else.c
new file mode 100644
index 000000000000..6c763817eb6a
--- /dev/null
+++ b/cfm_tests/cfg/simple_if_else/simple_if_else.c
@@ -0,0 +1,39 @@
+#include <stdio.h>
+void foo(int *a1, int *a2, int *a3, int *a4, int *a5, int *a6) {
+  int a = *a1;
+  int b = *a2;
+  int c = *a3;
+  int d = *a4;
+  int e = *a5;
+  int f = *a6;
+
+  if (a > 0) {
+    a++;
+    b--;
+    c--;
+    d*=3;
+  } else {
+    f++;
+    e*=4;
+  }
+
+  printf("a=%d\n"
+         "b=%d\n"
+         "c=%d\n"
+         "d=%d\n"
+         "e=%d\n"
+         "f=%d\n",
+         a, b, c, d, e, f);
+}
+
+int main() {
+  int a, b, c, d, e, f;
+  scanf("%d", &a);
+  scanf("%d", &b);
+  scanf("%d", &c);
+  scanf("%d", &d);
+  scanf("%d", &e);
+  scanf("%d", &f);
+
+  foo(&a, &b, &c, &d, &e, &f);
+}
diff --git a/cfm_tests/cfg/simple_if_else2/Makefile b/cfm_tests/cfg/simple_if_else2/Makefile
new file mode 100644
index 000000000000..ed11de3b7618
--- /dev/null
+++ b/cfm_tests/cfg/simple_if_else2/Makefile
@@ -0,0 +1,52 @@
+include ../config.mk
+
+clang_flags=-emit-llvm -S -Xclang -disable-O0-optnone 
+opt_flags=-sroa -S
+
+obj := $(patsubst %.c,%.merged.ll,$(wildcard *.c))
+inputs := $(wildcard input*.txt)
+all : ${obj}
+	
+%.merged.ll : %.c	
+	${clang} ${clang_flags} $^
+	${opt} ${opt_flags} < $(patsubst %.c,%.ll,$^) > $(patsubst %.c,%.optimized.ll,$^)
+	${opt}  ${cfmerger_flags} -no-simplifycfg-after-melding < $(patsubst %.c,%.optimized.ll,$^) > $@
+
+
+test : is_same test1 test2
+
+is_same : ${obj}
+	@cmp -s  $(patsubst %.merged.ll,%.optimized.ll,$^) $^ ; \
+	RETVAL=$$?; \
+	if [ $$RETVAL -eq 0 ]; then \
+					echo "ERROR : transformation did NOT change source IR"; \
+	else \
+					echo "SUCCESS : transformation did change source IR"; \
+	fi
+
+
+test1  : input1.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		echo "FAIL" ; \
+	fi \
+
+test2 : input2.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		echo "FAIL" ; \
+	fi \
+
+
+
+clean :
+	rm  -f *.ll output*.*
+
diff --git a/cfm_tests/cfg/simple_if_else2/input1.txt b/cfm_tests/cfg/simple_if_else2/input1.txt
new file mode 100644
index 000000000000..d00491fd7e5b
--- /dev/null
+++ b/cfm_tests/cfg/simple_if_else2/input1.txt
@@ -0,0 +1 @@
+1
diff --git a/cfm_tests/cfg/simple_if_else2/input2.txt b/cfm_tests/cfg/simple_if_else2/input2.txt
new file mode 100644
index 000000000000..3a2e3f4984a0
--- /dev/null
+++ b/cfm_tests/cfg/simple_if_else2/input2.txt
@@ -0,0 +1 @@
+-1
diff --git a/cfm_tests/cfg/simple_if_else2/simple_if_else2.c b/cfm_tests/cfg/simple_if_else2/simple_if_else2.c
new file mode 100644
index 000000000000..cf8ca87ee02a
--- /dev/null
+++ b/cfm_tests/cfg/simple_if_else2/simple_if_else2.c
@@ -0,0 +1,24 @@
+#include <stdio.h>
+#include <stdlib.h>
+void foo(int *a, int *n) {
+  int v = 0;
+  if (*n > 0) {
+    a[0]++;
+    a[9]--;
+  } else {
+    a[0]--;
+  }
+  for (int i = 0; i < 10; i++)
+    printf("%d\n", a[i]);
+}
+
+int main() {
+  int *a = (int *)malloc(sizeof(int) * 10);
+  int n;
+  for (int i = 0; i < 10; i++)
+    a[i] = i;
+
+  scanf("%d", &n);
+  foo(a, &n);
+  free(a);
+}
diff --git a/cfm_tests/cfg/unify_phi/Makefile b/cfm_tests/cfg/unify_phi/Makefile
new file mode 100644
index 000000000000..d90b53569195
--- /dev/null
+++ b/cfm_tests/cfg/unify_phi/Makefile
@@ -0,0 +1,111 @@
+include ../config.mk
+
+clang_flags=-emit-llvm -S -Xclang -disable-O0-optnone 
+opt_flags=-sroa -S
+
+obj := $(patsubst %.c,%.merged.ll,$(wildcard *.c))
+inputs := $(wildcard input*.txt)
+all : ${obj}
+	
+%.merged.ll : %.c	
+	${clang} ${clang_flags} $^
+	${opt} ${opt_flags} < $(patsubst %.c,%.ll,$^) > $(patsubst %.c,%.optimized.ll,$^)
+	${opt}  ${cfmerger_flags} < $(patsubst %.c,%.optimized.ll,$^) > $@
+
+
+test : is_same test1 test2 test3 test4 test5 test6 test7
+
+is_same : ${obj}
+	@cmp -s  $(patsubst %.merged.ll,%.optimized.ll,$^) $^ ; \
+	RETVAL=$$?; \
+	if [ $$RETVAL -eq 0 ]; then \
+					echo "ERROR : transformation did NOT change source IR"; \
+	else \
+					echo "SUCCESS : transformation did change source IR"; \
+	fi
+
+
+
+test1  : input1.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test2 : input2.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test3 : input3.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test4 : input4.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test5 : input5.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+test6 : input6.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+test7 : input7.txt
+	@${lli} $(obj) < $^ > output.merged.txt
+	@${lli} $(patsubst %.merged.ll, %.optimized.ll, $(obj)) < $^ > output.txt
+	@diff output.merged.txt output.txt
+	@if [ $$? -eq 0 ]; then \
+		echo "PASS" ; \
+	else \
+		@echo "FAIL" ; \
+	fi \
+
+
+
+
+
+
+
+
+
+
+clean :
+	rm  -f *.ll output*.* .*.dot
+
diff --git a/cfm_tests/cfg/unify_phi/cfg16.c b/cfm_tests/cfg/unify_phi/cfg16.c
new file mode 100644
index 000000000000..2e49e8ff9484
--- /dev/null
+++ b/cfm_tests/cfg/unify_phi/cfg16.c
@@ -0,0 +1,52 @@
+#include <stdio.h>
+void foo(int *a1, int *a2, int *a3, int *a4, int *a5, int *a6) {
+  int a = *a1;
+  int b = *a2;
+  int c = *a3;
+  int d = *a4;
+  int e = *a5;
+  int f = *a6;
+
+  if (a > 0) {
+    a++;
+    if (b > 0) {
+      b++;
+      if (c > 0)
+        c++;
+    }
+    if (c < 0) {
+      if (d > 0)
+        d++;
+    }
+  } else {
+
+    f++;
+    if (e == 0)
+        e *= 10;
+    if (d > 0) {
+      c++;
+      if (b < 0)
+        b++;
+    }
+    e = d + f;
+  }
+  printf("a=%d\n"
+         "b=%d\n"
+         "c=%d\n"
+         "d=%d\n"
+         "e=%d\n"
+         "f=%d\n",
+         a, b, c, d, e, f);
+}
+
+int main() {
+  int a, b, c, d, e, f;
+  scanf("%d", &a);
+  scanf("%d", &b);
+  scanf("%d", &c);
+  scanf("%d", &d);
+  scanf("%d", &e);
+  scanf("%d", &f);
+
+  foo(&a, &b, &c, &d, &e, &f);
+}
diff --git a/cfm_tests/cfg/unify_phi/input1.txt b/cfm_tests/cfg/unify_phi/input1.txt
new file mode 100644
index 000000000000..6ff2b89b459d
--- /dev/null
+++ b/cfm_tests/cfg/unify_phi/input1.txt
@@ -0,0 +1 @@
+1 2 3 4 5 6 
diff --git a/cfm_tests/cfg/unify_phi/input2.txt b/cfm_tests/cfg/unify_phi/input2.txt
new file mode 100644
index 000000000000..ac3342971ebd
--- /dev/null
+++ b/cfm_tests/cfg/unify_phi/input2.txt
@@ -0,0 +1 @@
+1 2 0 4 5 6
diff --git a/cfm_tests/cfg/unify_phi/input3.txt b/cfm_tests/cfg/unify_phi/input3.txt
new file mode 100644
index 000000000000..4c1119d22373
--- /dev/null
+++ b/cfm_tests/cfg/unify_phi/input3.txt
@@ -0,0 +1 @@
+1 2 -1 4 5 6
diff --git a/cfm_tests/cfg/unify_phi/input4.txt b/cfm_tests/cfg/unify_phi/input4.txt
new file mode 100644
index 000000000000..61dbe6776b93
--- /dev/null
+++ b/cfm_tests/cfg/unify_phi/input4.txt
@@ -0,0 +1 @@
+1 2 -1 0 5 6
diff --git a/cfm_tests/cfg/unify_phi/input5.txt b/cfm_tests/cfg/unify_phi/input5.txt
new file mode 100644
index 000000000000..6523b60b1d9c
--- /dev/null
+++ b/cfm_tests/cfg/unify_phi/input5.txt
@@ -0,0 +1 @@
+0 1 0 1 0 0
diff --git a/cfm_tests/cfg/unify_phi/input6.txt b/cfm_tests/cfg/unify_phi/input6.txt
new file mode 100644
index 000000000000..bcf510e18f6c
--- /dev/null
+++ b/cfm_tests/cfg/unify_phi/input6.txt
@@ -0,0 +1 @@
+0 1 0 1 1 0
diff --git a/cfm_tests/cfg/unify_phi/input7.txt b/cfm_tests/cfg/unify_phi/input7.txt
new file mode 100644
index 000000000000..ac7567c941ce
--- /dev/null
+++ b/cfm_tests/cfg/unify_phi/input7.txt
@@ -0,0 +1 @@
+0 -1 0 1 1 0
diff --git a/llvm/include/llvm/InitializePasses.h b/llvm/include/llvm/InitializePasses.h
index 489ef045796f..df1d9e9ac387 100644
--- a/llvm/include/llvm/InitializePasses.h
+++ b/llvm/include/llvm/InitializePasses.h
@@ -60,6 +60,10 @@ void initializeGlobalISel(PassRegistry&);
 /// Initialize all passes linked into the CodeGen library.
 void initializeTarget(PassRegistry&);
 
+void initializeCFMelder(PassRegistry&);
+
+void initializeCFMelderCodeSize(PassRegistry&);
+
 void initializeAAEvalLegacyPassPass(PassRegistry&);
 void initializeAAResultsWrapperPassPass(PassRegistry&);
 void initializeADCELegacyPassPass(PassRegistry&);
@@ -463,6 +467,8 @@ void initializeWinEHPreparePass(PassRegistry&);
 void initializeWriteBitcodePassPass(PassRegistry&);
 void initializeWriteThinLTOBitcodePass(PassRegistry&);
 void initializeXRayInstrumentationPass(PassRegistry&);
+void initializeCFMelderCodeSizeLegacyPassPass(PassRegistry &Registry);
+void initializeCFMelderLegacyPassPass(PassRegistry &Registry);
 
 } // end namespace llvm
 
diff --git a/llvm/include/llvm/LinkAllPasses.h b/llvm/include/llvm/LinkAllPasses.h
index c8b9aaeed76a..35785449e91a 100644
--- a/llvm/include/llvm/LinkAllPasses.h
+++ b/llvm/include/llvm/LinkAllPasses.h
@@ -39,6 +39,7 @@
 #include "llvm/IR/IRPrintingPasses.h"
 #include "llvm/Support/Valgrind.h"
 #include "llvm/Transforms/AggressiveInstCombine/AggressiveInstCombine.h"
+#include "llvm/Transforms/CFMelder/CFMelder.h"
 #include "llvm/Transforms/IPO.h"
 #include "llvm/Transforms/IPO/AlwaysInliner.h"
 #include "llvm/Transforms/IPO/Attributor.h"
@@ -236,6 +237,7 @@ namespace {
       (void) llvm::createUnifyLoopExitsPass();
       (void) llvm::createFixIrreduciblePass();
       (void)llvm::createFunctionSpecializationPass();
+      (void) llvm::createCFMelderPass();
 
       (void)new llvm::IntervalPartition();
       (void)new llvm::ScalarEvolutionWrapperPass();
diff --git a/llvm/include/llvm/Transforms/CFMelder/CFMelder.h b/llvm/include/llvm/Transforms/CFMelder/CFMelder.h
new file mode 100644
index 000000000000..fb5a31efee41
--- /dev/null
+++ b/llvm/include/llvm/Transforms/CFMelder/CFMelder.h
@@ -0,0 +1,34 @@
+#ifndef LLVM_TRANSFORMS_CFMEGER_CFMERGER_H
+#define LLVM_TRANSFORMS_CFMEGER_CFMERGER_H
+
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/PostDominators.h"
+#include "llvm/Analysis/TargetTransformInfo.h"
+#include "llvm/IR/PassManager.h"
+
+namespace llvm {
+
+// Function pass for control-flow melding
+class CFMelderPass : public PassInfoMixin<CFMelderPass> {
+public:
+  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);
+};
+
+FunctionPass *createCFMelderPass();
+
+// Module pass to drive control-flow melding
+class CFMelderCodeSizePass : public PassInfoMixin<CFMelderCodeSizePass> {
+public:
+  PreservedAnalyses run(Module &M, ModuleAnalysisManager &MAM);
+};
+
+ModulePass *createCFMelderCodeSizePass();
+
+SmallVector<unsigned> runCFM(BasicBlock *BB, DominatorTree &DT,
+                             PostDominatorTree &PDT, TargetTransformInfo &TTI,
+                             SmallVector<unsigned> &OnIdxs);
+
+} // namespace llvm
+
+#endif
\ No newline at end of file
diff --git a/llvm/lib/Passes/CMakeLists.txt b/llvm/lib/Passes/CMakeLists.txt
index 703969f8b5f4..3454b482711e 100644
--- a/llvm/lib/Passes/CMakeLists.txt
+++ b/llvm/lib/Passes/CMakeLists.txt
@@ -27,4 +27,5 @@ add_llvm_component_library(LLVMPasses
   TransformUtils
   Vectorize
   Instrumentation
+  CFMelder
   )
diff --git a/llvm/lib/Passes/PassBuilder.cpp b/llvm/lib/Passes/PassBuilder.cpp
index dedfc81f11bb..1b0b6fd7d1ba 100644
--- a/llvm/lib/Passes/PassBuilder.cpp
+++ b/llvm/lib/Passes/PassBuilder.cpp
@@ -84,6 +84,7 @@
 #include "llvm/Support/Regex.h"
 #include "llvm/Target/TargetMachine.h"
 #include "llvm/Transforms/AggressiveInstCombine/AggressiveInstCombine.h"
+#include "llvm/Transforms/CFMelder/CFMelder.h"
 #include "llvm/Transforms/Coroutines/CoroCleanup.h"
 #include "llvm/Transforms/Coroutines/CoroEarly.h"
 #include "llvm/Transforms/Coroutines/CoroElide.h"
diff --git a/llvm/lib/Passes/PassBuilderPipelines.cpp b/llvm/lib/Passes/PassBuilderPipelines.cpp
index e838665eb9ce..766b8a0e3174 100644
--- a/llvm/lib/Passes/PassBuilderPipelines.cpp
+++ b/llvm/lib/Passes/PassBuilderPipelines.cpp
@@ -126,6 +126,7 @@
 #include "llvm/Transforms/Vectorize/LoopVectorize.h"
 #include "llvm/Transforms/Vectorize/SLPVectorizer.h"
 #include "llvm/Transforms/Vectorize/VectorCombine.h"
+#include "llvm/Transforms/CFMelder/CFMelder.h"
 
 using namespace llvm;
 
@@ -182,6 +183,12 @@ static cl::opt<bool> EnableMergeFunctions(
     "enable-merge-functions", cl::init(false), cl::Hidden,
     cl::desc("Enable function merging as part of the optimization pipeline"));
 
+/*
+static cl::opt<bool> EnableCFMelder(
+    "enable-cfmelder", cl::init(false), cl::Hidden,
+    cl::desc("enable cfmelder"));
+*/
+
 PipelineTuningOptions::PipelineTuningOptions() {
   LoopInterleaving = true;
   LoopVectorization = true;
@@ -421,6 +428,12 @@ PassBuilder::buildFunctionSimplificationPipeline(OptimizationLevel Level,
         SimplifyCFGPass(SimplifyCFGOptions().convertSwitchRangeToICmp(true)));
   }
 
+  /*
+  if (EnableCFMelder) {
+    FPM.addPass(CFMelderPass());
+  }
+  */
+
   if (EnableConstraintElimination)
     FPM.addPass(ConstraintEliminationPass());
 
diff --git a/llvm/lib/Passes/PassRegistry.def b/llvm/lib/Passes/PassRegistry.def
index 69d8d8c43267..887503e0814a 100644
--- a/llvm/lib/Passes/PassRegistry.def
+++ b/llvm/lib/Passes/PassRegistry.def
@@ -232,6 +232,7 @@ FUNCTION_ALIAS_ANALYSIS("tbaa", TypeBasedAA())
 #ifndef FUNCTION_PASS
 #define FUNCTION_PASS(NAME, CREATE_PASS)
 #endif
+FUNCTION_PASS("cfmelder", CFMelderPass())
 FUNCTION_PASS("aa-eval", AAEvaluator())
 FUNCTION_PASS("adce", ADCEPass())
 FUNCTION_PASS("add-discriminators", AddDiscriminatorsPass())
diff --git a/llvm/lib/Transforms/CFMelder/CFMelder.cpp b/llvm/lib/Transforms/CFMelder/CFMelder.cpp
new file mode 100644
index 000000000000..c62bd45bc495
--- /dev/null
+++ b/llvm/lib/Transforms/CFMelder/CFMelder.cpp
@@ -0,0 +1,563 @@
+//===- Hello.cpp - Example code from "Writing an LLVM Pass" ---------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements two versions of the LLVM "Hello World" pass described
+// in docs/WritingAnLLVMPass.html
+//
+//===----------------------------------------------------------------------===//
+#include "llvm/Transforms/CFMelder/CFMelder.h"
+#include "CFMelderUtils.h"
+#include "RegionMelder.h"
+#include "llvm/ADT/PostOrderIterator.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Analysis/AliasAnalysis.h"
+#include "llvm/Analysis/CGSCCPassManager.h"
+#include "llvm/Analysis/DivergenceAnalysis.h"
+#include "llvm/Analysis/DominanceFrontier.h"
+#include "llvm/Analysis/DominanceFrontierImpl.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/PostDominators.h"
+#include "llvm/Analysis/RegionInfo.h"
+#include "llvm/Analysis/RegionInfoImpl.h"
+#include "llvm/Analysis/TargetTransformInfo.h"
+#include "llvm/Frontend/OpenMP/OMP.h.inc"
+#include "llvm/IR/Dominators.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/LegacyPassManager.h"
+#include "llvm/InitializePasses.h"
+#include "llvm/Pass.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+#include "llvm/Transforms/Utils/Cloning.h"
+#include "llvm/Transforms/Utils/Local.h"
+#include <algorithm>
+#include <cmath>
+#include <set>
+#include <sstream>
+#include <string>
+
+using namespace llvm;
+
+#define DEBUG_TYPE "cfmelder"
+
+static cl::opt<bool>
+    ForceMerging("force-cf-merging", cl::init(false), cl::Hidden,
+                 cl::desc("Always perform merging regardless of target"));
+
+static cl::opt<bool>
+    RunCFMelderAnalysisOnly("cfmelder-analysis-only", cl::init(false),
+                            cl::Hidden,
+                            cl::desc("Run control-melding analysis only"));
+// static cl::opt<bool>
+//     DisableRecursiveMelding("disable-recursive-melding", cl::init(false),
+//     cl::Hidden,
+//                  cl::desc("Disable recurisve melding"));
+
+static cl::opt<std::string> RunCFMeldingOnlyOnFunction(
+    "run-cfmelding-on-function", cl::init(""), cl::Hidden,
+    cl::desc("Limit CFMelding for this function only"));
+
+static cl::opt<bool> NoSimplifyCFGAfterMelding(
+    "no-simplifycfg-after-melding", cl::init(false), cl::Hidden,
+    cl::desc("Do not simplify the CFG after control-flow melding"));
+
+static cl::opt<bool> RunMeldingOnce("run-cfmelding-once", cl::init(false),
+                                    cl::Hidden,
+                                    cl::desc("Perform one melding and exit"));
+
+static cl::opt<unsigned>
+    MaxIterations("cfmelding-max-iteration", cl::init(10), cl::Hidden,
+                  cl::desc("Maximum number of iterations performed by CFMelder "
+                           "on the whole function"));
+namespace {
+
+size_t EstimateFunctionSize(Function *F, TargetTransformInfo &TTI) {
+  float size = 0;
+  for (Instruction &I : instructions(F)) {
+    switch (I.getOpcode()) {
+    // case Instruction::Alloca:
+    case Instruction::PHI:
+      size += 0.2;
+      break;
+    // case Instruction::Select:
+    //  size += 1.2;
+    //  break;
+    default:
+      auto cost = TTI.getInstructionCost(&I, TargetTransformInfo::TargetCostKind::TCK_CodeSize);
+    size += cost.getValue().getValue();
+    }
+  }
+  return size_t(std::ceil(size));
+}
+
+class CFMelderLegacyPass : public FunctionPass {
+
+public:
+  static char ID;
+
+  CFMelderLegacyPass() : FunctionPass(ID) {
+    initializeCFMelderLegacyPassPass(*PassRegistry::getPassRegistry());
+  }
+
+  void getAnalysisUsage(AnalysisUsage &AU) const override;
+
+  bool runOnFunction(Function &F) override;
+};
+
+class CFMelderCodeSizeLegacyPass : public ModulePass {
+public:
+  static char ID;
+
+  CFMelderCodeSizeLegacyPass() : ModulePass(ID) {
+    initializeCFMelderCodeSizeLegacyPassPass(*PassRegistry::getPassRegistry());
+  }
+
+  void getAnalysisUsage(AnalysisUsage &AU) const override;
+
+  bool runOnModule(Module &M) override;
+};
+
+} // namespace
+
+static bool runAnalysisOnly(Function &F, DominatorTree &DT,
+                            PostDominatorTree &PDT, LoopInfo &LI,
+                            TargetTransformInfo &TTI) {
+
+  auto GPUDA = std::make_unique<DivergenceInfo>(F, DT, PDT, LI, TTI,
+                                                /* KnownReducible = */ false);
+
+  INFO << "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
+          "+++++++++++++++\n";
+  INFO << "Function name : " << F.getName() << "\n";
+  INFO << "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
+          "+++++++++++++++\n";
+
+  ControlFlowGraphInfo CFGInfo(F, DT, PDT, TTI);
+
+  for (auto BBIt : post_order(&F.getEntryBlock())) {
+    BasicBlock &BB = *BBIt;
+    // check if this BB is the enrty to a diamond shaped control-flow
+    Value *BranchI = dyn_cast<Value>(BB.getTerminator());
+    if (Utils::isValidMergeLocation(BB, DT, PDT) &&
+        (GPUDA->isDivergent(*BranchI) || RunCFMelderAnalysisOnly)) {
+
+      // DebugLoc DebugLocation = BB.begin()->getDebugLoc();
+      INFO << "------------------------------------------------------------"
+              "-------------------\n";
+      INFO << "Valid merge location found at BB ";
+      BB.printAsOperand(errs(), false);
+      errs() << "\n";
+      RegionAnalyzer MA(&BB, CFGInfo);
+      MA.computeRegionMatch();
+      MA.printAnalysis(INFO);
+      INFO << "This merge is : " << (MA.hasAnyProfitableMatch() ? "" : "NOT")
+           << " PROFITABLE!\n";
+    }
+  }
+
+  return false;
+}
+
+static bool simplifyFunction(Function &F, TargetTransformInfo &TTI,
+                             SimplifyCFGOptions &Options) {
+  bool Changed = false;
+  bool LocalChange = false;
+  do {
+    LocalChange = false;
+    for (auto &BB : make_range(F.begin(), F.end())) {
+      if (simplifyCFG(&BB, TTI, nullptr, Options)) {
+        LocalChange = true;
+        break;
+      }
+    }
+
+    Changed |= LocalChange;
+
+  } while (LocalChange);
+  return Changed;
+}
+
+/*
+static int computeCodeSize(Function *F, TargetTransformInfo &TTI) {
+  float CodeSize = 0;
+  for (Instruction &I : instructions(*F)) {
+    switch(I.getOpcode()) {
+    case Instruction::PHI:
+      CodeSize += 0.2;
+      break;
+    default:
+      CodeSize += TTI.getInstructionCost(
+                       &I, TargetTransformInfo::TargetCostKind::TCK_CodeSize)
+                    .getValue()
+                    .getValue();
+    }
+  }
+  return CodeSize;
+}
+*/
+
+SmallVector<unsigned> llvm::runCFM(BasicBlock *BB, DominatorTree &DT,
+                                   PostDominatorTree &PDT,
+                                   TargetTransformInfo &TTI,
+                                   SmallVector<unsigned> &OnIdxs) {
+  bool LocalChange = false, AnyChange = false;
+  SmallVector<unsigned> ProfitableIdxs;
+  if (Utils::isValidMergeLocation(*BB, DT, PDT)) {
+    Function *Func = BB->getParent();
+    ControlFlowGraphInfo CFGInfo(*Func, DT, PDT, TTI);
+    RegionAnalyzer RA(BB, CFGInfo);
+    RA.computeRegionMatch();
+
+    // if OnIdxs is non-empty apply melding to those indexes only
+    SmallVector<unsigned> IdxsToProcess;
+    if (!OnIdxs.empty()) {
+      for (unsigned I : OnIdxs)
+        IdxsToProcess.push_back(I);
+    } else {
+      for (unsigned I = 0; I < RA.regionMatchSize(); ++I)
+        IdxsToProcess.push_back(I);
+    }
+
+    if (RA.hasAnyProfitableMatch()) {
+
+      for (unsigned I : IdxsToProcess) {
+        if (!RA.isRegionMatchProfitable(I))
+          continue;
+
+        int SizeBefore = EstimateFunctionSize(Func, TTI);
+        RegionMelder RM(RA);
+        RM.merge(I);
+        int SizeAfter = EstimateFunctionSize(Func, TTI);
+
+        if (SizeBefore > SizeAfter) {
+          ProfitableIdxs.push_back(I);
+        }
+        LocalChange = true;
+      }
+
+      if (LocalChange) {
+        DT.recalculate(*Func);
+        PDT.recalculate(*Func);
+        AnyChange = true;
+        LocalChange = false;
+      }
+    }
+  }
+
+  // PP: What I really want is to return whether this call modified Func
+  // Could pass-by-ref a bool for that but I am lazy so I add garbage to
+  // ProfitableIdxs to make sure that it's always non-empty when Func was
+  // modified
+  if (AnyChange && ProfitableIdxs.size() == 0)
+    ProfitableIdxs.push_back(UINT_MAX);
+  return ProfitableIdxs;
+}
+
+static bool runImplCodeSize(Function &F, DominatorTree &DT,
+                            PostDominatorTree &PDT, LoopInfo &LI,
+                            TargetTransformInfo &TTI) {
+  INFO << "Procesing function : " << F.getName() << "\n";
+  Function *Func = &F;
+  bool LocalChange = false, Changed = false;
+
+  int OrigCodeSize = EstimateFunctionSize(&F, TTI);
+  unsigned CountIter = 0;
+
+  do {
+    CountIter++;
+
+    LocalChange = false;
+    for (BasicBlock *BB : post_order(&Func->getEntryBlock())) {
+      if (Utils::isValidMergeLocation(*BB, DT, PDT)) {
+        INFO << "Valid merge location found at block "
+             << BB->getNameOrAsOperand() << "\n";
+        ControlFlowGraphInfo CFGInfo(*Func, DT, PDT, TTI);
+        RegionAnalyzer RA(BB, CFGInfo);
+        RA.computeRegionMatch();
+
+        if (RA.hasAnyProfitableMatch()) {
+
+          // Store the indexes of profitable merges
+          SmallVector<int, 8> Profitable;
+
+          // clone function
+          ValueToValueMapTy VMap;
+          Function *ClonedFunc = CloneFunction(Func, VMap);
+          DominatorTree ClonedDT(*ClonedFunc);
+          PostDominatorTree ClonedPDT(*ClonedFunc);
+          ControlFlowGraphInfo ClonedCFGInfo(*ClonedFunc, ClonedDT, ClonedPDT,
+                                             TTI);
+
+          RegionAnalyzer ClonedRA(dyn_cast<BasicBlock>(VMap[BB]),
+                                  ClonedCFGInfo);
+          ClonedRA.computeRegionMatch();
+
+          for (unsigned I = 0; I < ClonedRA.regionMatchSize(); ++I) {
+            if (!ClonedRA.isRegionMatchProfitable(I))
+              continue;
+
+            int SizeBefore = EstimateFunctionSize(ClonedFunc, TTI);
+            RegionMelder ClonedRM(ClonedRA);
+            ClonedRM.merge(I);
+            int SizeAfter = EstimateFunctionSize(ClonedFunc, TTI);
+            DEBUG << "Size changed from " << SizeBefore << " to " << SizeAfter
+                  << " : " << (SizeBefore - SizeAfter) << " : "
+                  << ((SizeBefore > SizeAfter) ? "Profitable" : "Unprofitable")
+                  << " Branch Fusion! [" << F.getName().str() << "] ";
+            BB->getTerminator()->dump();
+            if (SizeBefore > SizeAfter) {
+              Profitable.push_back(I);
+            }
+          }
+
+          // If there are profitble merges perform them on Func
+          if (!Profitable.empty()) {
+            for (int I : Profitable) {
+              RegionMelder RM(RA);
+              RM.merge(I);
+            }
+            LocalChange = true;
+          }
+
+          // delete the cloned functon
+          ClonedFunc->eraseFromParent();
+
+          if (LocalChange) {
+            DT.recalculate(*Func);
+            PDT.recalculate(*Func);
+            break;
+          }
+        }
+      }
+    }
+
+    Changed |= LocalChange;
+
+    if (RunMeldingOnce)
+      break;
+  } while (LocalChange); // && CountIter < MaxIterations);
+
+  if (Changed) {
+    // simplifyFunction(
+    //             *Func, TTI,
+    //             SimplifyCFGOptionsObj.setSimplifyCondBranch(false));
+
+    int FinalCodeSize = EstimateFunctionSize(&F, TTI);
+    double PercentReduction =
+        (OrigCodeSize - FinalCodeSize) * 100 / (double)OrigCodeSize;
+    INFO << "Size reduction for function " << F.getName() << ": "
+         << OrigCodeSize << " to  " << FinalCodeSize << " (" << PercentReduction
+         << "%)"
+         << "\n";
+  }
+
+  return Changed;
+}
+
+static bool runImpl(Function &F, DominatorTree &DT, PostDominatorTree &PDT,
+                    LoopInfo &LI, TargetTransformInfo &TTI) {
+
+  // if the target does not has branch divergence, just exit
+  if (!TTI.hasBranchDivergence() && !ForceMerging)
+    return false;
+
+  // analysis only
+  if (RunCFMelderAnalysisOnly) {
+    return runAnalysisOnly(F, DT, PDT, LI, TTI);
+  }
+
+  INFO << "Function name : " << F.getName() << "\n";
+
+  if (RunCFMeldingOnlyOnFunction.size() > 0) {
+    std::stringstream RunOnlyFuncs(RunCFMeldingOnlyOnFunction);
+    std::set<string> FuncNames;
+
+    while (RunOnlyFuncs.good()) {
+      std::string Fs;
+      std::getline(RunOnlyFuncs, Fs, ';');
+      FuncNames.insert(Fs);
+    }
+
+    bool ContainsName = false;
+    for (auto FN : FuncNames) {
+      if (F.getName().contains(FN)) {
+        ContainsName = true;
+        break;
+      }
+    }
+    if (!ContainsName)
+      return false;
+  }
+
+  // simplifyCFG options
+  SimplifyCFGOptions SimplifyCFGOptionsObj;
+
+  bool Changed = false, LocalChange = false;
+  unsigned CountIter = 0;
+
+  do {
+    LocalChange = false;
+    CountIter++;
+
+    for (auto &BBIt : post_order(&F.getEntryBlock())) {
+      BasicBlock &BB = *BBIt;
+      // errs() << "BB name : " << BB.getNameOrAsOperand() << "\n";
+      // check if this BB is the enrty to a diamond shaped control-flow
+      if (Utils::isValidMergeLocation(BB, DT, PDT)) {
+        INFO << "Valid merge location found at BB ";
+        BB.printAsOperand(errs(), false);
+        errs() << "\n";
+
+        ControlFlowGraphInfo CFGInfo(F, DT, PDT, TTI);
+        RegionAnalyzer MA(&BB, CFGInfo);
+        MA.computeRegionMatch();
+        if (MA.hasAnyProfitableMatch()) {
+          INFO << "Melding is profitable\n";
+
+          for (unsigned I = 0; I < MA.regionMatchSize(); I++) {
+            // skip unprofitable melding
+            if (!MA.isRegionMatchProfitable(I))
+              continue;
+            RegionMelder RM(MA);
+            RM.merge(I);
+            LocalChange = true;
+            CFGInfo.recompute();
+          }
+          if (LocalChange) {
+            if (!NoSimplifyCFGAfterMelding) {
+              INFO << "Running CFG simplification\n";
+              if (simplifyFunction(
+                      F, TTI,
+                      SimplifyCFGOptionsObj.setSimplifyCondBranch(false)
+                          .sinkCommonInsts(false)
+                          .hoistCommonInsts(false))) {
+                DT.recalculate(F);
+                PDT.recalculate(F);
+              }
+            }
+            break;
+          }
+        }
+      }
+    }
+
+    Changed |= LocalChange;
+    // if one melding is requested, exit (debugging)
+    if (RunMeldingOnce) {
+      break;
+    }
+  } while (LocalChange); // && CountIter < MaxIterations);
+
+  return Changed;
+}
+
+bool CFMelderLegacyPass::runOnFunction(Function &F) {
+  auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();
+  auto &PDT = getAnalysis<PostDominatorTreeWrapperPass>().getPostDomTree();
+  auto &TTI = getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);
+  auto &LI = getAnalysis<LoopInfoWrapperPass>().getLoopInfo();
+  return runImpl(F, DT, PDT, LI, TTI);
+}
+
+void CFMelderLegacyPass::getAnalysisUsage(AnalysisUsage &AU) const {
+  AU.addRequired<PostDominatorTreeWrapperPass>();
+  AU.addRequired<DominatorTreeWrapperPass>();
+  AU.addRequired<TargetTransformInfoWrapperPass>();
+  AU.addRequired<LoopInfoWrapperPass>();
+}
+
+PreservedAnalyses CFMelderPass::run(Function &F, FunctionAnalysisManager &AM) {
+
+  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);
+  auto &PDT = AM.getResult<PostDominatorTreeAnalysis>(F);
+  auto &TTI = AM.getResult<TargetIRAnalysis>(F);
+  auto &LI = AM.getResult<LoopAnalysis>(F);
+
+  if (!runImpl(F, DT, PDT, LI, TTI)) {
+    // No changes, all analyses are preserved.
+    return PreservedAnalyses::all();
+  }
+
+  return PreservedAnalyses::none();
+}
+
+bool CFMelderCodeSizeLegacyPass::runOnModule(Module &M) {
+  errs() << "Hello\n";
+  return false;
+}
+
+void CFMelderCodeSizeLegacyPass::getAnalysisUsage(AnalysisUsage &AU) const {
+  AU.addRequired<PostDominatorTreeWrapperPass>();
+  AU.addRequired<DominatorTreeWrapperPass>();
+  AU.addRequired<TargetTransformInfoWrapperPass>();
+  AU.addRequired<LoopInfoWrapperPass>();
+}
+
+PreservedAnalyses CFMelderCodeSizePass::run(Module &M,
+                                            ModuleAnalysisManager &MAM) {
+  auto &FAM = MAM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();
+  bool Changed = false;
+  SmallVector<Function *, 64> Funcs;
+
+  for (auto &F : M) {
+    if (F.isDeclaration())
+      continue;
+    Funcs.push_back(&F);
+  }
+
+  for (Function *F : Funcs) {
+    auto &DT = FAM.getResult<DominatorTreeAnalysis>(*F);
+    auto &PDT = FAM.getResult<PostDominatorTreeAnalysis>(*F);
+    auto &TTI = FAM.getResult<TargetIRAnalysis>(*F);
+    auto &LI = FAM.getResult<LoopAnalysis>(*F);
+    Changed |= runImplCodeSize(*F, DT, PDT, LI, TTI);
+  }
+  if (!Changed)
+    return PreservedAnalyses::all();
+  PreservedAnalyses PA;
+  return PA;
+}
+
+char CFMelderLegacyPass::ID = 0;
+
+INITIALIZE_PASS_BEGIN(CFMelderLegacyPass, "cfmelder",
+                      "Meld similar control-flow", false, false)
+INITIALIZE_PASS_DEPENDENCY(PostDominatorTreeWrapperPass)
+INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)
+INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)
+INITIALIZE_PASS_END(CFMelderLegacyPass, "cfmelder", "Meld similar control-flow",
+                    false, false)
+
+char CFMelderCodeSizeLegacyPass::ID = 0;
+
+INITIALIZE_PASS_BEGIN(CFMelderCodeSizeLegacyPass, "cfmelder-codesize",
+                      "Meld similar control-flow for code size reduction",
+                      false, false)
+INITIALIZE_PASS_DEPENDENCY(PostDominatorTreeWrapperPass)
+INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)
+INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)
+INITIALIZE_PASS_END(CFMelderCodeSizeLegacyPass, "cfmelder-codesize",
+                    "Meld similar control-flow for code size reduction", false,
+                    false)
+
+// Initialization Routines
+void llvm::initializeCFMelder(PassRegistry &Registry) {
+  initializeCFMelderLegacyPassPass(Registry);
+}
+
+void llvm::initializeCFMelderCodeSize(PassRegistry &Registry) {
+  initializeCFMelderCodeSizeLegacyPassPass(Registry);
+}
+
+FunctionPass *llvm::createCFMelderPass() { return new CFMelderLegacyPass(); }
+
+ModulePass *llvm::createCFMelderCodeSizePass() {
+  return new CFMelderCodeSizeLegacyPass();
+}
diff --git a/llvm/lib/Transforms/CFMelder/CFMelderUtils.cpp b/llvm/lib/Transforms/CFMelder/CFMelderUtils.cpp
new file mode 100644
index 000000000000..097b81b5b015
--- /dev/null
+++ b/llvm/lib/Transforms/CFMelder/CFMelderUtils.cpp
@@ -0,0 +1,1053 @@
+#include "CFMelderUtils.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/Analysis/CFG.h"
+#include "llvm/Analysis/CFGPrinter.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/PostDominators.h"
+#include "llvm/IR/BasicBlock.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/IntrinsicInst.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/raw_ostream.h"
+#include <sstream>
+using namespace llvm;
+
+bool Utils::requireRegionSimplification(Region *R) {
+  BasicBlock *Exit = R->getExit();
+  for (auto PredIt = pred_begin(Exit); PredIt != pred_end(Exit); ++PredIt) {
+    BasicBlock *Pred = *PredIt;
+    if (!R->contains(Pred))
+      return true;
+  }
+  return false;
+}
+
+Region *Utils::getRegionWithEntryExit(RegionInfo &RI, BasicBlock *Entry,
+                                      BasicBlock *Exit) {
+
+  // errs() << "entry : " << Entry->getNameOrAsOperand() << "\n";
+  // errs() << "exit : " << Exit->getNameOrAsOperand() << "\n";
+  SmallVector<Region *, 32> WorkList;
+  WorkList.push_back(RI.getTopLevelRegion());
+  Region *RFound = nullptr;
+  while (!WorkList.empty()) {
+    Region *R = WorkList.pop_back_val();
+    // R->print(errs());
+    if (R->getEntry() == Entry && R->getExit() == Exit) {
+      // errs() << "found\n";
+      RFound = R;
+      break;
+    }
+
+    for (std::unique_ptr<Region> &SubR : *R) {
+      WorkList.push_back(SubR.get());
+    }
+  }
+  return RFound;
+}
+
+bool Utils::isValidMergeLocation(BasicBlock &BB, DominatorTree &DT,
+                                 PostDominatorTree &PDT) {
+
+  const BranchInst *BI = dyn_cast<BranchInst>(BB.getTerminator());
+
+  if (!BI)
+    return false;
+
+  if (BI->getNumSuccessors() != 2) {
+    return false;
+  }
+
+  BasicBlock *BBLeft = BI->getSuccessor(0);
+  BasicBlock *BBRight = BI->getSuccessor(1);
+
+  // BB must dominate both successors
+  if (!DT.dominates(&BB, BBLeft) || !DT.dominates(&BB, BBRight))
+    return false;
+
+  // there can not be edges between successors of BB
+  if (Utils::hasPathBetween(BBLeft, BBRight, DT))
+    return false;
+
+  // successors of BB can not post-dominate each other
+  if (PDT.dominates(BBLeft, BBRight) || PDT.dominates(BBRight, BBLeft))
+    return false;
+
+  if (!PDT.getNode(&BB)->getIDom()->getBlock()) {
+    DEBUG << "No IPDOM for block " << BB.getName()
+          << ", This case is not considered\n";
+    return false;
+  }
+
+  // FIXME : filter regions that contain swithc instructions for now
+  BasicBlock *IPDom = PDT.getNode(&BB)->getIDom()->getBlock();
+  SmallVector<BasicBlock *, 32> WorkList;
+  SmallSet<BasicBlock *, 32> Visited;
+  WorkList.push_back(BBRight);
+  WorkList.push_back(BBLeft);
+  while (!WorkList.empty()) {
+    BasicBlock *Curr = WorkList.pop_back_val();
+    Visited.insert(Curr);
+    if (containsUnhandledInstructions(Curr))
+      return false;
+    for (unsigned I = 0; I < Curr->getTerminator()->getNumSuccessors(); I++) {
+      BasicBlock *Succ = Curr->getTerminator()->getSuccessor(I);
+      if (Visited.find(Succ) == Visited.end() && Succ != &BB && Succ != IPDom) {
+        WorkList.push_back(Succ);
+      }
+    }
+  }
+
+  return true;
+}
+
+bool Utils::containsUnhandledInstructions(const BasicBlock *BB) {
+  for (const Instruction &I : *BB) {
+    if (I.getOpcode() == Instruction::Switch)
+      return true;
+  }
+  return false;
+}
+
+bool Utils::hasPathBetween(BasicBlock *L, BasicBlock *R, DominatorTree &DT) {
+
+  // path exists if any of the predecessors of L is dominated by R
+  for (auto It = pred_begin(L); It != pred_end(R); ++It) {
+    if (DT.dominates(R, *It))
+      return true;
+  }
+  // OR, any of the predecessors of R are dominated by L
+  for (auto It = pred_begin(R); It != pred_end(R); ++It) {
+    if (DT.dominates(L, *It))
+      return true;
+  }
+
+  return false;
+}
+
+std::pair<unsigned, unsigned>
+Utils::computeLatReductionAtBest(BasicBlock *BB1, BasicBlock *BB2) {
+  DenseMap<unsigned, std::pair<unsigned, unsigned>> FreqMap;
+  unsigned LatReducedAtBest = 0;
+  unsigned TotalLatency = 0;
+  for (auto It = BB1->begin(); It != BB1->end(); ++It) {
+    if (FreqMap.find(It->getOpcode()) == FreqMap.end())
+      FreqMap[It->getOpcode()] = std::make_pair(0, 0);
+
+    FreqMap[It->getOpcode()].first += Utils::getInstructionCost(&(*It));
+    TotalLatency += Utils::getInstructionCost(&(*It));
+  }
+
+  for (auto It = BB2->begin(); It != BB2->end(); ++It) {
+    if (FreqMap.find(It->getOpcode()) == FreqMap.end())
+      FreqMap[It->getOpcode()] = std::make_pair(0, 0);
+
+    FreqMap[It->getOpcode()].second += Utils::getInstructionCost(&(*It));
+    TotalLatency += Utils::getInstructionCost(&(*It));
+  }
+
+  for (auto It : FreqMap) {
+    std::pair<unsigned, unsigned> &Counts = It.second;
+    // PHI nodes are not melded
+    if (It.first == Instruction::PHI) {
+      continue;
+    }
+
+    LatReducedAtBest += std::min(Counts.first, Counts.second);
+  }
+
+  return std::pair<unsigned, unsigned>(LatReducedAtBest, TotalLatency);
+}
+
+double Utils::computeBlockSimilarity(BasicBlock *BB1, BasicBlock *BB2) {
+  // double NMergeableAtBest = (double)computeMaxNumMergeableInsts(BB1, BB2);
+  // double TotalInsts = (double)(BB1->size() + BB2->size());
+  // return NMergeableAtBest / TotalInsts;
+  auto LatInfo = computeLatReductionAtBest(BB1, BB2);
+  double LatReductionAtBest = (double)LatInfo.first;
+  double TotalLat = (double)LatInfo.second;
+  // errs() << "latency reduction at best in bb : " << LatReductionAtBest <<
+  // "\n"; errs() << "total latency in bb: " << TotalLat << "\n";
+  return LatReductionAtBest / TotalLat;
+}
+
+double Utils::computeBlockSimilarity(BasicBlock *BB1, BasicBlock *BB2,
+                                     Region *Replicated,
+                                     function_ref<int()> GetBrCost) {
+  int LatReductionAtBest = 0, TotalLatency = 0;
+  // iterate over all blocks in replicated region
+  for (auto *BB : Replicated->blocks()) {
+    // for the matched blocks compute the instructions that can merged in best case
+    if (BB == BB1 || BB == BB2) {
+      auto LatInfo = computeLatReductionAtBest(BB1, BB2);
+      LatReductionAtBest += LatInfo.first;
+      TotalLatency += LatInfo.second;
+    } 
+    // else you have to pay one more branch to execute the block conditionally
+    else {
+      for (Instruction &I : *BB) {
+        TotalLatency += Utils::getInstructionCost(&I);
+      }
+      LatReductionAtBest -= GetBrCost();
+    }
+  }
+
+  return (double)LatReductionAtBest / (double)TotalLatency;
+}
+
+double Utils::computeRegionSimilarity(
+    const DenseMap<BasicBlock *, BasicBlock *> &Mapping, BasicBlock *LExit) {
+  unsigned LatReductionAtBest = 0, TotalLat = 0;
+  for (auto It : Mapping) {
+    // exit is not melded, ignore it's profitablity
+    if (It.first == LExit)
+      continue;
+    auto LatInfo = computeLatReductionAtBest(It.first, It.second);
+
+    // NMergeableAtBest += computeMaxNumMergeableInsts(It.first, It.second);
+    // TotalInsts += (unsigned)(It.first->size() + It.second->size());
+    LatReductionAtBest += LatInfo.first;
+    TotalLat += LatInfo.second;
+    // errs() << "BB left : " << It.first->getName() << ", BB right : " <<
+    // It.second->getName() << "\n"; errs() << "Lat reduction in bb  : " <<
+    // LatInfo.first << "\n"; errs() << "Total lat in bb: " << LatInfo.second <<
+    // "\n";
+  }
+  // errs() << "latency reduction at best in region: " << LatReductionAtBest <<
+  // "\n"; errs() << "total latency in region: " << TotalLat << "\n";
+  return (double)LatReductionAtBest / (double)TotalLat;
+}
+
+int Utils::getInstructionCost(Instruction *I) {
+  int SavedCycles = 0;
+  switch (I->getOpcode()) {
+  case Instruction::Add:
+  case Instruction::FAdd:
+    SavedCycles = 5;
+    break;
+  case Instruction::Mul:
+  case Instruction::FMul:
+    SavedCycles = 10;
+    break;
+  case Instruction::SDiv:
+  case Instruction::UDiv:
+  case Instruction::FDiv:
+    SavedCycles = 20;
+    break;
+  case Instruction::Store:
+  case Instruction::Load:
+    SavedCycles = 100;
+    break;
+  default:
+    SavedCycles = 3;
+    break;
+  }
+  return SavedCycles;
+}
+
+std::string Utils::getNameStr(Value *V) {
+  std::string Out;
+  llvm::raw_string_ostream SS(Out);
+  V->printAsOperand(SS, false);
+  return SS.str();
+}
+
+void Utils::writeCFGToDotFile(Function &F, std::string Prefix) {
+  std::string Filename = (Prefix + F.getName() + ".dot").str();
+  errs() << "Writing '" << Filename << "'...";
+
+  std::error_code EC;
+  raw_fd_ostream File(Filename, EC, sys::fs::OF_Text);
+
+  DOTFuncInfo CFGInfo(&F);
+
+  if (!EC)
+    WriteGraph(File, &CFGInfo);
+  else
+    errs() << "  error opening file for writing!";
+  errs() << "\n";
+}
+
+static bool CmpNumbers(uint64_t L, uint64_t R) { return L == R; }
+
+// Any two pointers in the same address space are equivalent, intptr_t and
+// pointers are equivalent. Otherwise, standard type equivalence rules apply.
+static bool CmpTypes(Type *TyL, Type *TyR, const DataLayout *DL) {
+  auto *PTyL = dyn_cast<PointerType>(TyL);
+  auto *PTyR = dyn_cast<PointerType>(TyR);
+
+  // const DataLayout &DL = FnL->getParent()->getDataLayout();
+  if (PTyL && PTyL->getAddressSpace() == 0)
+    TyL = DL->getIntPtrType(TyL);
+  if (PTyR && PTyR->getAddressSpace() == 0)
+    TyR = DL->getIntPtrType(TyR);
+
+  if (TyL == TyR)
+    return true;
+
+  if (int Res = CmpNumbers(TyL->getTypeID(), TyR->getTypeID()))
+    return Res;
+
+  switch (TyL->getTypeID()) {
+  default:
+    llvm_unreachable("Unknown type!");
+  case Type::IntegerTyID:
+    return CmpNumbers(cast<IntegerType>(TyL)->getBitWidth(),
+                      cast<IntegerType>(TyR)->getBitWidth());
+  // TyL == TyR would have returned true earlier, because types are uniqued.
+  case Type::VoidTyID:
+  case Type::FloatTyID:
+  case Type::DoubleTyID:
+  case Type::X86_FP80TyID:
+  case Type::FP128TyID:
+  case Type::PPC_FP128TyID:
+  case Type::LabelTyID:
+  case Type::MetadataTyID:
+  case Type::TokenTyID:
+    return false;
+
+  case Type::PointerTyID:
+    assert(PTyL && PTyR && "Both types must be pointers here.");
+    return CmpNumbers(PTyL->getAddressSpace(), PTyR->getAddressSpace());
+
+  case Type::StructTyID: {
+    auto *STyL = cast<StructType>(TyL);
+    auto *STyR = cast<StructType>(TyR);
+    if (STyL->getNumElements() != STyR->getNumElements())
+      return CmpNumbers(STyL->getNumElements(), STyR->getNumElements());
+
+    if (STyL->isPacked() != STyR->isPacked())
+      return CmpNumbers(STyL->isPacked(), STyR->isPacked());
+
+    for (unsigned i = 0, e = STyL->getNumElements(); i != e; ++i) {
+      if (int Res =
+              CmpTypes(STyL->getElementType(i), STyR->getElementType(i), DL))
+        return Res;
+    }
+    return false;
+  }
+
+  case Type::FunctionTyID: {
+    auto *FTyL = cast<FunctionType>(TyL);
+    auto *FTyR = cast<FunctionType>(TyR);
+    if (FTyL->getNumParams() != FTyR->getNumParams())
+      return CmpNumbers(FTyL->getNumParams(), FTyR->getNumParams());
+
+    if (FTyL->isVarArg() != FTyR->isVarArg())
+      return CmpNumbers(FTyL->isVarArg(), FTyR->isVarArg());
+
+    if (int Res = CmpTypes(FTyL->getReturnType(), FTyR->getReturnType(), DL))
+      return Res;
+
+    for (unsigned i = 0, e = FTyL->getNumParams(); i != e; ++i) {
+      if (int Res = CmpTypes(FTyL->getParamType(i), FTyR->getParamType(i), DL))
+        return Res;
+    }
+    return false;
+  }
+
+  case Type::ArrayTyID: {
+    auto *STyL = cast<ArrayType>(TyL);
+    auto *STyR = cast<ArrayType>(TyR);
+    if (STyL->getNumElements() != STyR->getNumElements())
+      return CmpNumbers(STyL->getNumElements(), STyR->getNumElements());
+    return CmpTypes(STyL->getElementType(), STyR->getElementType(), DL);
+  }
+  case Type::FixedVectorTyID:
+  case Type::ScalableVectorTyID: {
+    auto *STyL = cast<VectorType>(TyL);
+    auto *STyR = cast<VectorType>(TyR);
+    if (STyL->getElementCount().isScalable() !=
+        STyR->getElementCount().isScalable())
+      return CmpNumbers(STyL->getElementCount().isScalable(),
+                        STyR->getElementCount().isScalable());
+    if (STyL->getElementCount() != STyR->getElementCount())
+      return CmpNumbers(STyL->getElementCount().getKnownMinValue(),
+                        STyR->getElementCount().getKnownMinValue());
+    return CmpTypes(STyL->getElementType(), STyR->getElementType(), DL);
+  }
+  }
+}
+
+// Any two pointers in the same address space are equivalent, intptr_t and
+// pointers are equivalent. Otherwise, standard type equivalence rules apply.
+bool InstructionMatchUtils::areTypesEquivalent(Type *Ty1, Type *Ty2,
+                                        const DataLayout *DL,
+                                        const InstructionMatchOptions &Options) {
+  if (Ty1 == Ty2)
+    return true;
+  if (Options.IdenticalTypesOnly)
+    return false;
+
+  return CmpTypes(Ty1, Ty2, DL);
+}
+
+static bool matchIntrinsicCalls(Intrinsic::ID ID, const CallBase *CI1,
+                                const CallBase *CI2) {
+  Function *F = CI1->getCalledFunction();
+  if (!F)
+    return false;
+  auto ID1 = (Intrinsic::ID)F->getIntrinsicID();
+
+  F = CI2->getCalledFunction();
+  if (!F)
+    return false;
+  auto ID2 = (Intrinsic::ID)F->getIntrinsicID();
+
+  if (ID1 != ID)
+    return false;
+  if (ID1 != ID2)
+    return false;
+
+  switch (ID) {
+  default:
+    break;
+  case Intrinsic::coro_id: {
+    /*
+    auto *InfoArg = CS.getArgOperand(3)->stripPointerCasts();
+    if (isa<ConstantPointerNull>(InfoArg))
+      break;
+    auto *GV = dyn_cast<GlobalVariable>(InfoArg);
+    Assert(GV && GV->isConstant() && GV->hasDefinitiveInitializer(),
+      "info argument of llvm.coro.begin must refer to an initialized "
+      "constant");
+    Constant *Init = GV->getInitializer();
+    Assert(isa<ConstantStruct>(Init) || isa<ConstantArray>(Init),
+      "info argument of llvm.coro.begin must refer to either a struct or "
+      "an array");
+    */
+    break;
+  }
+  case Intrinsic::ctlz: // llvm.ctlz
+  case Intrinsic::cttz: // llvm.cttz
+    // is_zero_undef argument of bit counting intrinsics must be a constant int
+    return CI1->getArgOperand(1) == CI2->getArgOperand(1);
+  case Intrinsic::experimental_constrained_fadd:
+  case Intrinsic::experimental_constrained_fsub:
+  case Intrinsic::experimental_constrained_fmul:
+  case Intrinsic::experimental_constrained_fdiv:
+  case Intrinsic::experimental_constrained_frem:
+  case Intrinsic::experimental_constrained_fma:
+  case Intrinsic::experimental_constrained_sqrt:
+  case Intrinsic::experimental_constrained_pow:
+  case Intrinsic::experimental_constrained_powi:
+  case Intrinsic::experimental_constrained_sin:
+  case Intrinsic::experimental_constrained_cos:
+  case Intrinsic::experimental_constrained_exp:
+  case Intrinsic::experimental_constrained_exp2:
+  case Intrinsic::experimental_constrained_log:
+  case Intrinsic::experimental_constrained_log10:
+  case Intrinsic::experimental_constrained_log2:
+  case Intrinsic::experimental_constrained_rint:
+  case Intrinsic::experimental_constrained_nearbyint:
+    // visitConstrainedFPIntrinsic(
+    //    cast<ConstrainedFPIntrinsic>(*CS.getInstruction()));
+    break;
+  case Intrinsic::dbg_declare: // llvm.dbg.declare
+    // Assert(isa<MetadataAsValue>(CS.getArgOperand(0)),
+    //       "invalid llvm.dbg.declare intrinsic call 1", CS);
+    // visitDbgIntrinsic("declare",
+    // cast<DbgInfoIntrinsic>(*CS.getInstruction()));
+    break;
+  case Intrinsic::dbg_addr: // llvm.dbg.addr
+    // visitDbgIntrinsic("addr", cast<DbgInfoIntrinsic>(*CS.getInstruction()));
+    break;
+  case Intrinsic::dbg_value: // llvm.dbg.value
+    // visitDbgIntrinsic("value", cast<DbgInfoIntrinsic>(*CS.getInstruction()));
+    break;
+  case Intrinsic::dbg_label: // llvm.dbg.label
+    // visitDbgLabelIntrinsic("label",
+    // cast<DbgLabelInst>(*CS.getInstruction()));
+    break;
+  case Intrinsic::memcpy:
+  case Intrinsic::memmove:
+  case Intrinsic::memset: {
+    // isvolatile argument of memory intrinsics must be a constant int
+    return CI1->getArgOperand(3) == CI2->getArgOperand(3);
+  }
+  case Intrinsic::memcpy_element_unordered_atomic:
+  case Intrinsic::memmove_element_unordered_atomic:
+  case Intrinsic::memset_element_unordered_atomic: {
+    const auto *AMI1 = cast<AtomicMemIntrinsic>(CI1);
+    const auto *AMI2 = cast<AtomicMemIntrinsic>(CI2);
+
+    auto *ElementSizeCI1 = dyn_cast<ConstantInt>(AMI1->getRawElementSizeInBytes());
+
+    auto *ElementSizeCI2 = dyn_cast<ConstantInt>(AMI2->getRawElementSizeInBytes());
+
+    return (ElementSizeCI1 != nullptr && ElementSizeCI1 == ElementSizeCI2);
+  }
+  case Intrinsic::gcroot:
+  case Intrinsic::gcwrite:
+  case Intrinsic::gcread:
+    // llvm.gcroot parameter #2 must be a constant.
+    return CI1->getArgOperand(1) == CI2->getArgOperand(1);
+  case Intrinsic::init_trampoline:
+    break;
+  case Intrinsic::prefetch:
+    // arguments #2 and #3 in llvm.prefetch must be constants
+    return CI1->getArgOperand(1) == CI2->getArgOperand(1) &&
+           CI1->getArgOperand(2) == CI2->getArgOperand(2);
+  case Intrinsic::stackprotector:
+    /*
+    Assert(isa<AllocaInst>(CS.getArgOperand(1)->stripPointerCasts()),
+           "llvm.stackprotector parameter #2 must resolve to an alloca.", CS);
+    */
+    break;
+  case Intrinsic::lifetime_start:
+  case Intrinsic::lifetime_end:
+  case Intrinsic::invariant_start:
+    // size argument of memory use markers must be a constant integer
+    return CI1->getArgOperand(0) == CI2->getArgOperand(0);
+  case Intrinsic::invariant_end:
+    // llvm.invariant.end parameter #2 must be a constant integer
+    return CI1->getArgOperand(1) == CI2->getArgOperand(1);
+  case Intrinsic::localescape: {
+    /*
+    BasicBlock *BB = CS.getParent();
+    Assert(BB == &BB->getParent()->front(),
+           "llvm.localescape used outside of entry block", CS);
+    Assert(!SawFrameEscape,
+           "multiple calls to llvm.localescape in one function", CS);
+    for (Value *Arg : CS.args()) {
+      if (isa<ConstantPointerNull>(Arg))
+        continue; // Null values are allowed as placeholders.
+      auto *AI = dyn_cast<AllocaInst>(Arg->stripPointerCasts());
+      Assert(AI && AI->isStaticAlloca(),
+             "llvm.localescape only accepts static allocas", CS);
+    }
+    FrameEscapeInfo[BB->getParent()].first = CS.getNumArgOperands();
+    SawFrameEscape = true;
+    */
+    break;
+  }
+  case Intrinsic::localrecover: {
+    /*
+    Value *FnArg = CS.getArgOperand(0)->stripPointerCasts();
+    Function *Fn = dyn_cast<Function>(FnArg);
+    Assert(Fn && !Fn->isDeclaration(),
+           "llvm.localrecover first "
+           "argument must be function defined in this module",
+           CS);
+    auto *IdxArg = dyn_cast<ConstantInt>(CS.getArgOperand(2));
+    Assert(IdxArg, "idx argument of llvm.localrecover must be a constant int",
+           CS);
+    auto &Entry = FrameEscapeInfo[Fn];
+    Entry.second = unsigned(
+        std::max(uint64_t(Entry.second), IdxArg->getLimitedValue(~0U) + 1));
+    */
+    break;
+  }
+    /*
+    case Intrinsic::experimental_gc_statepoint:
+      Assert(!CS.isInlineAsm(),
+             "gc.statepoint support for inline assembly unimplemented", CS);
+      Assert(CS.getParent()->getParent()->hasGC(),
+             "Enclosing function does not use GC.", CS);
+
+      verifyStatepoint(CS);
+      break;
+    case Intrinsic::experimental_gc_result: {
+      Assert(CS.getParent()->getParent()->hasGC(),
+             "Enclosing function does not use GC.", CS);
+      // Are we tied to a statepoint properly?
+      CallSite StatepointCS(CS.getArgOperand(0));
+      const Function *StatepointFn =
+        StatepointCS.getInstruction() ? StatepointCS.getCalledFunction() :
+    nullptr; Assert(StatepointFn && StatepointFn->isDeclaration() &&
+                 StatepointFn->getIntrinsicID() ==
+                     Intrinsic::experimental_gc_statepoint,
+             "gc.result operand #1 must be from a statepoint", CS,
+             CS.getArgOperand(0));
+
+      // Assert that result type matches wrapped callee.
+      const Value *Target = StatepointCS.getArgument(2);
+      auto *PT = cast<PointerType>(Target->getType());
+      auto *TargetFuncType = cast<FunctionType>(PT->getElementType());
+      Assert(CS.getType() == TargetFuncType->getReturnType(),
+             "gc.result result type does not match wrapped callee", CS);
+      break;
+    }
+    case Intrinsic::experimental_gc_relocate: {
+      Assert(CS.getNumArgOperands() == 3, "wrong number of arguments", CS);
+
+      Assert(isa<PointerType>(CS.getType()->getScalarType()),
+             "gc.relocate must return a pointer or a vector of pointers", CS);
+
+      // Check that this relocate is correctly tied to the statepoint
+
+      // This is case for relocate on the unwinding path of an invoke statepoint
+      if (LandingPadInst *LandingPad =
+            dyn_cast<LandingPadInst>(CS.getArgOperand(0))) {
+
+        const BasicBlock *InvokeBB =
+            LandingPad->getParent()->getUniquePredecessor();
+
+        // Landingpad relocates should have only one predecessor with invoke
+        // statepoint terminator
+        Assert(InvokeBB, "safepoints should have unique landingpads",
+               LandingPad->getParent());
+        Assert(InvokeBB->getTerminator(), "safepoint block should be well
+    formed", InvokeBB); Assert(isStatepoint(InvokeBB->getTerminator()), "gc
+    relocate should be linked to a statepoint", InvokeBB);
+      }
+      else {
+        // In all other cases relocate should be tied to the statepoint
+    directly.
+        // This covers relocates on a normal return path of invoke statepoint
+    and
+        // relocates of a call statepoint.
+        auto Token = CS.getArgOperand(0);
+        Assert(isa<Instruction>(Token) &&
+    isStatepoint(cast<Instruction>(Token)), "gc relocate is incorrectly tied to
+    the statepoint", CS, Token);
+      }
+
+      // Verify rest of the relocate arguments.
+
+      ImmutableCallSite StatepointCS(
+          cast<GCRelocateInst>(*CS.getInstruction()).getStatepoint());
+
+      // Both the base and derived must be piped through the safepoint.
+      Value* Base = CS.getArgOperand(1);
+      Assert(isa<ConstantInt>(Base),
+             "gc.relocate operand #2 must be integer offset", CS);
+
+      Value* Derived = CS.getArgOperand(2);
+      Assert(isa<ConstantInt>(Derived),
+             "gc.relocate operand #3 must be integer offset", CS);
+
+      const int BaseIndex = cast<ConstantInt>(Base)->getZExtValue();
+      const int DerivedIndex = cast<ConstantInt>(Derived)->getZExtValue();
+      // Check the bounds
+      Assert(0 <= BaseIndex && BaseIndex < (int)StatepointCS.arg_size(),
+             "gc.relocate: statepoint base index out of bounds", CS);
+      Assert(0 <= DerivedIndex && DerivedIndex < (int)StatepointCS.arg_size(),
+             "gc.relocate: statepoint derived index out of bounds", CS);
+
+      // Check that BaseIndex and DerivedIndex fall within the 'gc parameters'
+      // section of the statepoint's argument.
+      Assert(StatepointCS.arg_size() > 0,
+             "gc.statepoint: insufficient arguments");
+      Assert(isa<ConstantInt>(StatepointCS.getArgument(3)),
+             "gc.statement: number of call arguments must be constant integer");
+      const unsigned NumCallArgs =
+          cast<ConstantInt>(StatepointCS.getArgument(3))->getZExtValue();
+      Assert(StatepointCS.arg_size() > NumCallArgs + 5,
+             "gc.statepoint: mismatch in number of call arguments");
+      Assert(isa<ConstantInt>(StatepointCS.getArgument(NumCallArgs + 5)),
+             "gc.statepoint: number of transition arguments must be "
+             "a constant integer");
+      const int NumTransitionArgs =
+          cast<ConstantInt>(StatepointCS.getArgument(NumCallArgs + 5))
+              ->getZExtValue();
+      const int DeoptArgsStart = 4 + NumCallArgs + 1 + NumTransitionArgs + 1;
+      Assert(isa<ConstantInt>(StatepointCS.getArgument(DeoptArgsStart)),
+             "gc.statepoint: number of deoptimization arguments must be "
+             "a constant integer");
+      const int NumDeoptArgs =
+          cast<ConstantInt>(StatepointCS.getArgument(DeoptArgsStart))
+              ->getZExtValue();
+      const int GCParamArgsStart = DeoptArgsStart + 1 + NumDeoptArgs;
+      const int GCParamArgsEnd = StatepointCS.arg_size();
+      Assert(GCParamArgsStart <= BaseIndex && BaseIndex < GCParamArgsEnd,
+             "gc.relocate: statepoint base index doesn't fall within the "
+             "'gc parameters' section of the statepoint call",
+             CS);
+      Assert(GCParamArgsStart <= DerivedIndex && DerivedIndex < GCParamArgsEnd,
+             "gc.relocate: statepoint derived index doesn't fall within the "
+             "'gc parameters' section of the statepoint call",
+             CS);
+
+      // Relocated value must be either a pointer type or vector-of-pointer
+    type,
+      // but gc_relocate does not need to return the same pointer type as the
+      // relocated pointer. It can be casted to the correct type later if it's
+      // desired. However, they must have the same address space and
+    'vectorness' GCRelocateInst &Relocate =
+    cast<GCRelocateInst>(*CS.getInstruction());
+      Assert(Relocate.getDerivedPtr()->getType()->isPtrOrPtrVectorTy(),
+             "gc.relocate: relocated value must be a gc pointer", CS);
+
+      auto ResultType = CS.getType();
+      auto DerivedType = Relocate.getDerivedPtr()->getType();
+      Assert(ResultType->isVectorTy() == DerivedType->isVectorTy(),
+             "gc.relocate: vector relocates to vector and pointer to pointer",
+             CS);
+      Assert(
+          ResultType->getPointerAddressSpace() ==
+              DerivedType->getPointerAddressSpace(),
+          "gc.relocate: relocating a pointer shouldn't change its address
+    space", CS); break;
+    }
+    case Intrinsic::eh_exceptioncode:
+    case Intrinsic::eh_exceptionpointer: {
+      Assert(isa<CatchPadInst>(CS.getArgOperand(0)),
+             "eh.exceptionpointer argument must be a catchpad", CS);
+      break;
+    }
+    case Intrinsic::masked_load: {
+      Assert(CS.getType()->isVectorTy(), "masked_load: must return a vector",
+    CS);
+
+      Value *Ptr = CS.getArgOperand(0);
+      //Value *Alignment = CS.getArgOperand(1);
+      Value *Mask = CS.getArgOperand(2);
+      Value *PassThru = CS.getArgOperand(3);
+      Assert(Mask->getType()->isVectorTy(),
+             "masked_load: mask must be vector", CS);
+
+      // DataTy is the overloaded type
+      Type *DataTy = cast<PointerType>(Ptr->getType())->getElementType();
+      Assert(DataTy == CS.getType(),
+             "masked_load: return must match pointer type", CS);
+      Assert(PassThru->getType() == DataTy,
+             "masked_load: pass through and data type must match", CS);
+      Assert(Mask->getType()->getVectorNumElements() ==
+             DataTy->getVectorNumElements(),
+             "masked_load: vector mask must be same length as data", CS);
+      break;
+    }
+    case Intrinsic::masked_store: {
+      Value *Val = CS.getArgOperand(0);
+      Value *Ptr = CS.getArgOperand(1);
+      //Value *Alignment = CS.getArgOperand(2);
+      Value *Mask = CS.getArgOperand(3);
+      Assert(Mask->getType()->isVectorTy(),
+             "masked_store: mask must be vector", CS);
+
+      // DataTy is the overloaded type
+      Type *DataTy = cast<PointerType>(Ptr->getType())->getElementType();
+      Assert(DataTy == Val->getType(),
+             "masked_store: storee must match pointer type", CS);
+      Assert(Mask->getType()->getVectorNumElements() ==
+             DataTy->getVectorNumElements(),
+             "masked_store: vector mask must be same length as data", CS);
+      break;
+    }
+
+    case Intrinsic::experimental_guard: {
+      Assert(CS.isCall(), "experimental_guard cannot be invoked", CS);
+      Assert(CS.countOperandBundlesOfType(LLVMContext::OB_deopt) == 1,
+             "experimental_guard must have exactly one "
+             "\"deopt\" operand bundle");
+      break;
+    }
+
+    case Intrinsic::experimental_deoptimize: {
+      Assert(CS.isCall(), "experimental_deoptimize cannot be invoked", CS);
+      Assert(CS.countOperandBundlesOfType(LLVMContext::OB_deopt) == 1,
+             "experimental_deoptimize must have exactly one "
+             "\"deopt\" operand bundle");
+      Assert(CS.getType() ==
+    CS.getInstruction()->getFunction()->getReturnType(),
+             "experimental_deoptimize return type must match caller return
+    type");
+
+      if (CS.isCall()) {
+        auto *DeoptCI = CS.getInstruction();
+        auto *RI = dyn_cast<ReturnInst>(DeoptCI->getNextNode());
+        Assert(RI,
+               "calls to experimental_deoptimize must be followed by a return");
+
+        if (!CS.getType()->isVoidTy() && RI)
+          Assert(RI->getReturnValue() == DeoptCI,
+                 "calls to experimental_deoptimize must be followed by a return
+    " "of the value computed by experimental_deoptimize");
+      }
+
+      break;
+    }
+    */
+  };
+  return false; // TODO: change to false by default
+}
+
+// bool FunctionMerger::matchLandingPad(LandingPadInst *LP1, LandingPadInst
+// *LP2) {
+static bool matchLandingPad(LandingPadInst *LP1, LandingPadInst *LP2) {
+  if (LP1->getType() != LP2->getType())
+    return false;
+  if (LP1->isCleanup() != LP2->isCleanup())
+    return false;
+  if (LP1->getNumClauses() != LP2->getNumClauses())
+    return false;
+  for (unsigned i = 0; i < LP1->getNumClauses(); i++) {
+    if (LP1->isCatch(i) != LP2->isCatch(i))
+      return false;
+    if (LP1->isFilter(i) != LP2->isFilter(i))
+      return false;
+    if (LP1->getClause(i) != LP2->getClause(i))
+      return false;
+  }
+  return true;
+}
+
+static bool matchLoadInsts(const LoadInst *LI1, const LoadInst *LI2) {
+  return LI1->isVolatile() == LI2->isVolatile() &&
+         LI1->getAlignment() == LI2->getAlignment() &&
+         LI1->getOrdering() == LI2->getOrdering();
+}
+
+static bool matchStoreInsts(const StoreInst *SI1, const StoreInst *SI2) {
+  return SI1->isVolatile() == SI2->isVolatile() &&
+         SI1->getAlignment() == SI2->getAlignment() &&
+         SI1->getOrdering() == SI2->getOrdering();
+}
+
+static bool matchAllocaInsts(const AllocaInst *AI1, const AllocaInst *AI2) {
+  if (AI1->getArraySize() != AI2->getArraySize() ||
+      AI1->getAlignment() != AI2->getAlignment())
+    return false;
+
+  /*
+  // If size is known, I2 can be seen as equivalent to I1 if it allocates
+  // the same or less memory.
+  if (DL->getTypeAllocSize(AI->getAllocatedType())
+        < DL->getTypeAllocSize(cast<AllocaInst>(I2)->getAllocatedType()))
+    return false;
+
+  */
+
+  return true;
+}
+
+static bool matchGetElementPtrInsts(const GetElementPtrInst *GEP1,
+                                    const GetElementPtrInst *GEP2) {
+  Type *Ty1 = GEP1->getSourceElementType();
+  SmallVector<Value *, 16> Idxs1(GEP1->idx_begin(), GEP1->idx_end());
+
+  Type *Ty2 = GEP2->getSourceElementType();
+  SmallVector<Value *, 16> Idxs2(GEP2->idx_begin(), GEP2->idx_end());
+
+  if (Ty1 != Ty2)
+    return false;
+  if (Idxs1.size() != Idxs2.size())
+    return false;
+
+  if (Idxs1.empty())
+    return true;
+
+  for (unsigned i = 1; i < Idxs1.size(); i++) {
+    Value *V1 = Idxs1[i];
+    Value *V2 = Idxs2[i];
+
+    // structs must have constant indices, therefore they must be constants and
+    // must be identical when merging
+    if (isa<StructType>(Ty1)) {
+      if (V1 != V2)
+        return false;
+    }
+    Ty1 = GetElementPtrInst::getTypeAtIndex(Ty1, V1);
+    Ty2 = GetElementPtrInst::getTypeAtIndex(Ty2, V2);
+    if (Ty1 != Ty2)
+      return false;
+  }
+  return true;
+}
+
+static bool matchSwitchInsts(const SwitchInst *SI1, const SwitchInst *SI2) {
+  if (SI1->getNumCases() == SI2->getNumCases()) {
+    auto CaseIt1 = SI1->case_begin(), CaseEnd1 = SI1->case_end();
+    auto CaseIt2 = SI2->case_begin(), CaseEnd2 = SI2->case_end();
+    do {
+      auto *Case1 = &*CaseIt1;
+      auto *Case2 = &*CaseIt2;
+      if (Case1 != Case2)
+        return false; // TODO: could allow permutation!
+      ++CaseIt1;
+      ++CaseIt2;
+    } while (CaseIt1 != CaseEnd1 && CaseIt2 != CaseEnd2);
+    return true;
+  }
+  return false;
+}
+
+static bool matchCallInsts(const CallBase *CI1, const CallBase *CI2) {
+  if (CI1->isInlineAsm() || CI2->isInlineAsm())
+    return false;
+
+  // if (CI1->getCalledFunction()==nullptr) return false;
+
+  if (CI1->getCalledFunction() != CI2->getCalledFunction())
+    return false;
+
+  if (Function *F = CI1->getCalledFunction()) {
+    if (auto ID = (Intrinsic::ID)F->getIntrinsicID()) {
+      if (!matchIntrinsicCalls(ID, CI1, CI2))
+        return false;
+    }
+  }
+
+  return CI1->arg_size() == CI2->arg_size() &&
+         CI1->getCallingConv() == CI2->getCallingConv() &&
+         CI1->getAttributes() == CI2->getAttributes();
+}
+
+static bool matchInvokeInsts(const InvokeInst *II1, const InvokeInst *II2) {
+  return matchCallInsts(II1, II2) &&
+         II1->getCallingConv() == II2->getCallingConv() &&
+         II1->getAttributes() == II2->getAttributes() &&
+         matchLandingPad(II1->getLandingPadInst(), II2->getLandingPadInst());
+}
+
+static bool matchInsertValueInsts(const InsertValueInst *IV1,
+                                  const InsertValueInst *IV2) {
+  return IV1->getIndices() == IV2->getIndices();
+}
+
+static bool matchExtractValueInsts(const ExtractValueInst *EV1,
+                                   const ExtractValueInst *EV2) {
+  return EV1->getIndices() == EV2->getIndices();
+}
+
+static bool matchFenceInsts(const FenceInst *FI1, const FenceInst *FI2) {
+  return FI1->getOrdering() == FI2->getOrdering() &&
+         FI1->getSyncScopeID() == FI2->getSyncScopeID();
+}
+
+bool InstructionMatchUtils::matchInstructions(Instruction *I1, Instruction *I2,
+                                       const InstructionMatchOptions &Options) {
+
+  if (I1->getOpcode() != I2->getOpcode())
+    return false;
+
+  if (I1->getOpcode() == Instruction::CallBr)
+    return false;
+
+  // Returns are special cases that can differ in the number of operands
+  if (I1->getOpcode() == Instruction::Ret)
+    return true;
+
+  if (I1->getNumOperands() != I2->getNumOperands())
+    return false;
+
+  const DataLayout *DL =
+      &I1->getParent()->getParent()->getParent()->getDataLayout();
+
+  bool sameType = false;
+  if (Options.IdenticalTypesOnly) {
+    sameType = (I1->getType() == I2->getType());
+    for (unsigned i = 0; i < I1->getNumOperands(); i++) {
+      sameType = sameType &&
+                 (I1->getOperand(i)->getType() == I2->getOperand(i)->getType());
+    }
+  } else {
+    sameType = areTypesEquivalent(I1->getType(), I2->getType(), DL, Options);
+    for (unsigned i = 0; i < I1->getNumOperands(); i++) {
+      sameType = sameType &&
+                 areTypesEquivalent(I1->getOperand(i)->getType(),
+                                    I2->getOperand(i)->getType(), DL, Options);
+    }
+  }
+  if (!sameType)
+    return false;
+
+  switch (I1->getOpcode()) {
+    // case Instruction::Br: return false; //{ return (I1->getNumOperands()==1);
+    // }
+
+    //#define MatchCaseInst(Kind, I1, I2) case Instruction::#Kind
+
+  case Instruction::Load:
+    return matchLoadInsts(dyn_cast<LoadInst>(I1), dyn_cast<LoadInst>(I2));
+  case Instruction::Store:
+    return matchStoreInsts(dyn_cast<StoreInst>(I1), dyn_cast<StoreInst>(I2));
+  case Instruction::Alloca:
+    return matchAllocaInsts(dyn_cast<AllocaInst>(I1), dyn_cast<AllocaInst>(I2));
+  case Instruction::GetElementPtr:
+    return matchGetElementPtrInsts(dyn_cast<GetElementPtrInst>(I1),
+                                   dyn_cast<GetElementPtrInst>(I2));
+  case Instruction::Switch:
+    return matchSwitchInsts(dyn_cast<SwitchInst>(I1), dyn_cast<SwitchInst>(I2));
+  case Instruction::Call:
+    return matchCallInsts(dyn_cast<CallInst>(I1), dyn_cast<CallInst>(I2));
+  case Instruction::Invoke:
+    return matchInvokeInsts(dyn_cast<InvokeInst>(I1), dyn_cast<InvokeInst>(I2));
+  case Instruction::InsertValue:
+    return matchInsertValueInsts(dyn_cast<InsertValueInst>(I1),
+                                 dyn_cast<InsertValueInst>(I2));
+  case Instruction::ExtractValue:
+    return matchExtractValueInsts(dyn_cast<ExtractValueInst>(I1),
+                                  dyn_cast<ExtractValueInst>(I2));
+  case Instruction::Fence:
+    return matchFenceInsts(dyn_cast<FenceInst>(I1), dyn_cast<FenceInst>(I2));
+  case Instruction::AtomicCmpXchg: {
+    const AtomicCmpXchgInst *CXI = dyn_cast<AtomicCmpXchgInst>(I1);
+    const AtomicCmpXchgInst *CXI2 = cast<AtomicCmpXchgInst>(I2);
+    return CXI->isVolatile() == CXI2->isVolatile() &&
+           CXI->isWeak() == CXI2->isWeak() &&
+           CXI->getSuccessOrdering() == CXI2->getSuccessOrdering() &&
+           CXI->getFailureOrdering() == CXI2->getFailureOrdering() &&
+           CXI->getSyncScopeID() == CXI2->getSyncScopeID();
+  }
+  case Instruction::AtomicRMW: {
+    const AtomicRMWInst *RMWI = dyn_cast<AtomicRMWInst>(I1);
+    return RMWI->getOperation() == cast<AtomicRMWInst>(I2)->getOperation() &&
+           RMWI->isVolatile() == cast<AtomicRMWInst>(I2)->isVolatile() &&
+           RMWI->getOrdering() == cast<AtomicRMWInst>(I2)->getOrdering() &&
+           RMWI->getSyncScopeID() == cast<AtomicRMWInst>(I2)->getSyncScopeID();
+  }
+  default:
+    if (auto *CI = dyn_cast<CmpInst>(I1))
+      return CI->getPredicate() == cast<CmpInst>(I2)->getPredicate();
+    if (isa<OverflowingBinaryOperator>(I1)) {
+      if (!isa<OverflowingBinaryOperator>(I2))
+        return false;
+      if (I1->hasNoUnsignedWrap() != I2->hasNoUnsignedWrap())
+        return false;
+      if (I1->hasNoSignedWrap() != I2->hasNoSignedWrap())
+        return false;
+    }
+    if (isa<PossiblyExactOperator>(I1)) {
+      if (!isa<PossiblyExactOperator>(I2))
+        return false;
+      if (I1->isExact() != I2->isExact())
+        return false;
+    }
+    if (isa<FPMathOperator>(I1)) {
+      if (!isa<FPMathOperator>(I2))
+        return false;
+      if (I1->isFast() != I2->isFast())
+        return false;
+      if (I1->hasAllowReassoc() != I2->hasAllowReassoc())
+        return false;
+      if (I1->hasNoNaNs() != I2->hasNoNaNs())
+        return false;
+      if (I1->hasNoInfs() != I2->hasNoInfs())
+        return false;
+      if (I1->hasNoSignedZeros() != I2->hasNoSignedZeros())
+        return false;
+      if (I1->hasAllowReciprocal() != I2->hasAllowReciprocal())
+        return false;
+      if (I1->hasAllowContract() != I2->hasAllowContract())
+        return false;
+      if (I1->hasApproxFunc() != I2->hasApproxFunc())
+        return false;
+    }
+  }
+
+  return true;
+}
+
+bool InstructionMatchUtils::match(Value *V1, Value *V2) {
+  if (isa<Instruction>(V1) && isa<Instruction>(V2))
+    return matchInstructions(dyn_cast<Instruction>(V1),
+                             dyn_cast<Instruction>(V2));
+
+  if (isa<BasicBlock>(V1) && isa<BasicBlock>(V2)) {
+    auto *BB1 = dyn_cast<BasicBlock>(V1);
+    auto *BB2 = dyn_cast<BasicBlock>(V2);
+    if (BB1->isLandingPad() || BB2->isLandingPad()) {
+      LandingPadInst *LP1 = BB1->getLandingPadInst();
+      LandingPadInst *LP2 = BB2->getLandingPadInst();
+      if (LP1 == nullptr || LP2 == nullptr)
+        return false;
+      return matchLandingPad(LP1, LP2);
+    } 
+    return true;
+  }
+  return false;
+}
diff --git a/llvm/lib/Transforms/CFMelder/CFMelderUtils.h b/llvm/lib/Transforms/CFMelder/CFMelderUtils.h
new file mode 100644
index 000000000000..8dfef09d9310
--- /dev/null
+++ b/llvm/lib/Transforms/CFMelder/CFMelderUtils.h
@@ -0,0 +1,119 @@
+#ifndef LLVM_LIB_TRANSFORMS_CFMELDER_UTILS_H
+#define LLVM_LIB_TRANSFORMS_CFMELDER_UTILS_H
+
+// #include "llvm/ADT/SequenceAlignment.h"
+#include "llvm/ADT/SmallSet.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/PostDominators.h"
+#include "llvm/Analysis/RegionInfo.h"
+#include "llvm/IR/Dominators.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/IRBuilder.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/raw_ostream.h"
+
+#define CFMELDER_DEBUG
+
+#ifdef CFMELDER_DEBUG
+
+#define INFO errs() << "INFO   : "
+#define DEBUG errs() << "DEBUG  : "
+
+#endif
+
+#ifdef CFMELDER_INFO
+
+#define INFO errs() << "INFO   : "
+#define DEBUG
+
+#endif
+
+namespace llvm {
+
+// utilities for decide instruction merging compatibility
+// taken from : https://github.com/charitha22/hybf-cc23-artifact/blob/main/llvm/include/llvm/Transforms/IPO/FunctionMerging.h
+class InstructionMatchUtils {
+public:
+  struct InstructionMatchOptions {
+    bool IdenticalTypesOnly;
+    bool EnableUnifiedReturnType;
+
+    InstructionMatchOptions(bool IdenticalTypesOnly = true,
+                          bool EnableUnifiedReturnType = true)
+        : IdenticalTypesOnly(IdenticalTypesOnly),
+          EnableUnifiedReturnType(EnableUnifiedReturnType) {}
+  };
+  static bool matchInstructions(Instruction *I1, Instruction *I2,
+                                const InstructionMatchOptions &Options = {});
+
+  static bool areTypesEquivalent(Type *Ty1, Type *Ty2, const DataLayout *DL,
+                                 const InstructionMatchOptions &Options = {});
+
+  /// Checks if value 'V1' can be merged with value 'V2'
+  static bool match(Value *V1, Value *V2);
+};
+
+/// utility functions
+class Utils {
+public:
+  static bool containsUnhandledInstructions(const BasicBlock *BB);
+
+  /// Check if block BB is valid location to apply the melding transformation.
+  /// follwing condtions are checked here.
+  /// - BB must have two successors
+  /// - BB must dominate both successors
+  /// - Successors of BB can not have a path between them
+  /// - Successors of BB can not post-dominate each other
+  /// - BB must have post dominator
+  /// - Region encapsulated by BB and its post-dominator can not contain
+  /// unhandled instructions
+  ///   (currently switch instructions)  : FIXME
+  static bool isValidMergeLocation(BasicBlock &BB, DominatorTree &DT,
+                                   PostDominatorTree &PDT);
+
+  /// Returns true if any of blocks L's predecessors are dominated by R
+  /// or any of R's predecessors are dominated by L
+  static bool hasPathBetween(BasicBlock *L, BasicBlock *R, DominatorTree &DT);
+
+
+  /// Computes maximum possible latency reduction achieved by merging
+  /// two blocks in the best case scenario (i.e. everything aligns)
+  static std::pair<unsigned, unsigned>
+  computeLatReductionAtBest(BasicBlock *BB1, BasicBlock *BB2);
+
+  /// Compute the similarity score for two blocks
+  static double computeBlockSimilarity(BasicBlock *BB1, BasicBlock *BB2);
+
+  /// Compute block similarity with region replication
+  static double computeBlockSimilarity(BasicBlock *BB1, BasicBlock *BB2,
+                                       Region *Replicated, function_ref<int()> GetBrCost);
+
+  /// Computes the similarity score for two regions given by 'Mapping'
+  static double
+  computeRegionSimilarity(const DenseMap<BasicBlock *, BasicBlock *> &Mapping,
+                          BasicBlock *LExit);
+
+  /// Given a region tree, returns the region with entry 'Entry' and exit 'Exit'
+  static Region *getRegionWithEntryExit(RegionInfo &RI, BasicBlock *Entry,
+                                        BasicBlock *Exit);
+
+  /// checks if a region need to be simplified. Region R is not simple if it's
+  /// exit has predecessors from outside R
+  static bool requireRegionSimplification(Region *R);
+
+  /// cutomized instruction latency cost (only used for GPU control-flow
+  /// melding)
+  static int getInstructionCost(Instruction *I);
+
+  /// get name as operand for basic block
+  static std::string getNameStr(Value *V);
+
+  /// write a function CFG into a .dot file
+  static void writeCFGToDotFile(Function &F, std::string Prefix = "");
+};
+
+} // namespace llvm
+
+#endif
\ No newline at end of file
diff --git a/llvm/lib/Transforms/CFMelder/CMakeLists.txt b/llvm/lib/Transforms/CFMelder/CMakeLists.txt
new file mode 100644
index 000000000000..7c8d26cd0fd6
--- /dev/null
+++ b/llvm/lib/Transforms/CFMelder/CMakeLists.txt
@@ -0,0 +1,46 @@
+# If we don't need RTTI or EH, there's no reason to export anything
+# from the hello plugin.
+# if( NOT LLVM_REQUIRES_RTTI )
+#   if( NOT LLVM_REQUIRES_EH )
+#       set(LLVM_EXPORTED_SYMBOL_FILE ${CMAKE_CURRENT_SOURCE_DIR}/CFMerger.exports)
+#   endif()
+# endif()
+
+# if(WIN32 OR CYGWIN)
+#   set(LLVM_LINK_COMPONENTS Core Support)
+# endif()
+
+# add_llvm_library( LLVMCFMelderPlugin MODULE BUILDTREE_ONLY
+#     CFMelder.cpp
+#     CFAnalyzer.cpp
+#     CFMelderUtils.cpp 
+#     InstructionMatch.cpp
+
+#   DEPENDS
+#   intrinsics_gen
+#   PLUGIN_TOOL
+#   opt
+#   )
+
+add_llvm_component_library(LLVMCFMelder
+  CFMelder.cpp
+  CFMelderUtils.cpp 
+  RegionAnalyzer.cpp
+  RegionMelder.cpp
+  RegionReplicator.cpp
+
+  ADDITIONAL_HEADER_DIRS
+  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Transforms
+  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Transforms/CFMelder
+
+
+
+  DEPENDS
+  intrinsics_gen
+
+  LINK_COMPONENTS
+  Analysis
+  Core
+  Support
+  )
+
diff --git a/llvm/lib/Transforms/CFMelder/NeedlemanWunsch.h b/llvm/lib/Transforms/CFMelder/NeedlemanWunsch.h
new file mode 100644
index 000000000000..31d074e7add7
--- /dev/null
+++ b/llvm/lib/Transforms/CFMelder/NeedlemanWunsch.h
@@ -0,0 +1,105 @@
+#ifndef __NEEDLEMAN_WUNSCH_H__
+#define __NEEDLEMAN_WUNSCH_H__
+#include "SeqAlignmentUtils.h"
+#include <assert.h>
+#include <functional>
+#include <memory>
+#include <ostream>
+#include <string>
+
+using namespace std;
+
+template <typename elemTy, typename ArrayTy>
+class NeedlemanWunsch
+{
+private:
+  ScoringFunction<elemTy>& CostModel;
+
+  AlignedSeq<elemTy> constructSoln(Matrix &M, ArrayTy &Seq1, ArrayTy &Seq2)
+  {
+    AlignedSeq<elemTy> Result;
+
+    int I = M.getRows() - 1;
+    int J = M.getCols() - 1;
+
+    while (I >= 0 || J >= 0)
+    {
+
+      if (I >= 0 && J >= 0 && M(I, J).getMatch())
+      {
+        AlignedPair<elemTy> Point(&Seq1[I], &Seq2[J]);
+        Result.insert(Result.begin(), Point);
+        I--;
+        J--;
+      }
+      else if (I >= 0 && M(I, J).getDirection() == TOP)
+      {
+        AlignedPair<elemTy> Point(&Seq1[I], nullptr);
+        Result.insert(Result.begin(), Point);
+        I--;
+      }
+      else
+      {
+        AlignedPair<elemTy> Point(nullptr, &Seq2[J]);
+        Result.insert(Result.begin(), Point);
+        J--;
+      }
+    }
+
+    return Result;
+  }
+
+public:
+  NeedlemanWunsch(ScoringFunction<elemTy>& CostModel) : CostModel(CostModel) {}
+
+  AlignedSeq<elemTy> compute(ArrayTy &Seq1, ArrayTy &Seq2)
+  {
+    Matrix M(Seq1.size(), Seq2.size());
+
+    for (int I = -1; I < M.getRows(); I++)
+    {
+      M(I, -1).setCost(-CostModel.gap(0));
+      M(I, -1).setDirection(TOP);
+    }
+    for (int I = -1; I < M.getCols(); I++)
+    {
+      M(-1, I).setCost(-CostModel.gap(0));
+      M(-1, I).setDirection(LEFT);
+    }
+
+    for (unsigned I = 0; I < M.getRows(); ++I)
+    {
+      for (unsigned J = 0; J < M.getCols(); ++J)
+      {
+        int DiagCost = M(I - 1, J - 1).getCost() + CostModel(*(Seq1.begin() + I), *(Seq2.begin() + J));
+        int LeftCost = M(I, J - 1).getCost() - CostModel.gap(0);
+        int TopCost = M(I - 1, J).getCost() - CostModel.gap(0);
+        int Cost = DiagCost;
+        Direction D = DIAG;
+        bool IsMatch = true;
+
+        if (Cost < LeftCost)
+        {
+          D = LEFT;
+          Cost = LeftCost;
+          IsMatch = false;
+        }
+
+        if (Cost < TopCost)
+        {
+          D = TOP;
+          Cost = TopCost;
+          IsMatch = false;
+        }
+
+        M(I, J) = Cell(Cost, D, IsMatch);
+      }
+    }
+
+    // llvm::errs() << M << "\n";
+
+    return constructSoln(M, Seq1, Seq2);
+  }
+};
+
+#endif
\ No newline at end of file
diff --git a/llvm/lib/Transforms/CFMelder/RegionAnalyzer.cpp b/llvm/lib/Transforms/CFMelder/RegionAnalyzer.cpp
new file mode 100644
index 000000000000..f385c82d8243
--- /dev/null
+++ b/llvm/lib/Transforms/CFMelder/RegionAnalyzer.cpp
@@ -0,0 +1,742 @@
+#include "RegionAnalyzer.h"
+#include "SmithWaterman.h"
+#include "llvm/Analysis/RegionInfo.h"
+#include "llvm/CodeGen/DIE.h"
+#include "llvm/IR/BasicBlock.h"
+#include "llvm/MCA/HardwareUnits/RetireControlUnit.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/TableGen/Record.h"
+#include <algorithm>
+#include <memory>
+
+using namespace llvm;
+
+static cl::opt<double> SimilarityThreshold(
+    "cf-merging-similarity-threshold", cl::init(0.2), cl::Hidden,
+    cl::desc(
+        "Minimum similarity required to merge two basicblocks or two regions"));
+
+static cl::opt<bool> PerformGreedyRegionMatch(
+    "use-greedy-region-match", cl::init(false), cl::Hidden,
+    cl::desc("Enable greedy region match in control-flow melding"));
+
+static cl::opt<bool> DisableRegionReplication(
+    "disable-region-replication", cl::init(false), cl::Hidden,
+    cl::desc("Disable replicating regions in control-flow melding"));
+
+static cl::opt<bool>
+    RunBranchFusionOnly("run-branch-fusion-only", cl::init(false), cl::Hidden,
+                        cl::desc("Run branch fusion only, no region-melding"));
+
+void ControlFlowGraphInfo::recompute() {
+  DT.recalculate(getFunction());
+  PDT.recalculate(getFunction());
+
+  LI = std::make_shared<LoopInfo>(DT);
+
+  /// calculate regions
+  DominanceFrontier DF;
+  DF.analyze(DT);
+  RI = std::make_shared<RegionInfo>();
+  RI->recalculate(getFunction(), &DT, &PDT, &DF);
+}
+
+ControlFlowGraphInfo::ControlFlowGraphInfo(Function &F, DominatorTree &DT,
+                                           PostDominatorTree &PDT,
+                                           TargetTransformInfo &TTI)
+    : F(F), DT(DT), PDT(PDT), TTI(TTI) {
+  LI = std::make_shared<LoopInfo>(DT);
+  /// calculate regions
+  DominanceFrontier DF;
+  DF.analyze(DT);
+  RI = std::make_shared<RegionInfo>();
+  RI->recalculate(F, &DT, &PDT, &DF);
+}
+
+bool RegionComparator::compare() {
+  DenseMap<BasicBlock *, int> LabelMapR1;
+  DenseMap<BasicBlock *, int> LabelMapR2;
+  SmallVector<BasicBlock *, 0> StackR1;
+  SmallVector<BasicBlock *, 0> StackR2;
+
+  StackR1.push_back(R1->getEntry());
+  StackR2.push_back(R2->getEntry());
+  // do a parallel DFS traversal
+  while (!StackR1.empty()) {
+    BasicBlock *CurrBlockR1 = StackR1.pop_back_val();
+    BasicBlock *CurrBlockR2 = StackR2.pop_back_val();
+    // num of successors must match
+    if (CurrBlockR1->getTerminator()->getNumSuccessors() !=
+        CurrBlockR2->getTerminator()->getNumSuccessors())
+      return false;
+    // add to map
+    LabelMapR1.insert(
+        std::pair<BasicBlock *, int>(CurrBlockR1, LabelMapR1.size()));
+    LabelMapR2.insert(
+        std::pair<BasicBlock *, int>(CurrBlockR2, LabelMapR2.size()));
+    // update the mapping
+    Mapping.insert(
+        std::pair<BasicBlock *, BasicBlock *>(CurrBlockR1, CurrBlockR2));
+
+    // iterate over all successors
+    for (unsigned I = 0; I < CurrBlockR1->getTerminator()->getNumSuccessors();
+         I++) {
+      BasicBlock *SuccR1 = CurrBlockR1->getTerminator()->getSuccessor(I);
+      BasicBlock *SuccR2 = CurrBlockR2->getTerminator()->getSuccessor(I);
+      // check if we already visited this successor
+      auto ItR1 = LabelMapR1.find(SuccR1);
+      auto ItR2 = LabelMapR2.find(SuccR2);
+
+      int SuccLabelR1 = -1, SuccLabelR2 = -1;
+
+      if (ItR1 != LabelMapR1.end())
+        SuccLabelR1 = ItR1->second;
+
+      if (ItR2 != LabelMapR2.end())
+        SuccLabelR2 = ItR2->second;
+
+      if (SuccLabelR1 != SuccLabelR2)
+        return false;
+
+      // check if exit block is consisitent
+      if ((SuccR1 == R1->getExit() && SuccR2 != R2->getExit()) ||
+          (SuccR1 != R1->getExit() && SuccR2 == R2->getExit()))
+        return false;
+
+      // add succ to stack only if successor is not the exit block and
+      // it is not visited before
+      if (SuccR1 != R1->getExit() && SuccLabelR1 == -1 &&
+          SuccR2 != R2->getExit() && SuccLabelR2 == -1) {
+        StackR1.push_back(SuccR1);
+        StackR2.push_back(SuccR2);
+      }
+    }
+  }
+  return true;
+}
+
+void RegionComparator::getMapping(
+    DenseMap<BasicBlock *, BasicBlock *> &Result) {
+  Result.clear();
+  Result.insert(Mapping.begin(), Mapping.end());
+}
+
+MergeableRegionPair::MergeableRegionPair(Region &R1, Region &R2,
+                                         RegionComparator &Comparator) {
+  LEntry = R1.getEntry();
+  LExit = R1.getExit();
+  REntry = R2.getEntry();
+  RExit = R2.getExit();
+  Comparator.getMapping(this->Mapping);
+  // CalculateSimilarityScore();
+  SimilarityScore = Utils::computeRegionSimilarity(Mapping, LExit);
+  // errs() << "Similarity score : " << similarityScore << "\n";
+}
+
+BasicBlock *MergeableRegionPair::getMatchingRightBb(BasicBlock *BB) {
+  auto It = Mapping.find(BB);
+  assert(It != Mapping.end() && "Matching Right BB is not found for BB");
+  return It->second;
+}
+
+bool MergeableRegionPair::dominates(std::shared_ptr<MergeableRegionPair> &Other,
+                                    DominatorTree &DT) {
+  if (!DT.dominates(getLeftEntry(), Other->getLeftEntry()))
+    return false;
+
+  if (!DT.dominates(getRightEntry(), Other->getRightEntry()))
+    return false;
+
+  return true;
+}
+
+RegionAnalyzer::RegionAnalyzer(BasicBlock *BB, ControlFlowGraphInfo &CFGInfo)
+    : DivergentBB(BB), CFGInfo(CFGInfo) {
+
+  BranchInst *Bi = dyn_cast<BranchInst>(DivergentBB->getTerminator());
+  assert(Bi && Bi->isConditional() &&
+         "Top BB needs to have a conditional branch");
+  DivergentCondition = Bi->getCondition();
+}
+
+void RegionAnalyzer::computeSARegionMatch() {
+  RegionMeldingProfitabilityModel ScoringFunc;
+  auto SMSA =
+      SmithWaterman<Region *, SmallVectorImpl<Region *>, nullptr>(ScoringFunc);
+
+  auto Result = SMSA.compute(LeftRegions, RightRegions);
+  int AlignedReginPairs = 0;
+  for (auto Entry : Result) {
+    Region *L = Entry.getLeft();
+    Region *R = Entry.getRight();
+    if (Entry.match()) {
+      RegionComparator RC(L, R);
+      bool Check = RC.compare();
+      assert(Check && "Aligned regions are not similar!");
+      std::shared_ptr<MergeableRegionPair> RegionPair =
+          std::make_shared<MergeableRegionPair>(*L, *R, RC);
+
+      BestRegionMatch.push_back(RegionPair);
+      AlignedReginPairs++;
+    }
+  }
+
+  INFO << "Number of aligned region pairs : " << AlignedReginPairs << "\n";
+}
+
+void RegionAnalyzer::computeGreedyRegionMatch() {
+  SmallVector<std::shared_ptr<MergeableRegionPair>, 0> MergeableRegionPairs;
+  // case 3 : do a N*N region simlarty check
+  DEBUG << "Performing a N*N region similarity check\n";
+  for (Region *LRegion : LeftRegions) {
+    for (Region *RRegion : RightRegions) {
+      RegionComparator RC(LRegion, RRegion);
+      if (RC.compare()) {
+        std::shared_ptr<MergeableRegionPair> RegionPair =
+            std::make_shared<MergeableRegionPair>(*LRegion, *RRegion, RC);
+
+        // DEBUG << "Regions are similar\n";
+        // DEBUG << *regionPair << "\n";
+        // DEBUG << "Similarity score is " << regionPair->GetSimilarityScore()
+        //       << "\n";
+
+        MergeableRegionPairs.push_back(RegionPair);
+      } else {
+        // DEBUG << "Regions are not similar\n";
+      }
+    }
+  }
+
+  DominatorTree &DT = getCFGInfo().getDomTree();
+  // Sort the mergeable region pairs based on their simlarity
+  auto Comparator = [&](std::shared_ptr<MergeableRegionPair> &RP1,
+                        std::shared_ptr<MergeableRegionPair> &RP2) {
+    if (*RP1 == *RP2) {
+      return RP1->dominates(RP2, DT);
+    }
+    return *RP1 > *RP2;
+  };
+  std::sort(MergeableRegionPairs.begin(), MergeableRegionPairs.end(),
+            Comparator);
+
+  // add the most profitable match first
+  if (MergeableRegionPairs.size() > 0) {
+    BestRegionMatch.push_back(MergeableRegionPairs[0]);
+  }
+
+  // then add next best mergeable pair given that prev best dominates
+  // next best in L and R paths
+  for (unsigned I = 1; I < MergeableRegionPairs.size(); I++) {
+    auto &MRPair = MergeableRegionPairs[I];
+
+    auto &CurrBest = BestRegionMatch[BestRegionMatch.size() - 1];
+
+    if (CurrBest->dominates(MRPair, DT))
+      BestRegionMatch.push_back(MRPair);
+  }
+}
+
+void RegionAnalyzer::computeRegionMatch() {
+
+  BasicBlock *LeftEntry = DivergentBB->getTerminator()->getSuccessor(0);
+  BasicBlock *RightEntry = DivergentBB->getTerminator()->getSuccessor(1);
+
+  // running branch fusion only
+  if (RunBranchFusionOnly) {
+    BasicBlock *LeftUniqueSucc = LeftEntry->getUniqueSuccessor();
+    BasicBlock *RightUniqueSucc = RightEntry->getUniqueSuccessor();
+    if (LeftUniqueSucc && RightUniqueSucc &&
+        LeftUniqueSucc == RightUniqueSucc) {
+      BestBbMatchSimilarityScore =
+          Utils::computeBlockSimilarity(LeftEntry, RightEntry);
+      DEBUG << "Branch fusion can be applied to basic blocks ";
+      LeftEntry->printAsOperand(errs(), false);
+      errs() << ", ";
+      RightEntry->printAsOperand(errs(), false);
+      errs() << ", similarity score" << BestBbMatchSimilarityScore << "\n";
+      BestBbMatch.first = LeftEntry;
+      BestBbMatch.second = RightEntry;
+      HasBbMatch = true;
+    }
+    return;
+  }
+
+  // find the regions on left and right paths
+  findMergeableRegions(*DivergentBB);
+
+  // Case 1 : No regions found. L and R paths have single BB
+  if (LeftRegions.empty() && RightRegions.empty()) {
+    BestBbMatchSimilarityScore =
+        Utils::computeBlockSimilarity(LeftEntry, RightEntry);
+    DEBUG << "Basic blocks ";
+    LeftEntry->printAsOperand(errs(), false);
+    errs() << ", ";
+    RightEntry->printAsOperand(errs(), false);
+    errs() << " can be melded, similarity score " << BestBbMatchSimilarityScore
+           << "\n";
+
+    BestBbMatch.first = LeftEntry;
+    BestBbMatch.second = RightEntry;
+    HasBbMatch = true;
+    return;
+  }
+
+  // Case 2 : L or R path has single BB
+  if (LeftRegions.empty() || RightRegions.empty()) {
+
+    if (LeftRegions.empty()) {
+      BestBbMatch.first = LeftEntry;
+    }
+    if (RightRegions.empty()) {
+      BestBbMatch.second = RightEntry;
+    }
+
+    PostDominatorTree &PDT = getCFGInfo().getPostDomTree();
+    SmallVector<BasicBlock *, 8> MergeableBlocks;
+    BasicBlock *IPDom = PDT.getNode(DivergentBB)->getIDom()->getBlock();
+
+    assert(IPDom && "No IPDOM for divergent branch! This case is not handled");
+
+    Region *ReplicatedRegion = nullptr;
+
+    if (!BestBbMatch.first) {
+      assert(LeftRegions.size() > 0 && BestBbMatch.second);
+      findMergeableBBsInRegions(LeftEntry, LeftRegions, MergeableBlocks);
+      if (MergeableBlocks.size()) {
+        BestBbMatch.first =
+            findMostSimilarBb(BestBbMatch.second, MergeableBlocks);
+
+        for (auto *R : LeftRegions) {
+          if (R->contains(BestBbMatch.first)) {
+            ReplicatedRegion = R;
+            break;
+          }
+        }
+      }
+    }
+
+    if (!BestBbMatch.second) {
+      assert(RightRegions.size() > 0 && BestBbMatch.first);
+      MergeableBlocks.clear();
+      findMergeableBBsInRegions(RightEntry, RightRegions, MergeableBlocks);
+      if (MergeableBlocks.size()) {
+        BestBbMatch.second =
+            findMostSimilarBb(BestBbMatch.first, MergeableBlocks);
+        for (auto *R : RightRegions) {
+          if (R->contains(BestBbMatch.second)) {
+            ReplicatedRegion = R;
+            break;
+          }
+        }
+      }
+    }
+
+    // if profitable match is found
+    if (BestBbMatch.first && BestBbMatch.second) {
+      HasBbMatch = true;
+
+      BasicBlock *L = BestBbMatch.first;
+      BasicBlock *R = BestBbMatch.second;
+
+      DEBUG << "Block to region melding is possible with blocks "
+            << Utils::getNameStr(L) << ", " << Utils::getNameStr(R) << "\n";
+
+      if (requireRegionReplication()) {
+        // utility function to get branch cost
+        auto GetBrCost = [&]() -> int {
+          return getCFGInfo()
+              .getTTI()
+              .getCFInstrCost(Instruction::Br, TTI::TCK_CodeSize)
+              .getValue()
+              .getValue();
+        };
+        DEBUG << "Melding requires region replication\n";
+        BestBbMatchSimilarityScore = Utils::computeBlockSimilarity(
+            BestBbMatch.first, BestBbMatch.second, ReplicatedRegion, GetBrCost);
+            // BestBbMatch.first, BestBbMatch.second);
+
+      } else {
+        BestBbMatchSimilarityScore = Utils::computeBlockSimilarity(
+            BestBbMatch.first, BestBbMatch.second);
+      }
+
+      DEBUG << "Similarity score = " << BestBbMatchSimilarityScore << "\n";
+    }
+
+    return;
+  }
+  if (PerformGreedyRegionMatch)
+    computeGreedyRegionMatch();
+  else
+    computeSARegionMatch();
+
+  DEBUG << "Region pairs in profitabilty order  \n";
+  for (unsigned I = 0; I < BestRegionMatch.size(); ++I) {
+    auto BestPair = BestRegionMatch[I];
+    DEBUG << *BestPair
+          << ", similarity score = " << BestPair->getSimilarityScore() << "\n";
+  }
+}
+
+BasicBlock *
+RegionAnalyzer::findMostSimilarBb(BasicBlock *BB,
+                                  SmallVectorImpl<BasicBlock *> &Candidates) {
+  assert(Candidates.size() > 0 && "empty basicblock candidate list!");
+  BasicBlock *MostSimilar = Candidates[0];
+  double BestScore = Utils::computeBlockSimilarity(BB, MostSimilar);
+  // MergeableRegionPair::ComputeBBSimilarity(BB, candidates[0]);
+  for (BasicBlock *Candidate : Candidates) {
+    double Score = Utils::computeBlockSimilarity(BB, Candidate);
+    if (Score > BestScore) {
+      MostSimilar = Candidate;
+      BestScore = Score;
+    }
+  }
+
+  return MostSimilar;
+}
+
+// check if region list is in dominance order
+bool verifyRegionList(SmallVectorImpl<Region *> &Regions, DominatorTree &DT) {
+  for (auto It = Regions.begin(); It != Regions.end(); It++) {
+    // check if the list is in dominance order
+    if ((It + 1) != Regions.end()) {
+      Region *Curr = *It;
+      Region *Next = *(It + 1);
+      if (!DT.dominates(Curr->getEntry(), Next->getEntry()))
+        return false;
+    }
+  }
+  return true;
+}
+
+void printRegionList(SmallVectorImpl<Region *> &Regions, DominatorTree &DT) {
+  for (auto It = Regions.begin(); It != Regions.end(); It++) {
+
+    errs() << "[ ";
+    (*It)->getEntry()->printAsOperand(errs(), false);
+    errs() << " : ";
+    (*It)->getExit()->printAsOperand(errs(), false);
+    errs() << " ]";
+  }
+}
+
+void RegionAnalyzer::findMergeableBBsInRegions(
+    BasicBlock *From, SmallVectorImpl<Region *> &Regions,
+    SmallVectorImpl<BasicBlock *> &MergeableBBs) {
+
+  auto LI = getCFGInfo().getLoopInfo();
+  auto &DT = getCFGInfo().getDomTree();
+  auto &PDT = getCFGInfo().getPostDomTree();
+
+  auto IsInsideLoop = [&](BasicBlock *BB) -> bool {
+    Loop *LoopOfBB = LI->getLoopFor(BB);
+    if (LoopOfBB) {
+      BasicBlock *LoopHeader = LoopOfBB->getHeader();
+      if (DT.dominates(From, LoopHeader))
+        return true;
+    }
+    return false;
+  };
+  // any basic block containd in the regions is a valid location to merge
+  // including their exits
+  for (Region *R : Regions) {
+    for (auto *Cand : R->blocks()) {
+      // FIXME : avoid merging with basic blocks inside loops
+      // if region replication is not allowed, basic blocks that post dominates
+      // From can be a meld candidate
+      if (!IsInsideLoop(Cand)) {
+        if (DisableRegionReplication) {
+          if (PDT.dominates(Cand, From))
+            MergeableBBs.push_back(Cand);
+        } else {
+          MergeableBBs.push_back(Cand);
+        }
+      }
+    }
+    // // check region exit
+    // BasicBlock* Exit = R->getExit();
+    // if (!IsInsideLoop(Exit)){
+    //   MergeableBBs.push_back(Exit);
+    // }
+  }
+}
+
+void RegionAnalyzer::findMergeableRegions(BasicBlock &BB) {
+  auto RI = getCFGInfo().getRegionInfo();
+  DominatorTree &DT = getCFGInfo().getDomTree();
+  PostDominatorTree &PDT = getCFGInfo().getPostDomTree();
+
+  Region *R = RI->getRegionFor(&BB);
+
+  assert(BB.getTerminator()->getNumSuccessors() == 2 &&
+         "CFMelder : Entry block must have 2 successors!");
+
+  BasicBlock *LeftEntry = BB.getTerminator()->getSuccessor(0);
+  BasicBlock *RightEntry = BB.getTerminator()->getSuccessor(1);
+
+  SmallVector<Region *, 0> VisitedRegions;
+
+  // get all direct children of R and split them L and R paths
+  // regions are added to L  and R lists based on dominance order
+  for (auto It = R->begin(); It != R->end(); It++) {
+    Region &SubR = **It;
+
+    // if sub region is not direct child of R skip
+    if (SubR.getParent() != R)
+      continue;
+
+    BasicBlock *EntryBb = SubR.getEntry();
+
+    // check if this region beglongs to left or right paths
+    if (DT.dominates(LeftEntry, EntryBb) && PDT.dominates(EntryBb, LeftEntry)) {
+
+      auto ItLR = LeftRegions.begin();
+      for (; ItLR != LeftRegions.end(); ItLR++) {
+        if (DT.dominates(EntryBb, (*ItLR)->getEntry()))
+          break;
+      }
+
+      LeftRegions.insert(ItLR, &SubR);
+    }
+
+    if (DT.dominates(RightEntry, EntryBb) &&
+        PDT.dominates(EntryBb, RightEntry)) {
+      // add regions based on dominance order
+      auto ItRR = RightRegions.begin();
+      for (; ItRR != RightRegions.end(); ItRR++) {
+        if (DT.dominates(EntryBb, (*ItRR)->getEntry()))
+          break;
+      }
+      RightRegions.insert(ItRR, &SubR);
+    }
+  }
+
+#ifdef CFMELDER_DEBUG
+  DEBUG << "Left regions : ";
+  printRegionList(LeftRegions, DT);
+  errs() << "\n";
+  DEBUG << "Right regions : ";
+  printRegionList(RightRegions, DT);
+  errs() << "\n";
+#endif
+
+  // verify dominance order
+  assert(verifyRegionList(LeftRegions, DT) &&
+         "Left regions are not in dominance order!");
+  assert(verifyRegionList(RightRegions, DT) &&
+         "Right regions are not in dominance order!");
+}
+
+unsigned RegionAnalyzer::regionMatchSize() const {
+  if (HasBbMatch)
+    return 1;
+  return BestRegionMatch.size();
+}
+
+std::pair<BasicBlock *, BasicBlock *>
+RegionAnalyzer::getRegionMatchEntryBlocks(unsigned I) {
+
+  if (HasBbMatch)
+    return BestBbMatch;
+  std::shared_ptr<MergeableRegionPair> RP = BestRegionMatch[I];
+
+  return std::pair<BasicBlock *, BasicBlock *>(RP->getLeftEntry(),
+                                               RP->getRightEntry());
+}
+
+std::pair<BasicBlock *, BasicBlock *>
+RegionAnalyzer::getRegionMatchExitBlocks(unsigned I) {
+  // for single BB match exit block is null
+  if (HasBbMatch)
+    return std::pair<BasicBlock *, BasicBlock *>(nullptr, nullptr);
+  std::shared_ptr<MergeableRegionPair> RP = BestRegionMatch[I];
+
+  return std::pair<BasicBlock *, BasicBlock *>(RP->getLeftExit(),
+                                               RP->getRightExit());
+}
+
+DenseMap<BasicBlock *, BasicBlock *>
+RegionAnalyzer::getRegionMatch(unsigned I) {
+  DenseMap<BasicBlock *, BasicBlock *> BbMap;
+
+  if (HasBbMatch) {
+    assert(I == 0 && "only one basicblock match is expected");
+    BbMap.insert(BestBbMatch);
+    return BbMap;
+  }
+
+  assert(I < BestRegionMatch.size() &&
+         "requested list index is greater than its size!");
+
+  std::shared_ptr<MergeableRegionPair> RP = BestRegionMatch[I];
+
+  SmallVector<BasicBlock *, 0> WorkList;
+  SmallVector<BasicBlock *, 0> VisitedBBs;
+  WorkList.push_back(RP->getLeftEntry());
+
+  while (!WorkList.empty()) {
+    BasicBlock *CurrLeftBb = WorkList.pop_back_val();
+    BasicBlock *MatchingRightBb = RP->getMatchingRightBb(CurrLeftBb);
+
+    // add to map
+    BbMap.insert(
+        std::pair<BasicBlock *, BasicBlock *>(CurrLeftBb, MatchingRightBb));
+
+    // this block is visited
+    VisitedBBs.push_back(CurrLeftBb);
+    // add all in-region successors to worklist
+    for (unsigned I = 0; I < CurrLeftBb->getTerminator()->getNumSuccessors();
+         I++) {
+      BasicBlock *Succ = CurrLeftBb->getTerminator()->getSuccessor(I);
+      if (Succ != RP->getLeftExit() &&
+          std::find(VisitedBBs.begin(), VisitedBBs.end(), Succ) ==
+              VisitedBBs.end())
+        WorkList.push_back(Succ);
+    }
+  }
+
+  // add matching exit blocks
+  BbMap.insert(std::pair<BasicBlock *, BasicBlock *>(RP->getLeftExit(),
+                                                     RP->getRightExit()));
+
+  return BbMap;
+}
+
+// if the region's exit has predecessors from outside the region
+// region needs a simplification
+bool RegionAnalyzer::requireRegionSimplification(Region *R) {
+  BasicBlock *Exit = R->getExit();
+  for (auto PredIt = pred_begin(Exit); PredIt != pred_end(Exit); ++PredIt) {
+    BasicBlock *Pred = *PredIt;
+    if (!R->contains(Pred))
+      return true;
+  }
+  return false;
+}
+
+// this function checks if the melding requires a region replication
+// this occurs when we have to do a BB-Region meld.
+// The matching basic block is inside the region but it does not post-dominate
+// the entry.
+bool RegionAnalyzer::requireRegionReplication() {
+  if (!HasBbMatch)
+    return false;
+  BasicBlock *L = BestBbMatch.first;
+  BasicBlock *R = BestBbMatch.second;
+  BasicBlock *LeftEntry = DivergentBB->getTerminator()->getSuccessor(0);
+  BasicBlock *RightEntry = DivergentBB->getTerminator()->getSuccessor(1);
+  PostDominatorTree &PDT = getCFGInfo().getPostDomTree();
+
+  return !PDT.dominates(L, LeftEntry) || !PDT.dominates(R, RightEntry);
+}
+
+unsigned RegionAnalyzer::getMostProfitableRegionMatchIndex() {
+  if (HasBbMatch)
+    return 0;
+
+  double MaxProfit = 0.0;
+  unsigned MaxIndex = 0;
+  for (unsigned I = 0; I < BestRegionMatch.size(); I++) {
+    if (BestRegionMatch[I]->getSimilarityScore() > MaxProfit) {
+      MaxIndex = I;
+      MaxProfit = BestRegionMatch[I]->getSimilarityScore();
+    }
+  }
+  return MaxIndex;
+}
+
+bool RegionAnalyzer::hasAnyProfitableMatch() {
+  if (HasBbMatch) {
+    // FIXME : if this requires region replication we need to be careful about
+    // store instructions. avoid doing RR is stroe instructions are present in
+    // other blocks for now
+    // if (requireRegionReplication()) {
+    //   Region *ReplicateR = nullptr;
+    //   BasicBlock* BBInsideRegion = nullptr;
+    //   BasicBlock *L = BestBbMatch.first;
+    //   BasicBlock *R = BestBbMatch.second;
+    //   BasicBlock *LeftEntry = DivergentBB->getTerminator()->getSuccessor(0);
+    //   BasicBlock *RightEntry = DivergentBB->getTerminator()->getSuccessor(1);
+
+    //   if (getPDT()->dominates(L, LeftEntry)) {
+    //     ReplicateR = getRI()->getRegionFor(R);
+    //     BBInsideRegion = R;
+    //   }
+    //   else {
+    //     ReplicateR = getRI()->getRegionFor(L);
+    //     BBInsideRegion = L;
+
+    //   }
+
+    //   // check if replicated region contains store instructions outside the
+    //   melded blocks
+    //   // if it does don't meld for now
+    //   for(auto *BB : ReplicateR->blocks()){
+    //     if (BB == BBInsideRegion) continue;
+    //     for (auto &I : *BB) {
+    //       if(isa<StoreInst>(&I)) {
+    //         DEBUG << "Replicated region contains store instructions outside
+    //         melded block, no melding performed!\n"; return false;
+    //       }
+    //     }
+    //   }
+
+    // }
+
+    // if merging 2 basic blocks, avoid merging single branch blocks (size > 1)
+    return BestBbMatchSimilarityScore >= SimilarityThreshold &&
+           (BestBbMatch.first->size() > 1 && BestBbMatch.second->size() > 1);
+  }
+
+  if (BestRegionMatch.size() > 0) {
+    for (auto &RegionPair : BestRegionMatch) {
+      if (RegionPair->getSimilarityScore() >= SimilarityThreshold)
+        return true;
+    }
+  }
+
+  return false;
+}
+
+bool RegionAnalyzer::isRegionMatchProfitable(unsigned Index) {
+  assert(Index < regionMatchSize() && "Region match index out of bounds!");
+  if (HasBbMatch) {
+    return hasAnyProfitableMatch();
+  }
+  return BestRegionMatch[Index]->getSimilarityScore() >= SimilarityThreshold;
+}
+
+void RegionAnalyzer::printAnalysis(llvm::raw_ostream &Os) {
+  if (HasBbMatch) {
+    Os << "Similarity Score : " << BestBbMatchSimilarityScore << "\n";
+    Os << "Merge at BB level : \n"
+       << "   merging BB ";
+    BestBbMatch.first->printAsOperand(Os, false);
+    Os << " with  ";
+    BestBbMatch.second->printAsOperand(errs(), false);
+    Os << "   requires " << (requireRegionReplication() ? "" : " no ")
+       << "region replication\n";
+
+  } else if (BestRegionMatch.size() > 0) {
+    Os << "Merge at REGION level : \n";
+    for (unsigned I = 0; I < BestRegionMatch.size(); I++) {
+      Os << "Index : " << I << "\n";
+      Os << "Similarity Score : " << BestRegionMatch[I]->getSimilarityScore()
+         << "\n"
+         << "   merging region entry ";
+      BestRegionMatch[I]->getLeftEntry()->printAsOperand(errs(), false);
+      Os << " with "
+         << " region entry ";
+      BestRegionMatch[I]->getRightEntry()->printAsOperand(errs(), false);
+      Os << "\n"
+         << "   merging region exit ";
+      BestRegionMatch[I]->getLeftExit()->printAsOperand(errs(), false);
+      Os << " with "
+         << " region exit ";
+      BestRegionMatch[I]->getRightExit()->printAsOperand(errs(), false);
+      Os << "\n";
+    }
+  }
+}
\ No newline at end of file
diff --git a/llvm/lib/Transforms/CFMelder/RegionAnalyzer.h b/llvm/lib/Transforms/CFMelder/RegionAnalyzer.h
new file mode 100644
index 000000000000..572249c8e4ab
--- /dev/null
+++ b/llvm/lib/Transforms/CFMelder/RegionAnalyzer.h
@@ -0,0 +1,197 @@
+#ifndef LLVM_LIB_TRANSFORMS_REGION_ANALYZER_H
+#define LLVM_LIB_TRANSFORMS_REGION_ANALYZER_H
+
+#include "CFMelderUtils.h"
+#include "SeqAlignmentUtils.h"
+#include "llvm/Analysis/DominanceFrontier.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/RegionInfo.h"
+#include "llvm/Analysis/TargetTransformInfo.h"
+#include "llvm/IR/BasicBlock.h"
+#include "llvm/IR/Function.h"
+
+namespace llvm {
+
+/// convienience object to pass control-flow info around
+class ControlFlowGraphInfo {
+private:
+  Function &F;
+  DominatorTree &DT;
+  PostDominatorTree &PDT;
+  TargetTransformInfo &TTI;
+  std::shared_ptr<RegionInfo> RI;
+  std::shared_ptr<LoopInfo> LI;
+
+public:
+  ControlFlowGraphInfo(Function &F, DominatorTree &DT, PostDominatorTree &PDT,
+                       TargetTransformInfo &TTI);
+  /// recompute analyses
+  void recompute();
+  ///
+  Function &getFunction() { return F; }
+  /// get dom tree
+  DominatorTree &getDomTree() { return DT; }
+  /// get post-dom tree
+  PostDominatorTree &getPostDomTree() { return PDT; }
+  /// get region info
+  shared_ptr<RegionInfo> getRegionInfo() { return RI; }
+  /// get loop info
+  shared_ptr<LoopInfo> getLoopInfo() { return LI; }
+  /// get TTI
+  TargetTransformInfo &getTTI() { return TTI; }
+};
+
+class RegionComparator {
+private:
+  const Region *R1;
+  const Region *R2;
+  DenseMap<BasicBlock *, BasicBlock *> Mapping;
+
+public:
+  RegionComparator(const Region *R1, const Region *R2) : R1(R1), R2(R2) {}
+  // compare two regions, return true if they have equal control flow
+  bool compare();
+  // get the region mapping if exists
+  void getMapping(DenseMap<BasicBlock *, BasicBlock *> &Result);
+};
+
+class MergeableRegionPair {
+private:
+  // Region *R1, *R2; // R1 == left, R2 == right
+  BasicBlock *LEntry = nullptr, *LExit = nullptr;
+  BasicBlock *REntry = nullptr, *RExit = nullptr;
+  double SimilarityScore{0.0};
+  DenseMap<BasicBlock *, BasicBlock *> Mapping;
+
+  // void CalculateSimilarityScore();
+
+public:
+  MergeableRegionPair(Region &R1, Region &R2, RegionComparator &Comparator);
+
+  double getSimilarityScore() const { return SimilarityScore; }
+
+  bool operator<(const MergeableRegionPair &RegionPair) {
+    return this->SimilarityScore < RegionPair.getSimilarityScore();
+  }
+
+  bool operator>(const MergeableRegionPair &RegionPair) {
+    return this->SimilarityScore > RegionPair.getSimilarityScore();
+  }
+
+  bool operator==(const MergeableRegionPair &RegionPair) {
+    return this->SimilarityScore == RegionPair.getSimilarityScore();
+  }
+
+  friend llvm::raw_ostream &operator<<(llvm::raw_ostream &OS,
+                                       MergeableRegionPair &MRP) {
+    OS << "[ Left entry : " << MRP.getLeftEntry()->getName()
+       << ", Left exit : " << MRP.getLeftExit()->getName()
+       << ", Right entry : " << MRP.getRightEntry()->getName()
+       << ", Right exit : " << MRP.getRightExit()->getName() << " ]";
+    return OS;
+  }
+
+  // returns true if R1 dominates other.R1 and R2 dominates other.R2
+  // i.e. this and other can be independantly mergeable
+  bool dominates(std::shared_ptr<MergeableRegionPair> &Other,
+                 DominatorTree &DT);
+
+  BasicBlock *getLeftEntry() { return LEntry; }
+  BasicBlock *getLeftExit() { return LExit; }
+
+  BasicBlock *getRightEntry() { return REntry; }
+  BasicBlock *getRightExit() { return RExit; }
+
+  DenseMap<BasicBlock *, BasicBlock *>::iterator begin() {
+    return Mapping.begin();
+  }
+  DenseMap<BasicBlock *, BasicBlock *>::iterator end() { return Mapping.end(); }
+
+  BasicBlock *getMatchingRightBb(BasicBlock *BB);
+};
+
+struct RegionMeldingProfitabilityModel : public ScoringFunction<Region *> {
+public:
+  int operator()(Region *R1, Region *R2) override {
+    RegionComparator RC(R1, R2);
+    if (!RC.compare())
+      return 0;
+    DenseMap<BasicBlock *, BasicBlock *> Mapping;
+    RC.getMapping(Mapping);
+    double Score = Utils::computeRegionSimilarity(Mapping, R1->getExit());
+
+    return (int)(Score * 100);
+  }
+  int gap(int K) override { return 0; }
+};
+
+// class to analyze merebale control-flow
+class RegionAnalyzer {
+private:
+  BasicBlock *DivergentBB;
+  Value *DivergentCondition;
+  ControlFlowGraphInfo &CFGInfo;
+
+  // left path and right path regions
+  SmallVector<Region *, 0> LeftRegions;
+  SmallVector<Region *, 0> RightRegions;
+
+  // best matching of regions
+  SmallVector<std::shared_ptr<MergeableRegionPair>, 0> BestRegionMatch;
+  // best mathcing basic blocks, if regions do not exist
+  std::pair<BasicBlock *, BasicBlock *> BestBbMatch{nullptr, nullptr};
+  bool HasBbMatch = false;
+  double BestBbMatchSimilarityScore = 0.0;
+
+  void findMergeableRegions(BasicBlock &BB);
+  BasicBlock *findMostSimilarBb(BasicBlock *BB,
+                                SmallVectorImpl<BasicBlock *> &Candidates);
+  /// Find mergeable blocks in 'Regions' that are not contained inside local
+  /// loops
+  void findMergeableBBsInRegions(BasicBlock *From,
+                                 SmallVectorImpl<Region *> &Regions,
+                                 SmallVectorImpl<BasicBlock *> &MergeableBBs);
+
+  void computeGreedyRegionMatch();
+  void computeSARegionMatch();
+
+public:
+  RegionAnalyzer(BasicBlock *BB, ControlFlowGraphInfo &CFGInfo);
+
+  void computeRegionMatch();
+
+  // region analyzer's result
+  DenseMap<BasicBlock *, BasicBlock *> getRegionMatch(unsigned Index);
+  std::pair<BasicBlock *, BasicBlock *>
+  getRegionMatchEntryBlocks(unsigned Index);
+  std::pair<BasicBlock *, BasicBlock *>
+  getRegionMatchExitBlocks(unsigned Index);
+  // bool isInsideRegionMatch(BasicBlock *BB, unsigned Index);
+  bool hasAnyProfitableMatch();
+  bool isRegionMatchProfitable(unsigned Index);
+  unsigned regionMatchSize() const;
+  unsigned getMostProfitableRegionMatchIndex();
+
+  // region replication, only applicable for BB-region melding
+  bool requireRegionReplication();
+
+  bool requireRegionSimplification(Region *R);
+
+  /// infomation about divergent region
+  Value *getDivergentCondition() const { return DivergentCondition; }
+
+  BasicBlock *getDivergentBlock() const { return DivergentBB; }
+
+  Function *getParentFunction() const {
+    return getDivergentBlock()->getParent();
+  }
+
+  /// control-flow analysis
+  ControlFlowGraphInfo &getCFGInfo() { return CFGInfo; }
+
+  void printAnalysis(llvm::raw_ostream &OS);
+};
+
+} // namespace llvm
+
+#endif
\ No newline at end of file
diff --git a/llvm/lib/Transforms/CFMelder/RegionMelder.cpp b/llvm/lib/Transforms/CFMelder/RegionMelder.cpp
new file mode 100644
index 000000000000..1a7e722aa16b
--- /dev/null
+++ b/llvm/lib/Transforms/CFMelder/RegionMelder.cpp
@@ -0,0 +1,1259 @@
+#include "RegionMelder.h"
+#include "CFMelderUtils.h"
+#include "RegionReplicator.h"
+#include "SeqAlignmentUtils.h"
+#include "llvm/ADT/CachedHashString.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/iterator_range.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/Value.h"
+#include "llvm/IR/Verifier.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+#include <chrono>
+#include <string>
+
+using namespace llvm;
+#define ENABLE_TIMING 1
+
+#define DEBUG_TYPE "cfmelder"
+
+static cl::opt<bool> DisableMelding(
+    "disable-melding", cl::init(false), cl::Hidden,
+    cl::desc("Disables melding step, runs region simplification if required"));
+
+static cl::opt<bool> EnableFullPredication(
+    "enable-full-predication", cl::init(false), cl::Hidden,
+    cl::desc("Enable full predication for merged blocks"));
+
+static cl::opt<bool> UseLatencyCostModel(
+    "use-latency-for-alignment", cl::init(false), cl::Hidden,
+    cl::desc("Use latency cost model for instruction alignment"));
+
+static cl::opt<bool>
+    DumpSeqAlignStats("dump-seq-align-stats", cl::init(false), cl::Hidden,
+                      cl::desc("Dump information on sequence alignment"));
+
+STATISTIC(NumMeldings, "Number of profitable meldings performed");
+STATISTIC(BBToBBMeldings,
+          "Number of profitable basic block to basic block meldings");
+STATISTIC(BBToRegionMeldings,
+          "Number of profitable basic block to region meldings");
+STATISTIC(RegionToRegionMeldings,
+          "Number of profitable region to region meldings");
+STATISTIC(InstrAlignTime,
+          "Time spent in instruction alignment in microseconds");
+
+AlignedSeq<Value *>
+RegionMelder::getAlignmentOfBlocks(BasicBlock *LeftBb, BasicBlock *RightBb,
+                                   ScoringFunction<Value *> &ScoringFunc) {
+  // do sequence aligment
+  SmallVector<Value *, 32> LSeq;
+  SmallVector<Value *, 32> RSeq;
+  linearizeBb(LeftBb, LSeq);
+  linearizeBb(RightBb, RSeq);
+
+  auto SMSA =
+      SmithWaterman<Value *, SmallVectorImpl<Value *>, nullptr>(ScoringFunc);
+
+  auto Result = SMSA.compute(LSeq, RSeq);
+
+  return Result;
+}
+
+void RegionMelder::computeRegionSeqAlignment(
+    DenseMap<BasicBlock *, BasicBlock *> BbMap) {
+
+  shared_ptr<ScoringFunction<Value *>> ScoringFuncSize =
+      make_shared<CodeSizeCostModel>(MA.getCFGInfo().getTTI());
+  shared_ptr<ScoringFunction<Value *>> ScoringFuncLat =
+      make_shared<GPULatencyCostModel>();
+
+  auto ScoringFunc = UseLatencyCostModel ? ScoringFuncLat : ScoringFuncSize;
+
+  for (auto It = BbMap.begin(); It != BbMap.end(); It++) {
+    BasicBlock *LBB = It->first;
+    BasicBlock *RBB = It->second;
+
+    RegionInstrAlignement.concat(getAlignmentOfBlocks(LBB, RBB, *ScoringFunc));
+  }
+  if (DumpSeqAlignStats) {
+
+    int SavedCycles = 0;
+    for (auto Entry : RegionInstrAlignement) {
+      Value *Left = Entry.getLeft();
+      Value *Right = Entry.getRight();
+      if (Left && Right) {
+        if (isa<BasicBlock>(Left))
+          continue;
+        SavedCycles += (*ScoringFunc)(Left, Right);
+      } else {
+        SavedCycles -= (*ScoringFunc).gap(0);
+      }
+    }
+    INFO << "Number of cycles saved by alignment : " << SavedCycles << "\n";
+  }
+}
+
+bool requireUnpredication(BasicBlock *Current, BasicBlock *Corresponding) {
+  // if current contains instructions with side effetcs we need to unpredicate
+  // these include stores, calls and divisions
+  for (auto &I : *Current) {
+    if (I.mayHaveSideEffects()) {
+      return true;
+    }
+  }
+  return Corresponding->size() > 1;
+}
+
+void RegionMelder::cloneInstructions() {
+  INFO << "Cloning instructions\n";
+  // generate the control flow for merged region
+  IRBuilder<> Builder(&MA.getParentFunction()->getEntryBlock());
+  for (auto &Entry : RegionInstrAlignement) {
+
+    Value *LEntry = Entry.get(0);
+    Value *REntry = Entry.get(1);
+    if (Entry.match()) {
+      if (isa<BasicBlock>(LEntry)) {
+        assert(isa<BasicBlock>(REntry) &&
+               "Both matching entries must be basic blocks");
+        BasicBlock *NewBb =
+            BasicBlock::Create(MA.getParentFunction()->getContext(),
+                               "merged.bb", MA.getParentFunction());
+        // update value map
+        MergedValuesToLeftValues[NewBb] = LEntry;
+        MergedValuesToRightValues[NewBb] = REntry;
+
+        BasicBlock *LeftBb = dyn_cast<BasicBlock>(LEntry);
+        BasicBlock *RightBb = dyn_cast<BasicBlock>(REntry);
+        // update label map
+        LeftBbToMergedBb[LeftBb] = NewBb;
+        RightBbToMergedBb[RightBb] = NewBb;
+
+        for (auto &I : *dyn_cast<BasicBlock>(LEntry)) {
+          if (isa<PHINode>(&I)) {
+            Instruction *NewI = cloneInstruction(&I, Builder);
+            MergedValuesToLeftValues[NewI] = &I;
+            OrigToMergedValues[&I] = NewI;
+            MergedInstructions.push_back(NewI);
+          }
+        }
+
+        for (auto &I : *dyn_cast<BasicBlock>(REntry)) {
+          if (isa<PHINode>(&I)) {
+            Instruction *NewI = cloneInstruction(&I, Builder);
+            MergedValuesToRightValues[NewI] = &I;
+            OrigToMergedValues[&I] = NewI;
+            MergedInstructions.push_back(NewI);
+          }
+        }
+        // add to merged blocks
+        MergedBBs.push_back(NewBb);
+
+      } else {
+        assert(isa<Instruction>(LEntry) && isa<Instruction>(REntry) &&
+               "Both entries must be instructions");
+        // skip phi nodes
+        if (!isa<PHINode>(LEntry)) {
+          Instruction *LeftI = dyn_cast<Instruction>(LEntry);
+          Instruction *RightI = dyn_cast<Instruction>(REntry);
+
+          Instruction *NewI = cloneInstruction(LeftI, Builder);
+
+          // update the maps
+          MergedValuesToLeftValues[NewI] = LeftI;
+          MergedValuesToRightValues[NewI] = RightI;
+          OrigToMergedValues[LeftI] = NewI;
+          OrigToMergedValues[RightI] = NewI;
+
+          MergedInstructions.push_back(NewI);
+        }
+      }
+    } else {
+      if (LEntry != nullptr && !isa<PHINode>(LEntry)) {
+        Instruction *LeftI = dyn_cast<Instruction>(LEntry);
+        Instruction *NewI = cloneInstruction(LeftI, Builder);
+        // update map
+        MergedValuesToLeftValues[NewI] = LeftI;
+        OrigToMergedValues[LeftI] = NewI;
+        MergedInstructions.push_back(NewI);
+
+        // update splitRanges
+        // unpredication is not done if one the blocks is just a branch, occurs
+        // in region replication
+        auto ClonedRightParentIt =
+            MergedValuesToRightValues.find(NewI->getParent());
+        assert(ClonedRightParentIt != MergedValuesToRightValues.end() &&
+               "Cloned left BB not found for right value!");
+        // if (cast<BasicBlock>(ClonedRightParentIt->second)->size() > 1)
+        if (requireUnpredication(LeftI->getParent(),
+                                 cast<BasicBlock>(ClonedRightParentIt->second)))
+          updateSplitRangeMap(true, NewI);
+      }
+
+      if (REntry != nullptr && !isa<PHINode>(REntry)) {
+        Instruction *RightI = dyn_cast<Instruction>(REntry);
+        Instruction *NewI = cloneInstruction(RightI, Builder);
+        // update map
+        MergedValuesToRightValues[NewI] = RightI;
+        OrigToMergedValues[RightI] = NewI;
+        MergedInstructions.push_back(NewI);
+
+        // update splitRanges
+        // unpredication is not done if one the blocks is just a branch, occurs
+        // in region replication
+        auto ClonedLeftParentIt =
+            MergedValuesToLeftValues.find(NewI->getParent());
+        assert(ClonedLeftParentIt != MergedValuesToLeftValues.end() &&
+               "Cloned left BB not found for right value!");
+        // if (cast<BasicBlock>(ClonedLeftParentIt->second)->size() > 1)
+        if (requireUnpredication(RightI->getParent(),
+                                 cast<BasicBlock>(ClonedLeftParentIt->second)))
+          updateSplitRangeMap(false, NewI);
+      }
+    }
+  }
+}
+
+void RegionMelder::fixPhiNode(PHINode *Orig) {
+  // orig->print(errs()); errs() << "\n";
+  // get the merged phi node
+  assert(OrigToMergedValues.find(Orig) != OrigToMergedValues.end() &&
+         "phi node is not found in merged control flow!");
+
+  PHINode *MergedPhi = dyn_cast<PHINode>(OrigToMergedValues[Orig]);
+
+  for (unsigned I = 0; I < Orig->getNumIncomingValues(); I++) {
+    BasicBlock *OrigIncomingBb = Orig->getIncomingBlock(I);
+    Value *OrigIncomingV = Orig->getIncomingValue(I);
+    // set the matching incoming block and value in merged PHI node
+    BasicBlock *MergedIncomingBb = OrigIncomingBb;
+    Value *MergedIncomingV = OrigIncomingV;
+    if (LeftBbToMergedBb.find(OrigIncomingBb) != LeftBbToMergedBb.end())
+      MergedIncomingBb = LeftBbToMergedBb[OrigIncomingBb];
+    else if (RightBbToMergedBb.find(OrigIncomingBb) != RightBbToMergedBb.end())
+      MergedIncomingBb = RightBbToMergedBb[OrigIncomingBb];
+
+    assert(MergedIncomingBb != nullptr &&
+           "matching incoming block not found for phi node!");
+
+    MergedPhi->setIncomingBlock(I, MergedIncomingBb);
+
+    // check if origIncoming value is merged
+    if (OrigToMergedValues.find(OrigIncomingV) != OrigToMergedValues.end())
+      MergedIncomingV = OrigToMergedValues[OrigIncomingV];
+
+    // set the incoming value
+    MergedPhi->setIncomingValue(I, MergedIncomingV);
+  }
+}
+
+void RegionMelder::fixOperends() {
+  INFO << "Fixing operends\n";
+  // set the correct operends in merged instructions
+  for (auto &Entry : RegionInstrAlignement) {
+    Value *L = Entry.get(0);
+    Value *R = Entry.get(1);
+
+    Instruction *MergedI;
+    if (Entry.match()) {
+      // L->print(errs()); errs() << "\n";
+      // R->print(errs()); errs() << "\n";
+      // ignore basic blocks, branch instructions and phi nodes
+      if (isa<BasicBlock>(L))
+        continue;
+
+      // handle phi nodes seperately
+      if (isa<PHINode>(L)) {
+        fixPhiNode(dyn_cast<PHINode>(L));
+        fixPhiNode(dyn_cast<PHINode>(R));
+        continue;
+      }
+
+      Instruction *LeftI = dyn_cast<Instruction>(L);
+      Instruction *RightI = dyn_cast<Instruction>(R);
+      assert(OrigToMergedValues[L] == OrigToMergedValues[R] &&
+             "matching instructions must have common merged instruction");
+      // set the operends of merged instruction
+      MergedI = dyn_cast<Instruction>(OrigToMergedValues[L]);
+
+      if (isa<BranchInst>(L))
+        setOperendsForBr(dyn_cast<BranchInst>(L), dyn_cast<BranchInst>(R),
+                         dyn_cast<BranchInst>(MergedI));
+      else
+        setOperends(LeftI, RightI, MergedI);
+
+    } else {
+      // ignore branch instructions
+      // TODO : returns
+      if (L != nullptr) {
+        assert(!isa<BranchInst>(L) && "unmatched branch found!");
+        if (isa<PHINode>(L)) {
+          fixPhiNode(dyn_cast<PHINode>(L));
+        } else if (isa<StoreInst>(L) && EnableFullPredication) {
+          StoreInst *MergedSi = dyn_cast<StoreInst>(OrigToMergedValues[L]);
+          setOprendsForNonMatchingStore(MergedSi, true);
+        } else {
+          assert(!isa<BasicBlock>(L) &&
+                 "non matching value can not be a basicblock");
+          Instruction *LeftI = dyn_cast<Instruction>(L);
+          MergedI = dyn_cast<Instruction>(OrigToMergedValues[L]);
+
+          setOperends(LeftI, nullptr, MergedI);
+        }
+      }
+
+      if (R != nullptr) {
+        assert(!isa<BranchInst>(R) && "unmatched branch found!");
+        if (isa<PHINode>(R)) {
+          fixPhiNode(dyn_cast<PHINode>(R));
+        } else if (isa<StoreInst>(R) && EnableFullPredication) {
+          StoreInst *MergedSi = dyn_cast<StoreInst>(OrigToMergedValues[R]);
+          setOprendsForNonMatchingStore(MergedSi, false);
+        } else {
+          assert(!isa<BasicBlock>(R) &&
+                 "non matching value can not be a basicblock");
+          Instruction *RightI = dyn_cast<Instruction>(R);
+          MergedI = dyn_cast<Instruction>(OrigToMergedValues[R]);
+
+          setOperends(nullptr, RightI, MergedI);
+        }
+      }
+    }
+  }
+}
+
+void RegionMelder::setOperendsForBr(BranchInst *LeftBr, BranchInst *RightBr,
+                                    BranchInst *MergedBr) {
+
+  // for branches inside the merged regions : pick the correct condition using a
+  // select branch labels are set in RAUW phase
+  if (ExitBlockL && LeftBr->getParent() != ExitBlockL) {
+    assert(LeftBr->getNumSuccessors() == RightBr->getNumSuccessors() &&
+           "branches inside the merged region must have same number of "
+           "successors!");
+    if (LeftBr->isConditional()) {
+      Value *LeftCond = LeftBr->getCondition();
+      Value *RightCond = RightBr->getCondition();
+      Value *MergedCond = nullptr;
+      if (OrigToMergedValues.find(LeftCond) != OrigToMergedValues.end())
+        LeftCond = OrigToMergedValues[LeftCond];
+      if (OrigToMergedValues.find(RightCond) != OrigToMergedValues.end())
+        RightCond = OrigToMergedValues[RightCond];
+
+      MergedCond = LeftCond;
+      // create a select if left and right conditions are not same
+      if (LeftCond != RightCond) {
+        IRBuilder<> Builder(MergedBr);
+        MergedCond = Builder.CreateSelect(MA.getDivergentCondition(), LeftCond,
+                                          RightCond);
+      }
+      MergedBr->setCondition(MergedCond);
+    }
+
+    return;
+  }
+
+  // for branches in exit blocks : create two new basic blocks and copy left and
+  // right branches trasfer control to new blocks based on merge path
+
+  // create two new basic blocks and copy the branches from left and right sides
+  BasicBlock *NewBbLeftBr =
+      BasicBlock::Create(MA.getParentFunction()->getContext(),
+                         "merged.branch.split", MA.getParentFunction());
+  BasicBlock *NewBbRightBr =
+      BasicBlock::Create(MA.getParentFunction()->getContext(),
+                         "merged.branch.split", MA.getParentFunction());
+
+  MergedBBs.push_back(NewBbLeftBr);
+  MergedBBs.push_back(NewBbRightBr);
+
+  // clone the original branches and add them to new BBs
+  IRBuilder<> Builder(NewBbLeftBr);
+  Instruction *NewLeftBr = LeftBr->clone();
+  Instruction *NewRightBr = RightBr->clone();
+  Builder.Insert(NewLeftBr);
+  Builder.SetInsertPoint(NewBbRightBr);
+  Builder.Insert(NewRightBr);
+
+  // create a new branch in the merged block to set the targets based on
+  // mergepath remove exiting mergeBr
+  Builder.SetInsertPoint(MergedBr->getParent());
+  BranchInst *NewBi = Builder.CreateCondBr(MA.getDivergentCondition(),
+                                           NewBbLeftBr, NewBbRightBr);
+  MergedBr->eraseFromParent();
+
+  // update the value maps
+  MergedValuesToLeftValues[NewBi] = LeftBr;
+  MergedValuesToLeftValues[NewBi] = RightBr;
+  OrigToMergedValues[LeftBr] = NewBi;
+  OrigToMergedValues[RightBr] = NewBi;
+
+  // fix the phi uses in all successors
+  for (BasicBlock *SuccBb : dyn_cast<BranchInst>(NewLeftBr)->successors()) {
+    SuccBb->replacePhiUsesWith(LeftBr->getParent(), NewBbLeftBr);
+  }
+
+  for (BasicBlock *SuccBb : dyn_cast<BranchInst>(NewRightBr)->successors()) {
+    SuccBb->replacePhiUsesWith(RightBr->getParent(), NewBbRightBr);
+  }
+}
+
+void RegionMelder::setOprendsForNonMatchingStore(StoreInst *SI, bool IsLeft) {
+  // non matching store instructions causes invalid memory write in
+  // L or R path. To avoid this we have to add a redundant load that reads the
+  // curent value of the address. and depending on the path we pick the correct
+  // to value to write. i.e. current value in the non-matching path or intended
+  // value in the matching path
+  Value *Addr = SI->getPointerOperand();
+  Value *Val = SI->getValueOperand();
+
+  // find the merged operends
+  if (OrigToMergedValues.find(Addr) != OrigToMergedValues.end())
+    Addr = OrigToMergedValues[Addr];
+  if (OrigToMergedValues.find(Val) != OrigToMergedValues.end())
+    Val = OrigToMergedValues[Val];
+
+  // create a load for the addr (gets current value)
+  IRBuilder<> Builder(SI);
+  Builder.SetInsertPoint(SI);
+  LoadInst *RedunLoad = Builder.CreateLoad(Val->getType(), Addr, "redun.load");
+  // create a switch to pick the right value
+  Value *ValueL = nullptr, *ValueR = nullptr;
+  if (IsLeft) {
+    ValueL = Val;
+    ValueR = RedunLoad;
+  } else {
+    ValueL = RedunLoad;
+    ValueR = Val;
+  }
+  Value *ValToStore =
+      Builder.CreateSelect(MA.getDivergentCondition(), ValueL, ValueR);
+
+  // set the value
+  SI->setOperand(0, ValToStore);
+  // set the addr
+  SI->setOperand(1, Addr);
+}
+
+void RegionMelder::setOperends(Instruction *LeftI, Instruction *RightI,
+                               Instruction *MergedI) {
+  for (unsigned I = 0; I < MergedI->getNumOperands(); I++) {
+    Value *LeftOp = nullptr, *RightOp = nullptr;
+
+    if (LeftI)
+      LeftOp = LeftI->getOperand(I);
+    if (RightI)
+      RightOp = RightI->getOperand(I);
+
+    if (LeftOp && OrigToMergedValues.find(LeftOp) != OrigToMergedValues.end())
+      LeftOp = OrigToMergedValues[LeftOp];
+    if (RightOp && OrigToMergedValues.find(RightOp) != OrigToMergedValues.end())
+      RightOp = OrigToMergedValues[RightOp];
+
+    // if the operends are different add a select to pick the correct one
+    Value *NewOp = LeftOp ? LeftOp : RightOp;
+    if (LeftOp && RightOp && LeftOp != RightOp) {
+      SelectInst *Select =
+          SelectInst::Create(MA.getDivergentCondition(), LeftOp, RightOp,
+                             "merged.select", MergedI);
+      NewOp = dyn_cast<Value>(Select);
+    }
+
+    // set the new operenf
+    MergedI->setOperand(I, NewOp);
+  }
+}
+
+void RegionMelder::runPostMergeCleanup() {
+
+  // replace all uses with merged vals
+  // ignore basicblocks
+  for (auto &Entry : RegionInstrAlignement) {
+
+    Value *L = Entry.get(0);
+    Value *R = Entry.get(1);
+
+    Value *MergedValLeft = nullptr;
+    Value *MergedValRight = nullptr;
+    if (Entry.match()) {
+      if (isa<BasicBlock>(L)) {
+        MergedValLeft = LeftBbToMergedBb[dyn_cast<BasicBlock>(L)];
+        MergedValRight = MergedValLeft;
+
+      } else if (isa<PHINode>(L)) {
+        MergedValLeft = OrigToMergedValues[L];
+        MergedValRight = OrigToMergedValues[R];
+      } else {
+        MergedValLeft = OrigToMergedValues[L];
+        MergedValRight = MergedValLeft;
+      }
+
+      L->replaceAllUsesWith(MergedValLeft);
+      R->replaceAllUsesWith(MergedValRight);
+
+    } else {
+      if (L != nullptr) {
+        if (isa<BasicBlock>(L))
+          MergedValLeft = LeftBbToMergedBb[dyn_cast<BasicBlock>(L)];
+        else
+          MergedValLeft = OrigToMergedValues[L];
+
+        L->replaceAllUsesWith(MergedValLeft);
+      }
+      if (R != nullptr) {
+        if (isa<BasicBlock>(R))
+          MergedValRight = LeftBbToMergedBb[dyn_cast<BasicBlock>(R)];
+        else
+          MergedValRight = OrigToMergedValues[R];
+
+        R->replaceAllUsesWith(MergedValRight);
+      }
+    }
+  }
+  // fix outside phi nodes that are invalid after merge
+  // FixOutsidePHINodes(outsidePhisBeforeRAUW);
+
+  // erase orig instructions in merged regions
+  for (auto &Entry : RegionInstrAlignement) {
+
+    Value *L = Entry.get(0);
+    Value *R = Entry.get(1);
+
+    if (Entry.match()) {
+      if (isa<BasicBlock>(L)) {
+        if (L != R) {
+          dyn_cast<BasicBlock>(L)->eraseFromParent();
+          dyn_cast<BasicBlock>(R)->eraseFromParent();
+        } else {
+          dyn_cast<BasicBlock>(L)->eraseFromParent();
+        }
+      }
+    } else {
+      if (L != nullptr) {
+        if (isa<BasicBlock>(L)) {
+          dyn_cast<BasicBlock>(L)->eraseFromParent();
+        }
+      }
+
+      if (R != nullptr) {
+        if (isa<BasicBlock>(R)) {
+          dyn_cast<BasicBlock>(R)->eraseFromParent();
+        }
+      }
+    }
+  }
+
+  // merging can result in additional predessors for merged entry blocks
+  // scan all phi nodes and add missing incoming blocks, value will be undef
+  // because these transitions will not happen during execution
+  for (auto &BB : *MA.getParentFunction()) {
+    for (PHINode &PN : BB.phis()) {
+      for (auto It = pred_begin(&BB); It != pred_end(&BB); ++It) {
+        if (PN.getBasicBlockIndex(*It) < 0) {
+          // PN.print(errs());  errs() << "\n";
+          // (*it)->print(errs());
+          PN.addIncoming(UndefValue::get(PN.getType()), *It);
+        }
+      }
+    }
+  }
+}
+
+Region *RegionMelder::getRegionToReplicate(BasicBlock *MatchedBlock,
+                                           BasicBlock *PathEntry) {
+  auto RI = MA.getCFGInfo().getRegionInfo();
+  PostDominatorTree &PDT = MA.getCFGInfo().getPostDomTree();
+  BasicBlock *Curr = MatchedBlock;
+  Region *R = nullptr;
+  do {
+    Region *Candidate = RI->getRegionFor(Curr);
+    BasicBlock *Entry = Candidate->getEntry();
+    if (PDT.dominates(Entry, PathEntry)) {
+      R = Candidate;
+    } else {
+      // BasicBlock *OldCurr = Curr;
+      for (auto *Pred : make_range(pred_begin(Entry), pred_end(Entry))) {
+        if (!Candidate->contains(Pred)) {
+          Curr = Pred;
+          break;
+        }
+      }
+      // if (OldCurr == Curr) {
+      //   errs() << "DID NOT CHANGE CURRENT! INFINITE LOOP!\n";
+      // }
+    }
+
+  } while (!R);
+  assert(R != nullptr && "can not find region to replicate!");
+  return R;
+}
+
+void RegionMelder::merge(unsigned Index) {
+
+  // static int Count = 0;
+  // Utils::writeCFGToDotFile(*MA.getParentFunction(), std::to_string(Count++) + ".cfmelder.");
+
+  bool RegionAlreadySimplified = false;
+
+  if (MA.requireRegionReplication()) {
+    INFO << "Replicating regions in BB-region match\n";
+    auto Mapping = MA.getRegionMatch(Index);
+    assert(Mapping.size() == 1 &&
+           "more than one pair of basic blocks to match in BB-region match");
+
+    // determine on which side region needs to be replicated
+    BasicBlock *LeftPathEntry =
+        MA.getDivergentBlock()->getTerminator()->getSuccessor(0);
+    BasicBlock *RightPathEntry =
+        MA.getDivergentBlock()->getTerminator()->getSuccessor(1);
+
+    BasicBlock *ExpandedBlock, *MatchedBlock = nullptr;
+    Region *RToReplicate = nullptr;
+    BasicBlock *Left = Mapping.begin()->first, *Right = Mapping.begin()->second;
+    bool ExpandingLeft = false;
+    if (MA.getCFGInfo().getPostDomTree().dominates(Left, LeftPathEntry)) {
+      DEBUG << "Replicating right region\n";
+      ExpandedBlock = Left;
+      MatchedBlock = Right;
+      RToReplicate = getRegionToReplicate(MatchedBlock, RightPathEntry);
+      ExpandingLeft = true;
+    } else {
+      DEBUG << "Replicating left region\n";
+      ExpandedBlock = Right;
+      MatchedBlock = Left;
+      RToReplicate = getRegionToReplicate(MatchedBlock, LeftPathEntry);
+    }
+
+    // simplify the replicated region
+    BasicBlock *ExitToReplicate = RToReplicate->getExit();
+    BasicBlock *EntryToReplicate = RToReplicate->getEntry();
+    if (MA.requireRegionSimplification(RToReplicate)) {
+      INFO << "Replicated region is not a simple region, running region "
+              "simplification\n";
+      // BasicBlock *Entry = RToReplicate->getEntry();
+      ExitToReplicate =
+          simplifyRegion(RToReplicate->getExit(), RToReplicate->getEntry());
+
+      // recompute control-flow analyses , FIXME : this might be too expensive
+      MA.getCFGInfo().recompute();
+      RToReplicate = Utils::getRegionWithEntryExit(
+          *MA.getCFGInfo().getRegionInfo(), EntryToReplicate, ExitToReplicate);
+      assert(RToReplicate && "Can not find region with given entry and exit");
+
+      INFO << "region after region simplification : ";
+      errs() << "[";
+      RToReplicate->getEntry()->printAsOperand(errs(), false);
+      errs() << " : ";
+      RToReplicate->getExit()->printAsOperand(errs(), false);
+      errs() << "]\n";
+
+      RegionAlreadySimplified = true;
+    }
+
+    // errs() << "replicate the region\n";
+    // replicate the region
+    RegionReplicator RR(MA, ExpandingLeft, EnableFullPredication);
+    Region *ReplicatedR =
+        RR.replicate(ExpandedBlock, MatchedBlock, RToReplicate);
+
+    // errs() << "prepare for melding\n";
+    // prepare for melding
+    if (ExpandingLeft) {
+      EntryBlockL = ReplicatedR->getEntry();
+      ExitBlockL = ReplicatedR->getExit();
+      EntryBlockR = EntryToReplicate;
+      ExitBlockR = ExitToReplicate;
+    } else {
+      EntryBlockR = ReplicatedR->getEntry();
+      ExitBlockR = ReplicatedR->getExit();
+      EntryBlockL = EntryToReplicate;
+      ExitBlockL = ExitToReplicate;
+    }
+
+    // errs() << "here\n";
+    RR.getBasicBlockMapping(CurrMapping, ExpandingLeft);
+
+    BBToRegionMeldings++;
+
+  } else {
+
+    // set entry and exits
+    EntryBlockL = MA.getRegionMatchEntryBlocks(Index).first;
+    EntryBlockR = MA.getRegionMatchEntryBlocks(Index).second;
+
+    // exit blocks are set for only region-region melding, otherwise null
+    auto ExitBlocks = MA.getRegionMatchExitBlocks(Index);
+    if (ExitBlocks.first && ExitBlocks.second) {
+      ExitBlockL = ExitBlocks.first;
+      ExitBlockR = ExitBlocks.second;
+      RegionToRegionMeldings++;
+    } else {
+      BasicBlock *LeftUniqueSucc = EntryBlockL->getUniqueSuccessor();
+      BasicBlock *RightUniqueSucc = EntryBlockR->getUniqueSuccessor();
+      // if diamonf control-flow
+      if (LeftUniqueSucc && RightUniqueSucc &&
+          LeftUniqueSucc == RightUniqueSucc) {
+        BBToBBMeldings++;
+      } else {
+        BBToRegionMeldings++;
+      }
+    }
+
+    CurrMapping = MA.getRegionMatch(Index);
+  }
+
+  INFO << "Melding entry blocks ";
+  EntryBlockL->printAsOperand(errs(), false);
+  errs() << " , ";
+  EntryBlockR->printAsOperand(errs(), false);
+  errs() << "\n";
+
+  if (ExitBlockL) {
+    INFO << "Melding exit blocks ";
+    ExitBlockL->printAsOperand(errs(), false);
+    errs() << " , ";
+    ExitBlockR->printAsOperand(errs(), false);
+    errs() << "\n";
+  }
+  // run pre merge passes
+  runPreMergePasses(RegionAlreadySimplified);
+  // Utils::writeCFGToDotFile(*MA.getParentFunction(), std::to_string(Count++) + ".cfmelder.");
+
+  if (!DisableMelding) {
+    // parentFunc->print(errs());
+    // compute alignment
+#if ENABLE_TIMING == 1
+    auto T1 = std::chrono::high_resolution_clock::now();
+#endif
+    computeRegionSeqAlignment(CurrMapping);
+#if ENABLE_TIMING == 1
+    auto T2 = std::chrono::high_resolution_clock::now();
+    auto micros =
+        std::chrono::duration_cast<std::chrono::microseconds>(T2 - T1).count();
+    InstrAlignTime += (unsigned int)(micros);
+#endif
+    // for(auto& Entry : RegionInstrAlignement) {
+    //   if(Entry.getLeft())
+    //     Entry.getLeft()->print(errs());
+    //   else
+    //     errs() << "_";
+    //   errs() << ":";
+    //   if(Entry.getRight())
+    //     Entry.getRight()->print(errs());
+    //   else
+    //     errs() << "_";
+    //   errs() << "\n";
+    // }
+    // while(true);
+
+    // Merge the regions
+    cloneInstructions();
+    fixOperends();
+    runPostMergeCleanup();
+    runPostOptimizations();
+
+    if (!EnableFullPredication)
+      runUnpredicationPass();
+  }
+  NumMeldings++;
+  // Utils::writeCFGToDotFile(*MA.getParentFunction(), std::to_string(Count++) + ".cfmelder.");
+  // verify the function
+  // assert(!verifyFunction(*MA.getParentFunction(), &errs()) &&
+  //        "function verification failed!");
+}
+
+void RegionMelder::linearizeBb(BasicBlock *BB,
+                               SmallVectorImpl<Value *> &LinearizedVals) {
+  LinearizedVals.push_back(BB);
+  for (Instruction &I : *BB) {
+    LinearizedVals.push_back(&I);
+  }
+}
+
+Instruction *RegionMelder::cloneInstruction(Instruction *OrigI,
+                                            IRBuilder<> &Builder) {
+  Instruction *NewI = OrigI->clone();
+
+  BasicBlock *InsertAt = nullptr;
+  // decide whta place to insert at
+  if (LeftBbToMergedBb.find(OrigI->getParent()) != LeftBbToMergedBb.end())
+    InsertAt = LeftBbToMergedBb[OrigI->getParent()];
+  if (InsertAt == nullptr)
+    InsertAt = RightBbToMergedBb[OrigI->getParent()];
+
+  // insertion
+  Builder.SetInsertPoint(InsertAt);
+  Builder.Insert(NewI);
+
+  return NewI;
+}
+
+void RegionMelder::runUnpredicationPass() {
+
+  for (auto &Range : SplitRanges) {
+    BasicBlock *BB = Range.getStart()->getParent();
+    BasicBlock *SplitBb = SplitBlock(BB, Range.getStart());
+    SplitBb->setName("predication.split"); // FIX : for ambigous overloading
+    BasicBlock *TailBlock = SplitBlock(SplitBb, Range.getEnd()->getNextNode());
+    TailBlock->setName("predication.tail"); //  FIX : for ambigous overloading
+
+    MergedBBs.push_back(SplitBb);
+
+    // now only execute the splitBlock conditionally
+    Instruction *OldBr = BB->getTerminator();
+    BasicBlock *TrueTarget = nullptr;
+    BasicBlock *FalseTarget = nullptr;
+    if (Range.splitToTrue()) {
+      TrueTarget = SplitBb;
+      FalseTarget = TailBlock;
+    } else {
+      TrueTarget = TailBlock;
+      FalseTarget = SplitBb;
+    }
+    BranchInst *NewBr = BranchInst::Create(TrueTarget, FalseTarget,
+                                           MA.getDivergentCondition(), BB);
+    OldBr->replaceAllUsesWith(NewBr);
+    OldBr->eraseFromParent();
+
+    // add phi node where necessary
+
+    for (auto &I : *SplitBb) {
+      SmallVector<Instruction *, 32> Users;
+      PHINode *NewPhi = nullptr;
+      for (auto It = I.user_begin(); It != I.user_end(); ++It) {
+        Instruction *User = dyn_cast<Instruction>(*It);
+        if (User->getParent() != SplitBb) {
+          Users.push_back(User);
+        }
+      }
+
+      if (!Users.empty()) {
+        NewPhi =
+            PHINode::Create(I.getType(), 2, "", TailBlock->getFirstNonPHI());
+        NewPhi->addIncoming(&I, SplitBb);
+        NewPhi->addIncoming(UndefValue::get(NewPhi->getType()), BB);
+        for (auto User : Users) {
+          User->replaceUsesOfWith(&I, NewPhi);
+        }
+      }
+    }
+  }
+}
+
+void RegionMelder::updateSplitRangeMap(bool Direction, Instruction *I) {
+  InstrRange Range(I, I, Direction);
+  if (!SplitRanges.empty() && SplitRanges.back().canExtendUsing(Range)) {
+    InstrRange Prev = SplitRanges.pop_back_val();
+    SplitRanges.push_back(Prev.extendUsing(Range));
+  } else {
+    SplitRanges.push_back(Range);
+  }
+}
+
+BasicBlock *RegionMelder::simplifyRegion(BasicBlock *Exit, BasicBlock *Entry) {
+  // only applies for region merges (not needed for bb merges)
+  // if the exit block of the region (to be merged) has preds from outside that
+  // region create a new exit block and add an edge from new to old exit
+
+  // create a new exit block
+  Function *ParentFunc = MA.getParentFunction();
+  BasicBlock *NewExit = BasicBlock::Create(ParentFunc->getContext(), "new.exit",
+                                           ParentFunc, Exit);
+  // add a jump from new exit to old exit
+  BranchInst::Create(Exit, NewExit);
+  Region *MergedR = Utils::getRegionWithEntryExit(
+      *MA.getCFGInfo().getRegionInfo(), Entry, Exit);
+
+  // this can not be nullptr because must exit
+  assert(MergedR && "Can not find region with given entry and exit");
+
+  // move relavant phi nodes from old exit to new exit
+  SmallVector<BasicBlock *, 4> IncomingBlocksToDelete;
+  for (auto &Phi : Exit->phis()) {
+
+    IncomingBlocksToDelete.clear();
+    // create a new phi in new exit block
+    PHINode *NewPhi =
+        PHINode::Create(Phi.getType(), 1, "moved.phi", &*NewExit->begin());
+    for (unsigned I = 0; I < Phi.getNumIncomingValues(); ++I) {
+      Value *IncomingV = Phi.getIncomingValue(I);
+      BasicBlock *IncomingB = Phi.getIncomingBlock(I);
+      // incomingB->print(errs());
+
+      if (MergedR->contains(IncomingB)) {
+        NewPhi->addIncoming(IncomingV, IncomingB);
+        IncomingBlocksToDelete.push_back(IncomingB);
+      }
+    }
+    Phi.addIncoming(NewPhi, NewExit);
+    // remove incoming values from within region for the old exit
+    for (auto BB : IncomingBlocksToDelete) {
+      Phi.removeIncomingValue(BB);
+    }
+  }
+
+  // unlink the old exit from the region and link new exit block to region
+  SmallVector<BasicBlock *, 4> PredsWithinRegion;
+  for (auto It = pred_begin(Exit); It != pred_end(Exit); ++It) {
+    BasicBlock *Pred = *It;
+    // TODO : self loops?
+    if (MergedR->contains(Pred))
+      PredsWithinRegion.push_back(Pred);
+  }
+
+  for (BasicBlock *Pred : PredsWithinRegion) {
+    Pred->getTerminator()->replaceSuccessorWith(Exit, NewExit);
+  }
+
+  return NewExit;
+}
+
+bool RegionMelder::isInsideMeldedRegion(BasicBlock *BB, BasicBlock *Entry,
+                                        BasicBlock *Exit) {
+  // melded region is a single BB
+  if (!Exit) {
+    return BB == Entry;
+  }
+  // melded region has mutiple BBs
+  return (MA.getCFGInfo().getDomTree().dominates(Entry, BB) &&
+          MA.getCFGInfo().getPostDomTree().dominates(Exit, BB));
+}
+
+void RegionMelder::mergeOutsideDefsAtEntry() {
+
+  SmallVector<BasicBlock *, 16> LeftEntryPreds, RightEntryPreds;
+
+  auto CreateUnifyingBB = [&]() {
+    BasicBlock *UnifyBB =
+        BasicBlock::Create(MA.getParentFunction()->getContext(), "unify.bb",
+                           MA.getParentFunction(), EntryBlockL);
+    BranchInst::Create(UnifyBB, UnifyBB, MA.getDivergentCondition(), UnifyBB);
+
+    for (auto &PHI : EntryBlockL->phis()) {
+      // add a new phi in unifying block
+      PHINode *MovedPHI =
+          PHINode::Create(PHI.getType(), 1, "moved.phi", &*UnifyBB->begin());
+      for (unsigned int I = 0; I < PHI.getNumIncomingValues(); ++I) {
+        if (!isInsideMeldedRegion(PHI.getIncomingBlock(I), EntryBlockL,
+                                  ExitBlockL)) {
+          MovedPHI->addIncoming(PHI.getIncomingValue(I),
+                                PHI.getIncomingBlock(I));
+          PHI.setIncomingBlock(I, UnifyBB);
+          PHI.setIncomingValue(I, MovedPHI);
+        }
+      }
+    }
+
+    for (auto &PHI : EntryBlockR->phis()) {
+      // add a new phi in unifying block
+      PHINode *MovedPHI =
+          PHINode::Create(PHI.getType(), 1, "moved.phi", &*UnifyBB->begin());
+      for (unsigned int I = 0; I < PHI.getNumIncomingValues(); ++I) {
+        if (!isInsideMeldedRegion(PHI.getIncomingBlock(I), EntryBlockR,
+                                  ExitBlockR)) {
+          MovedPHI->addIncoming(PHI.getIncomingValue(I),
+                                PHI.getIncomingBlock(I));
+          PHI.setIncomingBlock(I, UnifyBB);
+          PHI.setIncomingValue(I, MovedPHI);
+        }
+      }
+    }
+
+    // find the predecessors of left and right entries
+    for (auto *LeftPred :
+         make_range(pred_begin(EntryBlockL), pred_end(EntryBlockL))) {
+      if (!isInsideMeldedRegion(LeftPred, EntryBlockL, ExitBlockL)) {
+        LeftEntryPreds.push_back(LeftPred);
+      }
+    }
+
+    for (auto *RightPred :
+         make_range(pred_begin(EntryBlockR), pred_end(EntryBlockR))) {
+      if (!isInsideMeldedRegion(RightPred, EntryBlockR, ExitBlockR)) {
+        RightEntryPreds.push_back(RightPred);
+      }
+    }
+
+    // add missing preds in phi nodes of unifybb
+    for (auto &PHI : UnifyBB->phis()) {
+      for (auto &Pred : LeftEntryPreds) {
+        if (PHI.getBasicBlockIndex(Pred) == -1) {
+          PHI.addIncoming(llvm::UndefValue::get(PHI.getType()), Pred);
+        }
+      }
+      for (auto &Pred : RightEntryPreds) {
+        if (PHI.getBasicBlockIndex(Pred) == -1) {
+          PHI.addIncoming(llvm::UndefValue::get(PHI.getType()), Pred);
+        }
+      }
+    }
+
+    // set the branches correctly
+    for (auto &LeftPred : LeftEntryPreds) {
+      LeftPred->getTerminator()->replaceSuccessorWith(EntryBlockL, UnifyBB);
+    }
+    for (auto &RightPred : RightEntryPreds) {
+      RightPred->getTerminator()->replaceSuccessorWith(EntryBlockR, UnifyBB);
+    }
+
+    UnifyBB->getTerminator()->setSuccessor(0, EntryBlockL);
+    UnifyBB->getTerminator()->setSuccessor(1, EntryBlockR);
+
+    return UnifyBB;
+  };
+
+  // create a unifiying basic block
+  BasicBlock *UnifyingBB = CreateUnifyingBB();
+
+  // add to mergedBBS
+  MergedBBs.push_back(UnifyingBB);
+
+  // recompute control-flow analyses
+  MA.getCFGInfo().recompute();
+  DominatorTree &DT = MA.getCFGInfo().getDomTree();
+  PostDominatorTree &PDT = MA.getCFGInfo().getPostDomTree();
+
+  // check if there are any def-use chains that are broken
+  for (auto &BB : *MA.getParentFunction()) {
+    // only need to check basic blocks detween top entry and unify BB
+    if (DT.dominates(MA.getDivergentBlock(), &BB) &&
+        PDT.dominates(UnifyingBB, &BB)) {
+      // iterate over all users and check for broken def-uses
+      for (auto &Def : make_range(BB.begin(), BB.end())) {
+        SmallVector<Instruction *, 32> BrokenUsers;
+        for (auto &Use : make_range(Def.use_begin(), Def.use_end())) {
+          Instruction *User = dyn_cast<Instruction>(Use.getUser());
+          // User->print(errs()); errs() << "\n";
+          if (!DT.dominates(&Def, Use)) {
+            // errs() << "broken user found\n";
+            // errs() << "def : ";
+            // Def.print(errs());
+            // errs() << "\n";
+            // errs() << "user : ";
+            // User->print(errs());
+            // errs() << "\n";
+
+            BrokenUsers.push_back(User);
+          }
+        }
+        PHINode *NewUnifyingPHI = nullptr;
+        for (Instruction *BrokenUser : BrokenUsers) {
+          // add a new phi node in the unifying block
+          if (!NewUnifyingPHI) {
+            NewUnifyingPHI = PHINode::Create(Def.getType(), 0, "unify.phi",
+                                             &*UnifyingBB->begin());
+
+            for (auto &LeftPred : LeftEntryPreds) {
+              if (DT.dominates(Def.getParent(), LeftPred))
+                NewUnifyingPHI->addIncoming(&Def, LeftPred);
+              else
+                NewUnifyingPHI->addIncoming(
+                    llvm::UndefValue::get(NewUnifyingPHI->getType()), LeftPred);
+            }
+            for (auto &RightPred : RightEntryPreds) {
+              if (DT.dominates(Def.getParent(), RightPred))
+                NewUnifyingPHI->addIncoming(&Def, RightPred);
+              else
+                NewUnifyingPHI->addIncoming(
+                    llvm::UndefValue::get(NewUnifyingPHI->getType()),
+                    RightPred);
+            }
+          }
+          BrokenUser->replaceUsesOfWith(&Def, NewUnifyingPHI);
+        }
+      }
+    }
+  }
+}
+
+void RegionMelder::updateMapping(BasicBlock *NewBb, BasicBlock *OldBb,
+                                 bool IsLeft) {
+  auto It = CurrMapping.begin();
+  bool Found = false;
+  for (; It != CurrMapping.end(); ++It) {
+    if (IsLeft) {
+      if (It->first == OldBb) {
+
+        Found = true;
+        break;
+      }
+    } else {
+      if (It->second == OldBb) {
+        Found = true;
+        break;
+      }
+    }
+  }
+  assert(Found && "Old exit not found in the mapping!");
+  CurrMapping.erase(It);
+  if (IsLeft) {
+    CurrMapping.insert(
+        std::pair<BasicBlock *, BasicBlock *>(NewBb, ExitBlockR));
+  } else {
+    CurrMapping.insert(
+        std::pair<BasicBlock *, BasicBlock *>(ExitBlockL, NewBb));
+  }
+}
+
+void RegionMelder::runPreMergePasses(bool RegionAlreadySimplified) {
+
+  // check if exit blocks need to be isolated
+  if (ExitBlockL) {
+    if (!RegionAlreadySimplified) {
+      DEBUG << "Simplifying left region\n";
+      BasicBlock *OldExitLeft = ExitBlockL;
+      ExitBlockL = simplifyRegion(ExitBlockL, EntryBlockL);
+      // update the mapping
+      updateMapping(ExitBlockL, OldExitLeft, true);
+      MA.getCFGInfo().recompute();
+    }
+  }
+
+  if (ExitBlockR) {
+    if (!RegionAlreadySimplified) {
+      DEBUG << "Simplifying right region\n";
+      BasicBlock *OldExitRight = ExitBlockR;
+      ExitBlockR = simplifyRegion(ExitBlockR, EntryBlockR);
+      // update the mapping
+      updateMapping(ExitBlockR, OldExitRight, false);
+      MA.getCFGInfo().recompute();
+    }
+  }
+
+  mergeOutsideDefsAtEntry();
+}
+
+static void simplifyConditionalBranches(Function *F) {
+  // check for conditional branches with same target and fold them
+  for (auto &BB : *F) {
+    if (BranchInst *BI = dyn_cast<BranchInst>(BB.getTerminator())) {
+      if (BI->getNumSuccessors() == 2 &&
+          BI->getSuccessor(0) == BI->getSuccessor(1)) {
+        DEBUG << "Converting conditional branch to unconditional\n";
+        IRBuilder<> Builder(BI);
+        Builder.CreateBr(BI->getSuccessor(0));
+        BI->eraseFromParent();
+      }
+    }
+  }
+}
+
+void RegionMelder::runPostOptimizations() {
+  Function *F = MA.getParentFunction();
+  static int Count = 0;
+  // Utils::writeCFGToDotFile(*MA.getParentFunction(), std::to_string(Count++) + ".cfmelder.");
+  INFO << "Running post-merge optimizations\n";
+
+  // first, simplify conditional branches
+  simplifyConditionalBranches(F);
+
+  // remove empty basic blocks with single incoming edge and single outgoing
+  // edge
+  for (BasicBlock *BB : MergedBBs) {
+
+    if (pred_size(BB) == 1 && succ_size(BB) == 1 && BB->size() == 1) {
+      // errs() << "processing block " << BB->getNameOrAsOperand() << "\n";
+      BasicBlock *SinglePred = *pred_begin(BB);
+      BasicBlock *SingleSucc = *succ_begin(BB);
+
+      // check if SinglePred is also a predecessor of SingleSucc
+      // SinglePred
+      //  /   \
+      // BB    |
+      //  \   /
+      // SingleSucc
+      if (isa<BranchInst>(SinglePred->getTerminator())) {
+        BranchInst *BI = dyn_cast<BranchInst>(SinglePred->getTerminator());
+        if (BI->isConditional() && (BI->getSuccessor(0) == SingleSucc ||
+                                    BI->getSuccessor(1) == SingleSucc)) {
+          Value *Cond = BI->getCondition();
+          // move the incoming values from phi nodes nodes to SinglePred
+          // as select instructions
+          for (auto &PHI : SingleSucc->phis()) {
+            Value *TrueIncoming =
+                BI->getSuccessor(0) == BB
+                    ? PHI.getIncomingValueForBlock(BB)
+                    : PHI.getIncomingValueForBlock(SinglePred);
+            Value *FalseIncoming =
+                BI->getSuccessor(1) == BB
+                    ? PHI.getIncomingValueForBlock(BB)
+                    : PHI.getIncomingValueForBlock(SinglePred);
+
+            // create a select
+            SelectInst *Sel = SelectInst::Create(
+                Cond, TrueIncoming, FalseIncoming, "moved.sel", BI);
+            // update the incoming value
+            PHI.setIncomingValueForBlock(BB, Sel);
+            PHI.setIncomingValueForBlock(SinglePred, Sel);
+          }
+        }
+      }
+
+      // connect SinglePred to SingleSucc
+      SinglePred->getTerminator()->replaceSuccessorWith(BB, SingleSucc);
+      // replace all uses in PHI nodes
+      BB->replaceAllUsesWith(SinglePred);
+      // unlink
+      BB->eraseFromParent();
+    }
+  }
+
+  // previous step can create conditional branches with same successors
+  simplifyConditionalBranches(F);
+
+  // check for phi nodes with identical incoming value, block pairs
+  // and fold them
+
+  for (auto &BB : *F) {
+    for (PHINode &Phi : BB.phis()) {
+      if (Phi.getNumIncomingValues() > pred_size(&BB)) {
+        bool Changed = false;
+        do {
+          Changed = false;
+          for (unsigned I = 0; I < Phi.getNumIncomingValues(); I++) {
+            BasicBlock *IncomingBlk = Phi.getIncomingBlock(I);
+            // only process incoming values from merged blocks
+            if (std::find(MergedBBs.begin(), MergedBBs.end(), IncomingBlk) ==
+                MergedBBs.end())
+              continue;
+            for (unsigned J = I + 1; J < Phi.getNumIncomingValues(); J++) {
+              if (Phi.getIncomingBlock(I) == Phi.getIncomingBlock(J) &&
+                  Phi.getIncomingValue(I) == Phi.getIncomingValue(J)) {
+                Phi.removeIncomingValue(J);
+                Changed = true;
+                break;
+              }
+            }
+            if (Changed) {
+              break;
+            }
+          }
+        } while (Changed);
+      }
+    }
+  }
+
+  // remove phi nodes with one incoming value
+  SmallVector<PHINode *, 8> PNToDelete;
+  for (auto &BB : *MA.getParentFunction()) {
+    for (auto &Phi : BB.phis()) {
+      if (Phi.getNumIncomingValues() == 1)
+        PNToDelete.push_back(&Phi);
+    }
+  }
+
+  for (PHINode *PN : PNToDelete) {
+    DEBUG << "Erasing phi node\n";
+    // PN->print(DEBUG);
+    // DEBUG << "\n";
+    PN->replaceAllUsesWith(PN->getIncomingValue(0));
+    PN->eraseFromParent();
+  }
+
+  // Utils::writeCFGToDotFile(*F, std::to_string(Count++) + ".cfmelder.");
+  // verifyFunction(*F);
+}
diff --git a/llvm/lib/Transforms/CFMelder/RegionMelder.h b/llvm/lib/Transforms/CFMelder/RegionMelder.h
new file mode 100644
index 000000000000..22e209e4b9bd
--- /dev/null
+++ b/llvm/lib/Transforms/CFMelder/RegionMelder.h
@@ -0,0 +1,190 @@
+#ifndef LLVM_LIB_TRANSFORMS_REGION_MELDER_H
+#define LLVM_LIB_TRANSFORMS_REGION_MELDER_H
+
+#include "RegionAnalyzer.h"
+#include "SmithWaterman.h"
+#include "llvm/ADT/SmallSet.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/IR/BasicBlock.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/IRBuilder.h"
+#include "llvm/IR/ValueMap.h"
+#include "llvm/TableGen/Record.h"
+#include "CFMelderUtils.h"
+
+namespace llvm {
+
+class InstructionMatch {
+public:
+  static bool match(Value *V1, Value *V2) {
+    if (isa<Instruction>(V1) && isa<Instruction>(V2)) {
+      Instruction *I1 = dyn_cast<Instruction>(V1);
+      Instruction *I2 = dyn_cast<Instruction>(V2);
+
+      if (I1->getOpcode() == I2->getOpcode() &&
+          I1->getOpcode() == Instruction::Br)
+        return true;
+    }
+    return InstructionMatchUtils::match(V1, V2);
+  };
+};
+
+// scoring function for instruction alignment based on code size reduction
+// if instrutions match always return a non-zero value
+struct CodeSizeCostModel : public ScoringFunction<Value *> {
+  TargetTransformInfo *TTI;
+  CodeSizeCostModel(TargetTransformInfo &TTI) : TTI(&TTI) {}
+
+public:
+  int operator()(Value *V1, Value *V2) override {
+    if (!InstructionMatch::match(V1, V2))
+      return 0;
+
+    int SavedSize = 0;
+    if (isa<Instruction>(V1)) {
+      SavedSize = 1 + TTI->getInstructionCost(
+                         dyn_cast<Instruction>(V1),
+                         TargetTransformInfo::TargetCostKind::TCK_CodeSize)
+                      .getValue()
+                      .getValue();
+    } else if (isa<BasicBlock>(V1)) {
+      SavedSize = 3;
+    }
+    return SavedSize;
+  }
+
+  int gap(int K) override {
+    int BrCost = TTI
+        ->getCFInstrCost(Instruction::Br, TTI::TargetCostKind::TCK_CodeSize)
+        .getValue()
+        .getValue();
+    return 1 + BrCost;
+  }
+};
+
+// simple scoring function for instruction alignment for latency reduction
+struct GPULatencyCostModel : public ScoringFunction<Value *> {
+public:
+  int operator()(Value *V1, Value *V2) override {
+
+    if (!InstructionMatch::match(V1, V2))
+      return 0;
+
+    int SavedCycles = 0;
+    if (isa<Instruction>(V1)) {
+      Instruction *I1 = dyn_cast<Instruction>(V1);
+      SavedCycles = Utils::getInstructionCost(I1);
+    } else if (isa<BasicBlock>(V1)) {
+      SavedCycles = 3;
+    }
+
+    return SavedCycles;
+  }
+  int gap(int K) override { return 2; }
+};
+
+class RegionMelder {
+private:
+  RegionAnalyzer &MA;
+
+  // entry and exits of currently merging regions
+  // if single BB, exit is null
+  BasicBlock *EntryBlockL{nullptr}, *EntryBlockR{nullptr};
+  BasicBlock *ExitBlockL{nullptr}, *ExitBlockR{nullptr};
+  DenseMap<BasicBlock *, BasicBlock *> CurrMapping;
+
+  AlignedSeq<Value *> RegionInstrAlignement;
+  using ValueToValueMapTy = ValueMap<const Value *, WeakTrackingVH>;
+
+  // value maps
+  ValueToValueMapTy MergedValuesToLeftValues;
+  ValueToValueMapTy MergedValuesToRightValues;
+  ValueToValueMapTy OrigToMergedValues;
+
+  // label map
+  DenseMap<BasicBlock *, BasicBlock *> LeftBbToMergedBb;
+  DenseMap<BasicBlock *, BasicBlock *> RightBbToMergedBb;
+
+  // merged instructions
+  SmallVector<Instruction *, 0> MergedInstructions;
+  SmallVector<BasicBlock *, 0> MergedBBs;
+
+  // un-predication
+  struct InstrRange {
+  private:
+    Instruction *StartI, *EndI;
+    bool Direction;
+
+  public:
+    InstrRange(Instruction *Start, Instruction *End, bool Dir)
+        : StartI(Start), EndI(End), Direction(Dir) {}
+    Instruction *getStart() const { return StartI; }
+    Instruction *getEnd() const { return EndI; }
+    bool splitToTrue() const { return Direction; }
+    bool splitToFalse() const { return !Direction; }
+    friend raw_ostream &operator<<(raw_ostream &OS, const InstrRange &Range) {
+      OS << "start : ";
+      Range.getStart()->print(OS);
+      OS << ", end : ";
+      Range.getEnd()->print(OS);
+      OS << ", direction : " << (Range.splitToTrue() ? "T" : "F");
+      return OS;
+    }
+
+    bool canExtendUsing(const InstrRange &Other) {
+      return Other.getStart()->getPrevNode() == EndI &&
+             Other.splitToTrue() == splitToTrue();
+    }
+    InstrRange extendUsing(const InstrRange &Other) {
+      assert(canExtendUsing(Other) &&
+             "this range can not be extended with provided range !");
+      return InstrRange(StartI, Other.getEnd(), splitToTrue());
+    }
+  };
+
+  SmallVector<InstrRange, 16> SplitRanges;
+
+  AlignedSeq<Value *>
+  getAlignmentOfBlocks(BasicBlock *LeftBb, BasicBlock *RightBb,
+                       ScoringFunction<Value *> &ScoringFunc);
+  void computeRegionSeqAlignment(DenseMap<BasicBlock *, BasicBlock *> BbMap);
+  void linearizeBb(BasicBlock *BB, SmallVectorImpl<Value *> &LinearizedVals);
+  void cloneInstructions();
+  void fixOperends();
+  void runPostMergeCleanup();
+  void setOperends(Instruction *LeftI, Instruction *RightI,
+                   Instruction *MergedI);
+  void setOperendsForBr(BranchInst *LeftBr, BranchInst *RightBr,
+                        BranchInst *MergedBr);
+  Instruction *cloneInstruction(Instruction *OrigI, IRBuilder<> &Builder);
+  void fixPhiNode(PHINode *Orig);
+  void runPostOptimizations();
+  void setOprendsForNonMatchingStore(StoreInst *SI, bool IsLeft);
+  void runPreMergePasses(bool RegionAlreadySimplified);
+  void mergeOutsideDefsAtEntry();
+
+  // makes the region SESE, after simplification exit block of the region
+  // is connected to rest of the CFG with only one edge
+  BasicBlock *simplifyRegion(BasicBlock *Exit, BasicBlock *Entry);
+
+  bool isExitBlockSafeToMerge(BasicBlock *Exit, BasicBlock *Entry);
+  void updateMapping(BasicBlock *NewBb, BasicBlock *OldBb, bool IsLeft);
+
+  void runUnpredicationPass();
+  void updateSplitRangeMap(bool Direction, Instruction *I);
+
+  bool isInsideMeldedRegion(BasicBlock *BB, BasicBlock *Entry,
+                            BasicBlock *Exit);
+
+  // finds the region whose entry block post dominates the path entry block
+  Region *getRegionToReplicate(BasicBlock *MatchedBlock, BasicBlock *PathEntry);
+
+public:
+  RegionMelder(RegionAnalyzer &MA) : MA(MA) {}
+  // meld I'th region pair
+  void merge(unsigned Index);
+};
+
+} // namespace llvm
+
+#endif
\ No newline at end of file
diff --git a/llvm/lib/Transforms/CFMelder/RegionReplicator.cpp b/llvm/lib/Transforms/CFMelder/RegionReplicator.cpp
new file mode 100644
index 000000000000..cc473ac88d49
--- /dev/null
+++ b/llvm/lib/Transforms/CFMelder/RegionReplicator.cpp
@@ -0,0 +1,499 @@
+#include "RegionReplicator.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/iterator_range.h"
+#include "llvm/Analysis/MemorySSAUpdater.h"
+#include "llvm/Analysis/PostDominators.h"
+#include "llvm/IR/BasicBlock.h"
+#include "llvm/IR/CFG.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/Dominators.h"
+#include "llvm/IR/Instruction.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/Support/raw_ostream.h"
+
+using namespace llvm;
+
+Region *RegionReplicator::replicate(BasicBlock *ExpandedBlock,
+                                    BasicBlock *MatchedBlock,
+                                    Region *RegionToReplicate) {
+
+  BasicBlock *EntryToReplicate = RegionToReplicate->getEntry();
+  BasicBlock *ExitToReplicate = RegionToReplicate->getExit();
+  // errs() << "replicate CFG\n";
+  // replicate the CFG of region and place the ExpandedBlock in right place
+  auto RepEntryExitPair =
+      replicateCFG(ExpandedBlock, MatchedBlock, RegionToReplicate);
+
+  // errs() << "recompute CF analysis\n";
+  // recompute CF analysis
+  MA.getCFGInfo().recompute();
+  auto RI = MA.getCFGInfo().getRegionInfo();
+
+  Region *ReplicatedR = Utils::getRegionWithEntryExit(
+      *RI, RepEntryExitPair.first, RepEntryExitPair.second);
+  // errs() << "place PHI nodes in the replicated region for correct def-use\n";
+  // place PHI nodes in the replicated region for correct def-use
+  ValueToValueMapTy PHIMap;
+  addPhiNodes(ExpandedBlock, ReplicatedR, PHIMap);
+
+  // errs() << "concretize the branch conditions within the replicated
+  // region\n"; concretize the branch conditions within the replicated region
+  concretizeBranchConditions(ExpandedBlock, ReplicatedR, PHIMap);
+
+  // errs() << "finalizing replication\n";
+  if (EnableFullPredication) {
+    // errs() << "Full predication enabled\n";
+    Region *OrigRegion =
+        Utils::getRegionWithEntryExit(*RI, EntryToReplicate, ExitToReplicate);
+    assert(OrigRegion && "Can not find the replicated region!");
+    fullPredicateStores(OrigRegion, MatchedBlock);
+  }
+
+  // MA.getCFGInfo().getFunction().getParent()->print(errs(), nullptr);
+  return ReplicatedR;
+}
+
+void RegionReplicator::getBasicBlockMapping(
+    DenseMap<BasicBlock *, BasicBlock *> &Map, bool IsExpandingLeft) {
+  for (auto It : Mapping) {
+    BasicBlock *Orig = It.first;
+    BasicBlock *Replicated = It.second;
+    if (IsExpandingLeft) {
+      Map.insert(std::pair<BasicBlock *, BasicBlock *>(Replicated, Orig));
+    } else {
+      Map.insert(std::pair<BasicBlock *, BasicBlock *>(Orig, Replicated));
+    }
+  }
+}
+
+pair<BasicBlock *, BasicBlock *>
+RegionReplicator::replicateCFG(BasicBlock *ExpandedBlock,
+                               BasicBlock *MatchedBlock,
+                               Region *RegionToReplicate) {
+  // remember the predessors of expanded block
+  SmallVector<BasicBlock *> PredsOfExpandedBlock;
+  for (auto It = pred_begin(ExpandedBlock); It != pred_end(ExpandedBlock);
+       ++It) {
+    PredsOfExpandedBlock.push_back(*It);
+  }
+  // DenseMap<BasicBlock *, BasicBlock *> Mapping;
+
+  // traverse the region to replicate and make new basic blocks
+  SmallSet<BasicBlock *, 32> WorkList;
+  SmallVector<BasicBlock *, 32> Visited;
+  WorkList.insert(RegionToReplicate->getEntry());
+
+  BasicBlock *ExpandedBlockExit = ExpandedBlock->getUniqueSuccessor();
+
+  // if expanded block does not have a unique successor, create one
+  if (!ExpandedBlockExit) {
+    BasicBlock *NewUniqueSucc =
+        BasicBlock::Create(ExpandedBlock->getParent()->getContext(),
+                           "expanded.block.exit", ExpandedBlock->getParent());
+
+    BranchInst *ExpandedBlockBr =
+        dyn_cast<BranchInst>(ExpandedBlock->getTerminator());
+    assert(ExpandedBlockBr != nullptr &&
+           "Expanded block does not have branch instruction at the end! This "
+           "case is not handled!");
+
+    BranchInst::Create(ExpandedBlockBr->getSuccessor(0),
+                       ExpandedBlockBr->getSuccessor(1),
+                       ExpandedBlockBr->getCondition(), NewUniqueSucc);
+
+    // upade incoming blocks of phis in ExpandedBlock's successors
+    for (PHINode &PHI : ExpandedBlockBr->getSuccessor(0)->phis()) {
+      PHI.replaceIncomingBlockWith(ExpandedBlock, NewUniqueSucc);
+    }
+
+    for (PHINode &PHI : ExpandedBlockBr->getSuccessor(1)->phis()) {
+      PHI.replaceIncomingBlockWith(ExpandedBlock, NewUniqueSucc);
+    }
+
+    ExpandedBlockBr->eraseFromParent();
+    BranchInst::Create(NewUniqueSucc, ExpandedBlock);
+
+    ExpandedBlockExit = NewUniqueSucc;
+  }
+  // assert(ExpandedBlockExit != nullptr &&
+  //        "Expanded block does not have a unique successor");
+
+  while (!WorkList.empty()) {
+    auto Curr = *WorkList.begin();
+    WorkList.erase(Curr);
+    BasicBlock *ReplicatedBB = nullptr;
+    Visited.push_back(Curr);
+    // if the visited block is the block we want to match eventually
+    if (Curr == MatchedBlock) {
+      ReplicatedBB = ExpandedBlock;
+      // if there is a conditional branch at the end of matched block we need
+      // add a conditional branch to exapnded block as well
+      BranchInst *BI = dyn_cast<BranchInst>(Curr->getTerminator());
+      assert(BI && "no branch instruction at end of replicated block!");
+      if (BI->isConditional()) {
+        ExpandedBlock->getTerminator()->eraseFromParent();
+        BranchInst::Create(ExpandedBlock, ExpandedBlock,
+                           ConstantInt::getTrue(Type::getInt1Ty(
+                               MA.getParentFunction()->getContext())),
+                           ExpandedBlock);
+      }
+    }
+    // if not replicate the basic block
+    else {
+      ReplicatedBB =
+          BasicBlock::Create(MA.getParentFunction()->getContext(),
+                             "replicated.bb", MA.getParentFunction());
+      // add a  branch
+      if (dyn_cast<BranchInst>(Curr->getTerminator())->isUnconditional()) {
+        BranchInst::Create(ExpandedBlock, ReplicatedBB);
+      } else {
+        // set branching condition to true, and concretize later
+        BranchInst::Create(ExpandedBlock, ExpandedBlock,
+                           ConstantInt::getTrue(Type::getInt1Ty(
+                               MA.getParentFunction()->getContext())),
+                           ReplicatedBB);
+      }
+    }
+
+    // errs() << "replicating ";
+    // Curr->printAsOperand(errs(), false);
+    // errs() << " into ";
+    // ReplicatedBB->printAsOperand(errs(), false);
+    // errs() << "\n";
+
+    // add replaicted basic block to mapping
+    Mapping.insert(std::pair<BasicBlock *, BasicBlock *>(Curr, ReplicatedBB));
+
+    // add all successors to visited including exit
+    for (auto It = succ_begin(Curr); It != succ_end(Curr); ++It) {
+      BasicBlock *Succ = *It;
+      if (std::find(Visited.begin(), Visited.end(), Succ) == Visited.end() &&
+          (Succ == RegionToReplicate->getExit() ||
+           RegionToReplicate->contains(Succ))) {
+        WorkList.insert(Succ);
+      }
+    }
+  }
+
+  // set edges in the new region
+  for (auto It : Mapping) {
+    BasicBlock *Orig = It.first;
+    BasicBlock *Replicated = It.second;
+
+    // errs() << "Orig : ";
+    // Orig->printAsOperand(errs(), false);
+    // errs() << "\n";
+    // errs() << "Replicated : ";
+    // Replicated->printAsOperand(errs(), false);
+    // errs() << "\n";
+
+    for (unsigned I = 0; I < Orig->getTerminator()->getNumSuccessors(); ++I) {
+      BasicBlock *OrigSucc = Orig->getTerminator()->getSuccessor(I);
+      auto It1 = Mapping.find(OrigSucc);
+      // edges inside the region
+      if (It1 != Mapping.end()) {
+        Replicated->getTerminator()->setSuccessor(I, It1->second);
+      }
+      // edges to exit
+      else {
+        Replicated->getTerminator()->setSuccessor(I, ExpandedBlockExit);
+      }
+    }
+  }
+
+  // connect the new entry with rest of the control flow
+  BasicBlock *OrigEntry = RegionToReplicate->getEntry();
+  BasicBlock *OrigExit = RegionToReplicate->getExit();
+  BasicBlock *ReplicatedEntry = Mapping[OrigEntry];
+  BasicBlock *ReplicatedExit = Mapping[OrigExit];
+
+  // traverse all predesessors of orig entry and connect to new entry
+  for (BasicBlock *Pred : PredsOfExpandedBlock) {
+    Pred->getTerminator()->replaceSuccessorWith(ExpandedBlock, ReplicatedEntry);
+  }
+
+  return pair<BasicBlock *, BasicBlock *>(ReplicatedEntry, ReplicatedExit);
+}
+
+void RegionReplicator::fullPredicateStores(Region *RToReplicate,
+                                           BasicBlock *MatchedBlock) {
+
+  for (BasicBlock *BB : RToReplicate->blocks()) {
+    if (BB == MatchedBlock) {
+      continue;
+    }
+    SmallVector<StoreInst *> Stores;
+    for (Instruction &I : make_range(BB->begin(), BB->end())) {
+      if (isa<StoreInst>(&I)) {
+        Stores.push_back(cast<StoreInst>(&I));
+      }
+    }
+
+    IRBuilder<> Builder(BB);
+    // process the stores
+    for (StoreInst *SI : Stores) {
+      Value *NewData = SI->getValueOperand();
+      Value *Addr = SI->getPointerOperand();
+      // add a load instruction
+      Builder.SetInsertPoint(SI);
+      LoadInst *OldData = Builder.CreateLoad(NewData->getType(), Addr, "rr.redun.load");
+      // add a select to pick the right value to store
+      Value *SelectI = nullptr;
+      if (IsExpandingLeft) {
+        SelectI = SelectInst::Create(MA.getDivergentCondition(), OldData,
+                                     NewData, "rr.store.sel", SI);
+      } else {
+        SelectI = SelectInst::Create(MA.getDivergentCondition(), NewData,
+                                     OldData, "rr.store.sel", SI);
+      }
+      // give right value to store
+      SI->setOperand(0, SelectI);
+      SI->setOperand(1, Addr);
+    }
+  }
+}
+
+void RegionReplicator::addPhiNodes(BasicBlock *ExpandedBlock,
+                                   Region *ReplicatedRegion,
+                                   ValueToValueMapTy &PHIMap) {
+
+  // users of defs in expanded block are only replaced if the user is
+  // outside the replicated region
+  // auto ShouldReplaceUse = [&] (Use &U) -> bool {
+  //   Instruction* User = dyn_cast<Instruction>(U.getUser());
+  //   if (User->getParent() == ReplicatedRegion->getExit()) return false;
+  //   for (auto * BB : ReplicatedRegion->blocks()){
+  //     if (User->getParent() == BB) return false;
+  //   }
+  //   return true;
+  // };
+  // errs() << "computing DF\n";
+  // compute DF
+  DominatorTree &DT = MA.getCFGInfo().getDomTree();
+  DominanceFrontier DF;
+  DF.analyze(DT);
+
+  // errs() << "get uses outside the expanded block\n";
+  // get uses outside the expanded block
+  SmallSet<Instruction *, 32> InstrsWithOutsideUses;
+
+  for (auto &I : *ExpandedBlock) {
+    for (Use &Use : I.uses()) {
+      Instruction *User = cast<Instruction>(Use.getUser());
+      if (User->getParent() != ExpandedBlock) {
+        // errs() << "instruction has users outside expanded block\n";
+        // I.print(errs());
+        // errs() << "\n";
+        InstrsWithOutsideUses.insert(&I);
+        break;
+      }
+    }
+  }
+
+  SmallSet<Instruction *, 32> WorkList(InstrsWithOutsideUses);
+
+  // errs() << "processing the work list\n";
+  DenseSet<Instruction *> Visited;
+  while (!WorkList.empty()) {
+    Instruction *I = *WorkList.begin();
+    WorkList.erase(I);
+
+    // errs() << "processing instruction : \n";
+    // I->print(errs());
+    // errs() << "\n";
+
+    // if (Visited.count(I)) {
+    //   errs() << "repeting:"; I->dump();
+    // }
+    Visited.insert(I);
+
+    // add phi nodes in DF for this instruction
+    auto It = DF.find(I->getParent());
+
+    assert(It != DF.end() &&
+           "Exapanded block does not have a DF within the replicated region!");
+
+    for (auto *BB : It->second) {
+      // the expanded block is outside any loops, if the dominance frontier
+      // includes loops header ignore it
+      if (BB == I->getParent())
+        continue;
+      // errs() << "processing frontier at " << BB->getNameOrAsOperand() << "\n";
+      // add a phi node only if DF is within the replicated region
+      if (ReplicatedRegion->contains(BB) || ReplicatedRegion->getExit() == BB) {
+        PHINode *NewPHI =
+            PHINode::Create(I->getType(), 0, "rr.phi", &*BB->begin());
+        for (auto PredIt = pred_begin(BB); PredIt != pred_end(BB); ++PredIt) {
+          BasicBlock *Pred = *PredIt;
+          if (DT.dominates(I->getParent(), Pred)) {
+            NewPHI->addIncoming(I, Pred);
+          } else {
+            NewPHI->addIncoming(llvm::UndefValue::get(I->getType()), Pred);
+          }
+        }
+        // I->replaceUsesWithIf(NewPHI, ShouldReplaceUse);
+        // figure out what instruction in expanded block NewPHI points to
+        // this is neede for RAUW later
+        Value *DefInExpandedBlock = I;
+        while (PHIMap.count(DefInExpandedBlock) > 0) {
+          DefInExpandedBlock = PHIMap[DefInExpandedBlock];
+        }
+
+        // check the found def is really in expanded block
+        assert(dyn_cast<Instruction>(DefInExpandedBlock)->getParent() ==
+                   ExpandedBlock &&
+               "found definition is not in expanded block!");
+
+        // update the PHI map
+        PHIMap.insert(std::pair<Value *, Value *>(NewPHI, DefInExpandedBlock));
+        // this phi must be furthur processed using its DF
+        // errs() << "new PHI node : \n";
+        // NewPHI->print(errs());
+        // errs() << "\n";
+        WorkList.insert(NewPHI);
+      }
+    }
+  }
+
+  // errs() << "finally change the phi nodes in the successors of exit\n";
+  // finally change the phi nodes in the successors of exit
+  BasicBlock *Exit = ReplicatedRegion->getExit();
+  for (auto SuccIt = succ_begin(Exit); SuccIt != succ_end(Exit); ++SuccIt) {
+    BasicBlock *Succ = *SuccIt;
+    for (auto &PN : Succ->phis()) {
+      PN.replaceIncomingBlockWith(ExpandedBlock, Exit);
+    }
+  }
+}
+
+static void visitDFS(BasicBlock *From, BasicBlock *To,
+                     SmallVector<BasicBlock *> CurrPath,
+                     DenseSet<BasicBlock *> Visited,
+                     SmallVector<SmallVector<BasicBlock *>> &Paths) {
+  Visited.insert(From);
+  CurrPath.push_back(From);
+
+  if (From == To) {
+    Paths.push_back(CurrPath);
+  } else {
+    for (auto SuccIt = succ_begin(From); SuccIt != succ_end(From); SuccIt++) {
+      BasicBlock *Succ = *SuccIt;
+      if (!Visited.count(Succ)) {
+        visitDFS(Succ, To, CurrPath, Visited, Paths);
+      }
+    }
+  }
+  Visited.erase(From);
+}
+
+void RegionReplicator::concretizeBranchConditions(BasicBlock *ExpandedBlock,
+                                                  Region *ReplicatedRegion,
+                                                  ValueToValueMapTy &PHIMap) {
+
+  BasicBlock *Entry = ReplicatedRegion->getEntry();
+  BasicBlock *Exit = ReplicatedRegion->getExit();
+
+  SmallVector<SmallVector<BasicBlock *>> Paths;
+  DenseSet<BasicBlock *> Visited;
+  SmallVector<BasicBlock *> CurrPath;
+
+  // use DFS to enumerate all paths from entry to exit
+  visitDFS(Entry, Exit, CurrPath, Visited, Paths);
+
+  int BestPathIndex = -1;
+  for (unsigned PathIdx = 0; PathIdx < Paths.size(); PathIdx++) {
+    for (auto *BB : Paths[PathIdx]) {
+      if (BB == ExpandedBlock) {
+        if (BestPathIndex == -1)
+          BestPathIndex = PathIdx;
+        else {
+          BestPathIndex = Paths[PathIdx].size() < Paths[BestPathIndex].size()
+                              ? PathIdx
+                              : BestPathIndex;
+        }
+      }
+    }
+  }
+
+  // at least one path must contain ExpandedBlock
+  assert(BestPathIndex != -1 && "None of the paths in replicated region goes "
+                                "through the expanded block!");
+
+  DEBUG << "Path found through the replicated block\n";
+  auto BestPath = Paths[BestPathIndex];
+  // for (unsigned BBIdx = 0; BBIdx < BestPath.size(); BBIdx++) {
+  //   DEBUG << BestPath[BBIdx]->getNameOrAsOperand() << ((BBIdx !=
+  //   BestPath.size() -1 )? " -> " : "\n");
+  // }
+
+  // concretize the branch conditions along the found path
+  Value *TrueV = ConstantInt::getTrue(
+      Type::getInt1Ty(MA.getParentFunction()->getContext()));
+  Value *FalseV = ConstantInt::getFalse(
+      Type::getInt1Ty(MA.getParentFunction()->getContext()));
+  for (unsigned BBIdx = 0; BBIdx < BestPath.size() - 1; BBIdx++) {
+    BasicBlock *BB = BestPath[BBIdx];
+    BasicBlock *BBNext = BestPath[BBIdx + 1];
+
+    BranchInst *BI = dyn_cast<BranchInst>(BB->getTerminator());
+    if (BI->isConditional()) {
+      Value *Cond = (BI->getSuccessor(0) == BBNext) ? TrueV : FalseV;
+      BI->setCondition(Cond);
+    }
+  }
+
+  // now we need to fix the broken def-use chains using the PHIMap
+  // find broken def-use chains for all defs in expanded block
+  BasicBlock *BestPathSecondExit = BestPath[BestPath.size() - 2];
+  SmallVector<std::pair<Instruction *, Instruction *>> BrokenDefUsers;
+  DominatorTree &DT = MA.getCFGInfo().getDomTree();
+  PostDominatorTree &PDT = MA.getCFGInfo().getPostDomTree();
+
+  // checks if a given instruction is inside replicated region
+  auto IsInsideReplicatedRegion = [&](Instruction *I) -> bool {
+    BasicBlock *Parent = I->getParent();
+    return DT.dominates(Entry, Parent) && PDT.dominates(Exit, Parent);
+  };
+
+  // find broken def-user. Defs are inside the expanded block.
+  // users are outside the replicated region
+  for (Instruction &Def : *ExpandedBlock) {
+    for (Use &U : Def.uses()) {
+      Instruction *User = dyn_cast<Instruction>(U.getUser());
+      if (!DT.dominates(&Def, User) && !IsInsideReplicatedRegion(User)) {
+        DEBUG << "Def-Use chain is broken for definition "
+              << Def.getNameOrAsOperand() << " and user "
+              << User->getNameOrAsOperand() << "\n";
+
+        BrokenDefUsers.push_back(
+            std::pair<Instruction *, Instruction *>(&Def, User));
+      }
+    }
+  }
+
+  // if broken def-uses are there we must have PHI nodes in the replicated exit
+  // added by addPhiNodes step
+  if (BrokenDefUsers.size()) {
+    assert(isa<PHINode>(*Exit->begin()) &&
+           "there are broken def-use to fix but replicated exit does not "
+           "contain PHI nodes!");
+  }
+
+  // RAUW phase : for each broken user we find the corresponding defining PHI node 
+  // in the region exit. this PHI node must have non-undef value for the incoming path
+  // selected in concretizeBranchCinditions
+  for (auto &DefUser : BrokenDefUsers) {
+    Instruction *Def = DefUser.first;
+    Instruction *User = DefUser.second;
+    for (auto &PHI : Exit->phis()) {
+
+      Value *PHIVal = dyn_cast<Value>(&PHI);
+
+      if (PHIMap[PHIVal] == dyn_cast<Value>(Def) &&
+          PHI.getIncomingValueForBlock(BestPathSecondExit) !=
+              llvm::UndefValue::get(PHI.getType())) {
+        User->replaceUsesOfWith(Def, PHIVal);
+      }
+    }
+  }
+}
diff --git a/llvm/lib/Transforms/CFMelder/RegionReplicator.h b/llvm/lib/Transforms/CFMelder/RegionReplicator.h
new file mode 100644
index 000000000000..5570a980dbc1
--- /dev/null
+++ b/llvm/lib/Transforms/CFMelder/RegionReplicator.h
@@ -0,0 +1,39 @@
+#ifndef LLVM_LIB_TRANSFORMS_REGION_REPLICATOR_H
+#define LLVM_LIB_TRANSFORMS_REGION_REPLICATOR_H
+
+#include "RegionAnalyzer.h"
+#include "llvm/Analysis/MemorySSAUpdater.h"
+
+namespace llvm {
+
+class RegionReplicator {
+private:
+  RegionAnalyzer &MA;
+  bool IsExpandingLeft;
+  bool EnableFullPredication;
+  // mapping from orig to replicated basic blocks
+  DenseMap<BasicBlock *, BasicBlock *> Mapping;
+
+  // replicate RegionToReplicate and returns replicated entry and exit
+  pair<BasicBlock *, BasicBlock *> replicateCFG(BasicBlock *ExpandedBlock, BasicBlock *MatchedBlock,
+                           Region *RegionToReplicate);
+  void addPhiNodes(BasicBlock *ExpandedBlock, Region *ReplicatedRegion, ValueToValueMapTy &PHIMap);
+  void concretizeBranchConditions(BasicBlock *ExpandedBlock,
+                                  Region *ReplicatedRegion, ValueToValueMapTy &PHIMap);
+  void fullPredicateStores(Region *RToReplicate,
+                                              BasicBlock *MatchedBlock);
+
+public:
+  RegionReplicator(RegionAnalyzer &MA, bool IsExpandingLeft, bool EnableFullPredication)
+      : MA(MA), IsExpandingLeft(IsExpandingLeft), EnableFullPredication(EnableFullPredication) {}
+
+  // expands SingleBB to have the same control flow as R
+  Region *replicate(BasicBlock *ExpandedBlock, BasicBlock *MatchedBlock,
+                    Region *RegionToReplicate);
+  void getBasicBlockMapping(DenseMap<BasicBlock *, BasicBlock *> &Map,
+                            bool IsExpandingLeft);
+};
+
+} // namespace llvm
+
+#endif
\ No newline at end of file
diff --git a/llvm/lib/Transforms/CFMelder/SeqAlignmentUtils.h b/llvm/lib/Transforms/CFMelder/SeqAlignmentUtils.h
new file mode 100644
index 000000000000..af2922b4b98e
--- /dev/null
+++ b/llvm/lib/Transforms/CFMelder/SeqAlignmentUtils.h
@@ -0,0 +1,161 @@
+#ifndef __SEQ_ALIGNMENT_UTIL_H__
+#define __SEQ_ALIGNMENT_UTIL_H__
+
+#include "llvm/Support/raw_ostream.h"
+#include <assert.h>
+#include <functional>
+#include <memory>
+#include <ostream>
+#include <string>
+#include <vector>
+using namespace std;
+
+enum Direction
+{
+  LEFT,
+  TOP,
+  DIAG,
+  NONE
+};
+
+struct Cell
+{
+private:
+  int Cost;
+  Direction Direc;
+  bool IsMatch;
+
+public:
+  Cell(int Value, Direction Direc, bool IsMatch) : Cost(Value), Direc(Direc), IsMatch(IsMatch) {}
+  Cell(const Cell &C) : Cost(C.Cost), Direc(C.Direc), IsMatch(C.IsMatch) {}
+
+  int getCost() const { return Cost; }
+  void setCost(int Value) {Cost = Value;}
+  int getDirection() const {return Direc;}
+  void setDirection(Direction Value) {Direc = Value;}
+  bool getMatch() const {return IsMatch;}
+  friend llvm::raw_ostream &operator<<(llvm::raw_ostream &Os, const Cell &C)
+  {
+    Os << "(" << C.Cost << ",";
+    if (C.Direc == DIAG)
+      Os << "DIAG";
+    else if (C.Direc == TOP)
+      Os << "TOP";
+    else if (C.Direc == LEFT)
+      Os << "LEFT";
+    else
+      Os << "NONE";
+    Os << ",";
+    if (C.IsMatch)
+      Os << "T";
+    else
+      Os << "F";
+    Os << ")";
+
+    return Os;
+  }
+};
+
+class Matrix
+{
+private:
+  vector<vector<Cell>> Data;
+  int Rows, Cols;
+
+public:
+  Matrix(unsigned Rows, unsigned Cols) : Rows(Rows), Cols(Cols)
+  {
+    for (unsigned I = 0; I < Rows + 1; I++)
+    {
+      Data.push_back(vector<Cell>(Cols + 1, Cell(0, NONE, false)));
+    }
+  }
+
+  Cell &operator()(int Row, int Col) { return Data[Row + 1][Col + 1]; }
+  Cell operator()(int Row, int Col) const { return Data[Row + 1][Col + 1]; }
+  int getRows() const { return Rows; }
+  int getCols() const { return Cols; }
+
+  friend llvm::raw_ostream &operator<<(llvm::raw_ostream &Os, const Matrix &M)
+  {
+    for (unsigned I = 0; I < M.getRows(); ++I)
+    {
+      for (unsigned J = 0; J < M.getCols(); ++J)
+      {
+        Os << M(I, J);
+      }
+      Os << "\n";
+    }
+    return Os;
+  }
+
+};
+
+template <typename elemTy>
+struct AlignedPair
+{
+  elemTy EL = nullptr;
+  elemTy ER = nullptr;
+  bool Match = false;
+
+public:
+  AlignedPair(elemTy EL, elemTy ER) : EL(EL), ER(ER), Match(EL && ER) {}
+  AlignedPair(const AlignedPair& Other) {
+    this->EL = Other.getLeft();
+    this->ER = Other.getRight();
+    this->Match = Other.match();
+  }
+  
+  bool match() const { return Match; }
+  bool missMatch() const { return !Match; }
+  elemTy getLeft() const { return EL; }
+  elemTy getRight() const { return ER; }
+  elemTy get(int I) {
+    if (I == 0) return getLeft();
+    return getRight();
+  }
+  friend ostream &operator<<(ostream &Os, const AlignedPair<elemTy> &Ap)
+  {
+    if (Ap.getLeft() != nullptr)
+      Os << *Ap.getLeft();
+    else
+      Os << "_";
+    Os << " : ";
+    if (Ap.getRight() != nullptr)
+      Os << *Ap.getRight();
+    else
+      Os << "_";
+    return Os;
+  }
+
+  
+};
+
+template <typename elemTy>
+class AlignedSeq : public vector<AlignedPair<elemTy>>
+{
+
+public:
+  using vector<AlignedPair<elemTy>>::size;
+  using vector<AlignedPair<elemTy>>::end;
+  using vector<AlignedPair<elemTy>>::begin;
+  using vector<AlignedPair<elemTy>>::reserve;
+  using vector<AlignedPair<elemTy>>::insert;
+
+  AlignedSeq &concat(const AlignedSeq &Other)
+  {
+
+    reserve(size() + Other.size());
+    insert(end(), Other.begin(), Other.end());
+    return *this;
+  }
+};
+
+template<typename elemTy>
+class ScoringFunction {
+public:
+  virtual int operator()(elemTy, elemTy) = 0;
+  virtual int gap(int K) = 0;
+};
+
+#endif
\ No newline at end of file
diff --git a/llvm/lib/Transforms/CFMelder/SmithWaterman.h b/llvm/lib/Transforms/CFMelder/SmithWaterman.h
new file mode 100644
index 000000000000..f4a9f1ac84e2
--- /dev/null
+++ b/llvm/lib/Transforms/CFMelder/SmithWaterman.h
@@ -0,0 +1,184 @@
+#ifndef __SMITH_WATERMAN_H__
+#define __SMITH_WATERMAN_H__
+#include "SeqAlignmentUtils.h"
+#include <assert.h>
+#include <functional>
+#include <memory>
+#include <ostream>
+#include <string>
+using namespace std;
+
+template <typename elemTy, typename ArrayTy, elemTy none_value>
+class SmithWaterman {
+private:
+  ScoringFunction<elemTy> &ScoringFunc;
+  bool AllowMismatches = false;
+
+  AlignedSeq<elemTy> constructSoln(Matrix &M, ArrayTy &Seq1, ArrayTy &Seq2,
+                                   int StartRow, int EndRow, int StartCol,
+                                   int EndCol) {
+    // find the max cost
+    int Maxi = EndRow, Maxj = EndCol;
+    int MaxCost = M(EndRow, EndCol).getCost();
+    for (int I = StartRow; I <= EndRow; ++I) {
+      for (int J = StartCol; J <= EndCol; ++J) {
+        if (M(I, J).getCost() >= MaxCost) {
+          Maxi = I;
+          Maxj = J;
+          MaxCost = M(I, J).getCost();
+        }
+      }
+    }
+    AlignedSeq<elemTy> Soln;
+    int Starti = Maxi;
+    int Startj = Maxj;
+    while (Starti >= StartRow && Startj >= StartCol) {
+      if (M(Starti, Startj).getDirection() == DIAG) {
+        AlignedPair<elemTy> Point(Seq1[Starti], Seq2[Startj]);
+        Soln.insert(Soln.begin(), Point);
+        Starti--;
+        Startj--;
+      } else if (M(Starti, Startj).getDirection() == LEFT) {
+        AlignedPair<elemTy> Point(none_value, Seq2[Startj]);
+        Soln.insert(Soln.begin(), Point);
+        Startj--;
+      } else {
+        AlignedPair<elemTy> Point(Seq1[Starti], none_value);
+        Soln.insert(Soln.begin(), Point);
+        Starti--;
+      }
+    }
+
+    // find the reminder solns from end of the Matrix
+    if (Maxi < EndRow && Maxj < EndCol) {
+      auto SolnRight =
+          constructSoln(M, Seq1, Seq2, Maxi + 1, EndRow, Maxj + 1, EndCol);
+      Soln.concat(SolnRight);
+    }
+
+    // add any remainder from the begining of the Matrix
+    while (Starti >= StartRow) {
+      AlignedPair<elemTy> Point(Seq1[Starti], none_value);
+      Soln.insert(Soln.begin(), Point);
+      Starti--;
+    }
+    while (Startj >= StartCol) {
+      AlignedPair<elemTy> Point(none_value, Seq2[Startj]);
+      Soln.insert(Soln.begin(), Point);
+      Startj--;
+    }
+
+    // add any remainder from the end of the Matrix
+    if (Maxj == EndCol) {
+      Maxi++;
+      while (Maxi <= EndRow) {
+        AlignedPair<elemTy> Point(Seq1[Maxi], none_value);
+        Soln.insert(Soln.end(), Point);
+        Maxi++;
+      }
+    }
+
+    if (Maxi == EndRow) {
+      Maxj++;
+      while (Maxj <= EndCol) {
+        AlignedPair<elemTy> Point(none_value, Seq2[Maxj]);
+        Soln.insert(Soln.end(), Point);
+        Maxj++;
+      }
+    }
+
+    return Soln;
+  }
+
+  int findMaxGapProfit(Matrix &m, int i, int j, Direction d) {
+    assert((d == Direction::LEFT || d == Direction::TOP) &&
+           "invalid direction for findMaxGapProfit");
+    int MaxGapProit = m(i, j).getCost() - ScoringFunc.gap(0);
+    if (d == Direction::LEFT) {
+      int Idx = j, GapLen = 1;
+      while (Idx >= 0) {
+        MaxGapProit = max(MaxGapProit,
+                          m(i, j - GapLen).getCost() - ScoringFunc.gap(GapLen));
+        Idx--;
+        GapLen++;
+      }
+
+    } else if (d == Direction::TOP) {
+      int Idx = i, GapLen = 1;
+      while (Idx >= 0) {
+        MaxGapProit = max(MaxGapProit,
+                          m(i - GapLen, j).getCost() - ScoringFunc.gap(GapLen));
+        Idx--;
+        GapLen++;
+      }
+    }
+    return MaxGapProit;
+  }
+
+public:
+  SmithWaterman(ScoringFunction<elemTy> &ScoringFunc,
+                bool AllowMismatches = false)
+      : ScoringFunc(ScoringFunc), AllowMismatches(AllowMismatches) {}
+
+  AlignedSeq<elemTy> compute(ArrayTy &Seq1, ArrayTy &Seq2) {
+    Matrix M(Seq1.size(), Seq2.size());
+
+    for (unsigned i = 0; i < M.getRows(); ++i) {
+      for (unsigned j = 0; j < M.getCols(); ++j) {
+
+        int DiagCost =
+            M(i - 1, j - 1).getCost() + ScoringFunc(Seq1[i], Seq2[j]);
+        int LeftCost = findMaxGapProfit(M, i, j - 1, Direction::LEFT);
+        int TopCost = findMaxGapProfit(M, i - 1, j, Direction::TOP);
+        int Cost = DiagCost;
+        Direction D = DIAG;
+        bool IsMatch = ScoringFunc(Seq1[i], Seq2[j]) == 0 ? false : true;
+
+        if (Cost < LeftCost) {
+          D = LEFT;
+          Cost = LeftCost;
+          IsMatch = false;
+        }
+
+        if (Cost < TopCost) {
+          D = TOP;
+          Cost = TopCost;
+          IsMatch = false;
+        }
+
+        if (Cost < 0) {
+          Cost = 0;
+        }
+
+        M(i, j) = Cell(Cost, D, IsMatch);
+      }
+    }
+    // llvm::errs() << M << "\n";
+    auto Soln =
+        constructSoln(M, Seq1, Seq2, 0, M.getRows() - 1, 0, M.getCols() - 1);
+
+    // remove mismatches if not allowed
+    if (!AllowMismatches) {
+      AlignedSeq<elemTy> MisMatchesRmvdSoln;
+      for (auto Entry : Soln) {
+        auto Left = Entry.getLeft();
+        auto Right = Entry.getRight();
+
+        if (Left != none_value && Right != none_value &&
+            ScoringFunc(Left, Right) == 0) {
+          AlignedPair<elemTy> AP1(Left, none_value);
+          AlignedPair<elemTy> AP2(none_value, Right);
+          MisMatchesRmvdSoln.push_back(AP1);
+          MisMatchesRmvdSoln.push_back(AP2);
+        } else {
+          MisMatchesRmvdSoln.push_back(Entry);
+        }
+      }
+      return MisMatchesRmvdSoln;
+    }
+
+    return Soln;
+  }
+};
+
+#endif
\ No newline at end of file
diff --git a/llvm/lib/Transforms/CMakeLists.txt b/llvm/lib/Transforms/CMakeLists.txt
index dda5f6de11e3..02557749efae 100644
--- a/llvm/lib/Transforms/CMakeLists.txt
+++ b/llvm/lib/Transforms/CMakeLists.txt
@@ -9,3 +9,4 @@ add_subdirectory(Hello)
 add_subdirectory(ObjCARC)
 add_subdirectory(Coroutines)
 add_subdirectory(CFGuard)
+add_subdirectory(CFMelder)
diff --git a/llvm/tools/bugpoint/CMakeLists.txt b/llvm/tools/bugpoint/CMakeLists.txt
index d64481df1c1c..eb8d46e51f81 100644
--- a/llvm/tools/bugpoint/CMakeLists.txt
+++ b/llvm/tools/bugpoint/CMakeLists.txt
@@ -20,6 +20,7 @@ set(LLVM_LINK_COMPONENTS
   Target
   TransformUtils
   Vectorize
+  CFMelder
   )
 
 add_llvm_tool(bugpoint
diff --git a/llvm/tools/opt/CMakeLists.txt b/llvm/tools/opt/CMakeLists.txt
index 1396e4dc988d..aca1a78cb2ae 100644
--- a/llvm/tools/opt/CMakeLists.txt
+++ b/llvm/tools/opt/CMakeLists.txt
@@ -25,6 +25,7 @@ set(LLVM_LINK_COMPONENTS
   TransformUtils
   Vectorize
   Passes
+  CFMelder
   )
 
 add_llvm_tool(opt
diff --git a/llvm/tools/opt/opt.cpp b/llvm/tools/opt/opt.cpp
index 7793a5471793..0f623bfb47d2 100644
--- a/llvm/tools/opt/opt.cpp
+++ b/llvm/tools/opt/opt.cpp
@@ -543,6 +543,7 @@ int main(int argc, char **argv) {
   initializeAnalysis(Registry);
   initializeTransformUtils(Registry);
   initializeInstCombine(Registry);
+  initializeCFMelder(Registry);
   initializeAggressiveInstCombine(Registry);
   initializeInstrumentation(Registry);
   initializeTarget(Registry);
-- 
2.32.0


From 81c3fc0d0ab34657b36c8eab36999a87b9f1ca71 Mon Sep 17 00:00:00 2001
From: Charitha Saumya <cgusthin@purdue.edu>
Date: Sun, 5 Nov 2023 02:20:14 -0500
Subject: [PATCH 2/3] control flow melding pass with llvm-14

---
 cfm_tests/cfg/config.mk | 2 --
 1 file changed, 2 deletions(-)

diff --git a/cfm_tests/cfg/config.mk b/cfm_tests/cfg/config.mk
index 381fb93e3e3e..948e169da61f 100644
--- a/cfm_tests/cfg/config.mk
+++ b/cfm_tests/cfg/config.mk
@@ -1,6 +1,4 @@
-LLVM_HOME=/home/min/a/cgusthin/git/llvm-project-rocm/build_codesize
 clang=$(LLVM_HOME)/bin/clang
 opt=$(LLVM_HOME)/bin/opt
 lli=$(LLVM_HOME)/bin/lli
-#pass_location=$(LLVM_HOME)/lib/LLVMCFMelderPlugin.so
 cfmerger_flags=-cfmelder  -S -force-cf-merging 
-- 
2.32.0


From 9f3a31d77a54d50e101376d316328db560bf801c Mon Sep 17 00:00:00 2001
From: Charitha Saumya <cgusthin@purdue.edu>
Date: Sun, 5 Nov 2023 02:28:58 -0500
Subject: [PATCH 3/3] control flow melding pass with llvm-14

---
 scripts/build_install.sh |  8 ++++++++
 scripts/run_cmake.sh     | 13 +++++++++++++
 2 files changed, 21 insertions(+)
 create mode 100644 scripts/build_install.sh
 create mode 100644 scripts/run_cmake.sh

diff --git a/scripts/build_install.sh b/scripts/build_install.sh
new file mode 100644
index 000000000000..b2ce9db04654
--- /dev/null
+++ b/scripts/build_install.sh
@@ -0,0 +1,8 @@
+#!/bin/bash
+DIR=$(dirname $0)
+cd ${DIR}/../build/
+cmake --build . --target opt -j16
+cmake --build . --target clang -j16
+cmake --build . --target lli -j16
+#cmake --build . --target install -j
+cd ..
diff --git a/scripts/run_cmake.sh b/scripts/run_cmake.sh
new file mode 100644
index 000000000000..0981e906df4e
--- /dev/null
+++ b/scripts/run_cmake.sh
@@ -0,0 +1,13 @@
+#!/bin/bash
+DIR=$(dirname $0)
+cd ${DIR}/..
+
+# lld is often faster but needs an existing llvm installation
+LINKER=gold
+#LINKER=lld
+
+# Ninja is a bit faster than make. uncomment it if you have it
+GNRTOR="Unix Makefiles"
+#GNRTOR="Ninja"
+
+cmake -G "$GNRTOR" -DLLVM_ENABLE_PROJECTS='clang' -DCMAKE_BUILD_TYPE="Release" -DLLVM_ENABLE_ASSERTIONS=On -B build -DLLVM_TARGETS_TO_BUILD=X86 -DLLVM_INCLUDE_TESTS=OFF -DLLVM_USE_LINKER=$LINKER -DCMAKE_INSTALL_PREFIX=install llvm 
\ No newline at end of file
-- 
2.32.0

